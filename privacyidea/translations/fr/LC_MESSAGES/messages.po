# French translations for PROJECT.
# Copyright (C) 2020 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
# sebastien C <sebastien.netknights@outlook.com>, 2023, 2025.
# Gregory Bouzinac <gregory.b@orange.fr>, 2024, 2025.
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: translations@privacyidea.org\n"
"POT-Creation-Date: 2025-04-04 01:39+0200\n"
"PO-Revision-Date: 2025-04-04 09:18+0000\n"
"Last-Translator: Gregory Bouzinac <gregory.b@orange.fr>\n"
"Language-Team: French <https://hosted.weblate.org/projects/privacyidea/"
"branch-3-11/fr/>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n > 1;\n"
"X-Generator: Weblate 5.11-dev\n"
"Generated-By: Babel 2.12.1\n"

#: api/auth.py:231
msgid "Authentication with passkey disabled."
msgstr "Authentification avec clé d'accès désactivée."

#: api/auth.py:236
msgid "Authentication failure. The passkey is not registered."
msgstr "Échec de l'authentification. La clé d'accès n'est pas enregistrée."

#: api/auth.py:239
msgid "Authentication failure. Token has no user."
msgstr "Échec de l'authentification. Le jeton n'a pas d'utilisateur."

#: api/auth.py:250
msgid "Authentication failure using passkey."
msgstr "Échec de l'authentification en utilisant la clé d'accès."

#: api/auth.py:255
msgid "Authentication failure. Unknown realm:"
msgstr "Échec de l'authentification. Domaine inconnu :"

#: api/auth.py:259
msgid "Authentication failure. Missing Username"
msgstr "Échec de l'authentification. Nom d'utilisateur manquant"

#: api/auth.py:378
msgid "Authentication failure. Wrong credentials"
msgstr "Échec de l'authentification. Identifiants invalides"

#: api/realm.py:528
msgid "The given node does not exist!"
msgstr "Le nœud spécifié n'existe pas  !"

#: api/realm.py:534 api/realm.py:544
msgid "Could not verify data in request!"
msgstr "Impossible de vérifier les données dans la requête !"

#: api/validate.py:466 lib/token.py:2608
msgid "Found matching challenge"
msgstr "Challenge correspondant trouvé"

#: api/lib/postpolicy.py:88
#, python-brace-format
msgid ""
"\n"
"<--- Please describe your Problem in detail --->\n"
"\n"
"<--- Please provide as many additional information as possible --->\n"
"\n"
"privacyIDEA Version: {version}\n"
"Subscriber: {subscriber_name}\n"
"Subscriptions: {subscriptions}\n"
msgstr ""
"\n"
"<--- Veuillez décrire votre problème en détail --->\n"
"\n"
"<--- Veuillez fournir autant d'informations que possible --->\n"
"\n"
"Version privacyIDEA : {version}\n"
"Nom : {subscriber_name}\n"
"Abonnements : {subscriptions}\n"

#: api/lib/prepolicy.py:2476
#, python-brace-format
msgid "Missing description for {} token."
msgstr "Description manquante pour le jeton {}."

#: api/lib/prepolicy.py:2477
#, python-brace-format
msgid "Description required for {} token."
msgstr "Description requise pour le jeton {}."

#: api/lib/utils.py:400
msgid "Authentication failure. Missing Authorization header."
msgstr "Échec de l'authentification. Entête Autorisation manquante."

#: api/lib/utils.py:405 api/lib/utils.py:436
msgid "Authentication failure. Error decoding the Authorization token:"
msgstr ""
"Échec de l'authentification. Erreur lors du décodage de l'autorisation du "
"jeton :"

#: api/lib/utils.py:429 api/lib/utils.py:439
msgid "Authentication failure. Your token has expired:"
msgstr "Échec de l'authentification. Votre jeton a expiré :"

#: api/lib/utils.py:442
#, python-brace-format
msgid ""
"Authentication failure. The username {wrong_username} is not allowed to "
"impersonate via JWT."
msgstr ""
"Échec de l'authentification. Le nom d'utilisateur {wrong_username} n'est pas "
"autorisé via JWT."

#: api/lib/utils.py:447
#, python-brace-format
msgid ""
"Authentication failure. You do not have the necessary role ({required_role}) "
"to access this resource!"
msgstr ""
"Échec de l'authentification. Vous n'avez pas le rôle requis "
"({required_role}) pour accéder à cette ressource !"

#: api/lib/utils.py:464
msgid "Invalid policy name:"
msgstr "Nom de politique non valide :"

#: api/lib/utils.py:467
msgid "The name of the policy may only contain the characters a-zA-Z0-9_. -"
msgstr ""
"Le nom de la politique ne peut contenir que les caractères a-zA-Z0-9_. -"

#: lib/challengeresponsedecorators.py:149
msgid "Please enter the new PIN again"
msgstr "Veuillez entrer à nouveau le nouveau code PIN"

#: lib/challengeresponsedecorators.py:163
msgid "Please enter a new PIN"
msgstr "Veuillez entrer un nouveau code PIN"

#: lib/challengeresponsedecorators.py:201
msgid "To resync your token, please enter the next OTP value"
msgstr ""
"Pour resynchroniser votre jeton, veuillez entrer la prochaine valeur OTP"

#: lib/containerclass.py:802
msgid ""
"General purpose container that can hold any type and any number of token."
msgstr ""
"Conteneur à usage général pouvant contenir n'importe quel type et nombre de "
"jetons."

#: lib/decorators.py:43 lib/token.py:2468
msgid "This action is not possible, since the token is locked"
msgstr "Cette action n'est pas possible, car le jeton est verrouillé"

#: lib/decorators.py:87
msgid "You either need to provide user or serial"
msgstr "Vous devez fournir soit un utilisateur soit un numéro de série"

#: lib/decorators.py:114
msgid "You need to specify a serial, user or credential_id."
msgstr ""
"Vous devez spécifier un numéro de série, un utilisateur ou des informations "
"d'identification."

#: lib/decorators.py:116
msgid "Invalid serial number."
msgstr "Numéro de série invalide."

#: lib/decorators.py:118
msgid "Invalid user."
msgstr "Utilisateur invalide."

#: lib/policy.py:205
msgid ""
"Note: If you use a comma in the message, you need to escape it with a "
"backslash."
msgstr ""
"Note : Si vous utilisez une virgule dans le message, vous devez l'échapper "
"avec une barre oblique inversée."

#: lib/policy.py:1455
msgid "Invalid client definition!"
msgstr "Définition du client invalide !"

#: lib/policy.py:1650
msgid "Define in which resolver the user should be registered."
msgstr "Définir dans quel résolveur l'utilisateur devrait être enregistré."

#: lib/policy.py:1654
msgid "Define in which realm the user should be registered."
msgstr "Définir dans quel royaume l'utilisateur devrait être enregistré."

#: lib/policy.py:1658
msgid ""
"The SMTP server configuration, that should be used to send the registration "
"email."
msgstr ""
"La configuration SMTP du serveur qui doit être utilisée pour envoyer le "
"courriel d'inscription."

#: lib/policy.py:1662
msgid ""
"Only users with this email address are allowed to register. This is a "
"regular expression."
msgstr ""
"Seuls les utilisateurs avec cette adresse électronique sont autorisés à "
"s'inscrire. C'est une expression régulière."

#: lib/policy.py:1667
#, python-brace-format
msgid ""
"The body of the registration email. Use '{regkey}' as tag for the "
"registration key."
msgstr ""
"Le corps du courriel d'inscription. Utilisez '{regkey}' comme balise pour la "
"clé d'inscription."

#: lib/policy.py:1673
msgid "Admin is allowed to enable tokens."
msgstr "L'administrateur est autorisé à activer les jetons."

#: lib/policy.py:1677
msgid "Admin is allowed to disable tokens."
msgstr "L'administrateur est autorisé a désactiver les jetons."

#: lib/policy.py:1682
msgid "Admin is allowed to set token properties."
msgstr "L'administrateur est autorisé à définir les propriétés d'un jeton."

#: lib/policy.py:1686
msgid "The admin is allowed to set the token description."
msgstr "L'administrateur est autorisé à définir la description du jeton."

#: lib/policy.py:1691
msgid "Admin is allowed to set the OTP PIN of tokens."
msgstr "L'administrateur est autorisé à définir le PIN OTP des jetons."

#: lib/policy.py:1696
msgid "Admin is allowed to set a random OTP PIN of tokens."
msgstr ""
"L'administrateur est autorisé à définir un PIN OTP aléatoire pour les jetons."

#: lib/policy.py:1700
msgid "Admin is allowed to manually set and delete token info."
msgstr ""
"L'administrateur est autorisé à définir et supprimer manuellement les "
"informations des jetons."

#: lib/policy.py:1704
msgid "Admin is allowed to set the OTP PIN during enrollment."
msgstr ""
"L'administrateur est autorisé à définir un PIN OTP pendant l'enrôlement."

#: lib/policy.py:1709
msgid "Admin is allowed to resync tokens."
msgstr "L'administrateur est autorisé à resynchroniser les jetons."

#: lib/policy.py:1714
msgid "Admin is allowed to reset the Failcounter of a token."
msgstr ""
"L'administrateur est autorisé à réinitialiser le compteur d'échecs d'un "
"jeton."

#: lib/policy.py:1719
msgid "Admin is allowed to revoke a token"
msgstr "L'administrateur est autorisé à révoquer un jeton"

#: lib/policy.py:1724
msgid "Admin is allowed to assign a token to a user."
msgstr "L'administrateur est autorisé à assigner un jeton à un utilisateur."

#: lib/policy.py:1730
msgid ""
"Admin is allowed to remove the token from a user, i.e. unassign a token."
msgstr ""
"L'administrateur est autorisé à supprimer le jeton d'un utilisateur, c'est-à-"
"dire supprimer l'assignation d'un jeton."

#: lib/policy.py:1736
msgid "Admin is allowed to import token files."
msgstr "L'administrateur est autorisé à importer des fichiers de jetons."

#: lib/policy.py:1741
msgid "Admin is allowed to remove tokens from the database."
msgstr ""
"L'administrateur est autorisé à supprimer des jetons de la base de données."

#: lib/policy.py:1747
msgid "Admin is allowed to view the list of the users."
msgstr "L'administrateur est autorisé à consulter la liste des utilisateurs."

#: lib/policy.py:1752
msgid "The Admin is allowed to list the machines."
msgstr "L'administrateur est autorisé à lister les machines."

#: lib/policy.py:1757
msgid "The Admin is allowed to attach and detach tokens to machines."
msgstr ""
"L'administrateur est autorisé à rattacher et détacher des jetons à des "
"machines."

#: lib/policy.py:1764
msgid ""
"The Admin is allowed to fetch authentication items of tokens assigned to "
"machines."
msgstr ""
"L'administrateur est autorisé à récupérer les éléments d'authentification "
"des jetons assignés aux machines."

#: lib/policy.py:1769
msgid "Admin is allowed to manage the realms of a token."
msgstr "L'administrateur est autorisé à gérer les domaines d'un jeton."

#: lib/policy.py:1774
msgid "Admin is allowed to list tokens."
msgstr "L'administrateur est autorisé à lister les jetons."

#: lib/policy.py:1778
msgid "Admin is allowed to retrieve a serial for a given OTP value."
msgstr ""
"L'administrateur est autorisé à récupérer un numéro de série pour une valeur "
"OTP donnée."

#: lib/policy.py:1783
msgid "Admin is allowed to retrieve random keys from privacyIDEA."
msgstr ""
"L'administrateur est autorisé à récupérer des clés aléatoires depuis "
"privacyIDEA."

#: lib/policy.py:1788
msgid "Admin is allowed to copy the PIN of one token to another token."
msgstr ""
"L'administrateur est autorisé à copier le code PIN d'un jeton vers un autre "
"jeton."

#: lib/policy.py:1793
msgid ""
"Admin is allowed to copy the assigned user to another token, i.e. assign a "
"user to another token."
msgstr ""
"L'administrateur est autorisé à copier l'utilisateur assigné vers un autre "
"jeton, c'est-à-dire assigner un utilisateur à un autre jeton."

#: lib/policy.py:1798
msgid "Admin is allowed to trigger the lost token workflow."
msgstr "L'administrateur est autorisé à déclencher le workflow de jeton perdu."

#: lib/policy.py:1804
msgid "Admin is allowed to write and modify the system configuration."
msgstr ""
"L'administrateur est autorisé à écrire et modifier la configuration du "
"système."

#: lib/policy.py:1809
msgid "Admin is allowed to delete keys in the system configuration."
msgstr ""
"L'administrateur est autorisé à supprimer des clés dans la configuration du "
"système."

#: lib/policy.py:1815
msgid "Admin is allowed to read basic system configuration."
msgstr ""
"L'administrateur est autorisé à lire les informations de base de la "
"configuration du système."

#: lib/policy.py:1820
msgid ""
"Admin is allowed to export a documentation of the complete configuration "
"including resolvers and realm."
msgstr ""
"L'administrateur est autorisé à exporter la documentation de la "
"configuration complète avec les interpréteurs et domaines."

#: lib/policy.py:1828
msgid "Admin is allowed to write and modify the policies."
msgstr "L'administrateur est autorisé à écrire et modifier les politiques."

#: lib/policy.py:1833
msgid "Admin is allowed to delete policies."
msgstr "L'administrateur est autorisé à supprimer des politiques."

#: lib/policy.py:1838
msgid "Admin is allowed to read policies."
msgstr "L'administrateur est autorisé à lire les politiques."

#: lib/policy.py:1842
msgid ""
"Admin is allowed to write and modify the resolver and realm configuration."
msgstr ""
"L'administrateur est autorisé à écrire et modifier la configuration des "
"resolvers et des domaines."

#: lib/policy.py:1849
msgid "Admin is allowed to delete resolvers and realms."
msgstr ""
"L'administrateur est autorisé à supprimer des resolvers et des domaines."

#: lib/policy.py:1854
msgid "Admin is allowed to read resolvers."
msgstr "L'administrateur est autorisé à lire les resolvers."

#: lib/policy.py:1858
msgid ""
"Admin is allowed to create new CA Connector definitions and modify existing "
"ones."
msgstr ""
"L'administrateur est autorisé à créer de nouvelles définitions de Connecteur "
"CA et à modifier les définitions existantes."

#: lib/policy.py:1864
msgid "Admin is allowed to delete CA Connector definitions."
msgstr ""
"L'administrateur est autorisé à supprimer des définitions de Connecteur CA."

#: lib/policy.py:1869
msgid "Admin is allowed to read CA Connector definitions."
msgstr "L'administrateur est autorisé à lire les définitions de Connecteur CA."

#: lib/policy.py:1874
msgid "Admin is allowed to write and modify the machine resolvers."
msgstr ""
"L'administrateur est autorisé à écrire et modifier des resolvers de machine."

#: lib/policy.py:1880
msgid "Admin is allowed to delete machine resolvers."
msgstr "L'administrateur est autorisé à supprimer des resolvers de machine."

#: lib/policy.py:1886
msgid "Admin is allowed to read machine resolvers."
msgstr "L'administrateur est autorisé à lire les resolvers de machine."

#: lib/policy.py:1893 lib/policy.py:2231
msgid "Set the maximum allowed length of the OTP PIN."
msgstr "Définir la longueur maximale autorisée du OTP PIN."

#: lib/policy.py:1898 lib/policy.py:2235
msgid "Set the minimum required length of the OTP PIN."
msgstr "Définir la longueur minimale autorisée du OTP PIN."

#: lib/policy.py:1902
msgid ""
"Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
"(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgstr ""
"Spécifier le contenu requis de l'OTP PIN. (l)ettres, (c)hiffres, caractères "
"(s)péciaux. Utiliser les boutons +/- ou une liste de caractères autorisés "
"[1234567890]"

#: lib/policy.py:1911
msgid "The length of a random PIN set by the administrator."
msgstr ""
"La longueur d'un code PIN généré aléatoirement défini par l'administrateur."

#: lib/policy.py:1914
msgid "Admin is allowed to view the Audit log."
msgstr "L'administrateur est autorisé à consulter le journal d'audit."

#: lib/policy.py:1918
msgid "The admin will only see audit entries of the last 10d, 3m or 2y."
msgstr ""
"L'administrateur verra uniquement les entrées d'audit des 10 derniers jours, "
"3 derniers mois ou 2 dernières années."

#: lib/policy.py:1923
msgid "The admin will not see the specified columns in the audit."
msgstr "L'administrateur ne verra pas les colonnes spécifiées dans l'audit."

#: lib/policy.py:1928
msgid "The admin is allowed to download the complete auditlog."
msgstr ""
"L'administrateur est autorisé à télécharger le journal d'audit complet."

#: lib/policy.py:1933
msgid "Admin is allowed to add users in a userstore/UserIdResolver."
msgstr ""
"L'administrateur est autorisé à ajouter des utilisateurs dans un magasin "
"d'utilisateur/UserIdResolver."

#: lib/policy.py:1938
msgid "Admin is allowed to update the users data in a userstore."
msgstr ""
"L'administrateur est autorisé à mettre à jour les données des utilisateurs "
"dans la base des utilisateurs."

#: lib/policy.py:1943
msgid "Admin is allowed to delete a user object in a userstore."
msgstr ""
"L'administrateur est autorisé à supprimer des objets utilisateurs dans la "
"base d'utilisateurs."

#: lib/policy.py:1948
msgid "Admin is allowed to set the password of the HSM/Security Module."
msgstr ""
"L'administrateur est autorisé à définir le mot de passe du module HSM/"
"Security."

#: lib/policy.py:1952
msgid "Admin is allowed to retrieve the list of active challenges."
msgstr ""
"L'administrateur est autorisé à récupérer la liste des challenges actifs."

#: lib/policy.py:1958
msgid "Admin is allowed to write new SMTP server definitions."
msgstr ""
"L'administrateur est autorisé à écrire de nouvelles définitions du serveur "
"SMTP."

#: lib/policy.py:1963
msgid "Admin is allowed to read SMTP server definitions."
msgstr "L'administrateur est autorisé à lire les définitions du serveur SMTP."

#: lib/policy.py:1968
msgid "Admin is allowed to write new RADIUS server definitions."
msgstr ""
"L'administrateur est autorisé à écrire de nouvelles définitions du serveur "
"RADIUS."

#: lib/policy.py:1974
msgid "Admin is allowed to read RADIUS server definitions."
msgstr ""
"L'administrateur est autorisé à lire les définitions du serveur RADIUS."

#: lib/policy.py:1979
msgid "Admin is allowed to write remote privacyIDEA server definitions."
msgstr ""
"L'administrateur est autorisé à écrire des définitions sur le serveur "
"privacyIDEA distant."

#: lib/policy.py:1986
msgid "Admin is allowed to read remote privacyIDEA server definitions."
msgstr ""
"L'administrateur est autorisé à lire les définitions du serveur privacyIDEA "
"distant."

#: lib/policy.py:1993
msgid "Admin is allowed to write periodic task definitions."
msgstr ""
"L'administrateur est autorisé à écrire des définitions de tâches périodiques."

#: lib/policy.py:1998
msgid "Admin is allowed to read periodic task definitions."
msgstr ""
"L'administrateur est autorisé à lire les définitions des tâches périodiques."

#: lib/policy.py:2003
msgid "Admin is allowed to read statistics data."
msgstr "L'administrateur est autorisé à lire les données statistiques."

#: lib/policy.py:2006
msgid "Admin is allowed to delete statistics data."
msgstr "L'administrateur est autorisé à supprimer les données statistiques."

#: lib/policy.py:2009
msgid "Admin is allowed to write and modify the event handling configuration."
msgstr ""
"L'administrateur est autorisé à écrire et modifier des configurations de "
"gestion d'événements."

#: lib/policy.py:2015
msgid "Admin is allowed to read event handling configuration."
msgstr ""
"L'administrateur est autorisé à lire les configurations de gestion "
"d'événements."

#: lib/policy.py:2020
msgid "Admin is allowed to write and modify SMS gateway definitions."
msgstr ""
"L'administrateur est autorisé à écrire et modifier des définitions de "
"passerelles SMS."

#: lib/policy.py:2026
msgid "Admin is allowed to read SMS gateway definitions."
msgstr ""
"L'administrateur est autorisé à lire les définitions de passerelles SMS."

#: lib/policy.py:2031
msgid ""
"Admin is allowed to get the list of authenticated clients and their types."
msgstr ""
"L'administrateur est autorisé à récupérer la liste des clients authentifiés "
"et leur type."

#: lib/policy.py:2038
msgid "Admin is allowed to add and delete component subscriptions."
msgstr ""
"L'administrateur est autorisé à ajouter et supprimer des souscription de "
"composants."

#: lib/policy.py:2044
msgid "The Admin is allowed to trigger a challenge for e.g. SMS OTP token."
msgstr ""
"L'administrateur est autorisé à déclencher un défi pour, par exemple, les "
"jetons SMS OTP."

#: lib/policy.py:2050
msgid ""
"The Admin is allowed to set certain custom user attributes. If the Admin "
"should be allowed to set any attribute, set this to '*:*'. For more details, "
"check the documentation."
msgstr ""
"L'administrateur est autorisé à positionner certains attributs utilisateurs "
"personnalisés. Si l'administrateur doit être autorisé à positionner "
"n'importe quel attribut, positionnez la valeur à '*:*'. Pour plus de "
"détails, regardez la documentation."

#: lib/policy.py:2058
msgid ""
"The Admin is allowed to delete certain custom user attributes. If the Admin "
"should be allowed to delete any attribute, set this to '*'. For more "
"details, check the documentation."
msgstr ""
"L'administrateur est autorisé à supprimer certains attributs utilisateurs "
"personnalisés. Si l'administrateur doit être autorisé à supprimer n'importe "
"quel attribut, positionnez la valeur à '*:*'. Pour plus de détails, regardez "
"la documentation."

#: lib/policy.py:2066
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the admin."
msgstr ""
"Liste de type de jetons séparés par des espaces, qui sera affichée dans une "
"liste déroulante dans les détails du jeton."

#: lib/policy.py:2071
msgid "The Admin is allowed list the available tokengroups."
msgstr ""
"L'administrateur est autorisé à lister les groupes de jetons disponibles."

#: lib/policy.py:2076
msgid "The Admin is allowed to add a new tokengroup."
msgstr "L'administrateur est autorisé à ajouter un nouveau groupe de jetons."

#: lib/policy.py:2081
msgid "The Admin is allowed delete a tokengroup."
msgstr "L'administrateur est autorisé à supprimer un groupe de jetons."

#: lib/policy.py:2086
msgid "The Admin is allowed list the available service ID definitions."
msgstr ""
"L'administrateur est autorisé à lister les définitions des services ID "
"disponibles."

#: lib/policy.py:2091
msgid "The Admin is allowed to add a new service ID definition."
msgstr "L'administrateur est autorisé à ajouter un nouveau service ID."

#: lib/policy.py:2096
msgid "The Admin is allowed delete a service ID definition."
msgstr ""
"L'administrateur est autorisé à supprimer une définition d'ID de service."

#: lib/policy.py:2101
msgid "The Admin is allowed to manage the tokengroups of a token."
msgstr "L'administrateur est autorisé à gérer les groupes d'un jeton."

#: lib/policy.py:2105
msgid "Admin is allowed to edit the container info."
msgstr "L'administrateur est autorisé à éditer les informations du conteneur."

#: lib/policy.py:2109
msgid "Admin is allowed to edit the container state."
msgstr "L'administrateur est autorisé à éditer l'état du conteneur."

#: lib/policy.py:2113
msgid "Admin is allowed to edit the container description."
msgstr "L'administrateur est autorisé à éditer la description du conteneur."

#: lib/policy.py:2117
msgid "Admin is allowed to create containers."
msgstr "L'administrateur est autorisé à créer des conteneurs."

#: lib/policy.py:2121
msgid "Admin is allowed to delete containers."
msgstr "L'administrateur est autorisé à supprimer des conteneurs."

#: lib/policy.py:2125
msgid "Admin is allowed to add tokens to containers."
msgstr "L'administrateur est autorisé à ajouter des jetons aux conteneurs."

#: lib/policy.py:2129
msgid "Admin is allowed to remove tokens from containers."
msgstr "L'administrateur est autorisé à supprimer des jetons des conteneurs."

#: lib/policy.py:2133
msgid "Admin is allowed to assign users to containers."
msgstr ""
"L'administrateur est autorisé à assigner des utilisateurs aux conteneurs."

#: lib/policy.py:2137
msgid "Admin is allowed to unassign users from containers."
msgstr ""
"L'administrateur est autorisé à désassigner des utilisateurs des conteneurs."

#: lib/policy.py:2141
msgid "Admin is allowed to set the realm of containers."
msgstr "L'administrateur est autorisé à définir le domaine des conteneurs."

#: lib/policy.py:2145
msgid "Admin is allowed to list containers."
msgstr "L'administrateur est autorisé à lister les conteneurs."

#: lib/policy.py:2149
msgid "Admin is allowed to register containers."
msgstr "L'administrateur est autorisé à enregistrer des conteneurs."

#: lib/policy.py:2153
msgid "Admin is allowed to unregister containers."
msgstr "L'administrateur est autorisé à désinscrire des conteneurs."

#: lib/policy.py:2157
msgid ""
"Admin is allowed to perform a container rollover including a rollover of all "
"contained tokens."
msgstr ""
"L'administrateur est autorisé à faire un roulement de conteneur incluant un "
"roulement de tous les jetons contenus."

#: lib/policy.py:2162
msgid "Admin is allowed to create and edit container templates."
msgstr ""
"L'administrateur est autorisé à créer et modifier des modèles de conteneur."

#: lib/policy.py:2166
msgid "Admin is allowed to delete templates."
msgstr "L'administrateur est autorisé à supprimer des modèles."

#: lib/policy.py:2170
msgid "Admin is allowed to list templates and view their details."
msgstr ""
"L'administrateur est autorisé à lister des modèles et à voir leurs détails."

#: lib/policy.py:2177
msgid ""
"The user is allowed to assign an existing token that is not yet assigned "
"using the token serial number."
msgstr ""
"L'utilisateur est autorisé à assigner un jeton existant qui n'est pas encore "
"assigné en utilisant son numéro de série."

#: lib/policy.py:2183
msgid "The user is allowed to disable his own tokens."
msgstr "L'utilisateur est autorisé à désactiver ses propres jetons."

#: lib/policy.py:2187
msgid "The user is allowed to enable his own tokens."
msgstr "L'utilisateur est autorisé à activer ses propres jetons."

#: lib/policy.py:2191
msgid "The user is allowed to delete his own tokens."
msgstr "L'utilisateur est autorisé à supprimer ses propres jetons."

#: lib/policy.py:2195
msgid "The user is allowed to unassign his own tokens."
msgstr ""
"L'utilisateur est autorisé à supprimer l'assignation de ses propres jetons."

#: lib/policy.py:2199
msgid "The user is allowed to resynchronize his tokens."
msgstr "L'utilisateur est autorisé à resynchroniser ses jetons."

#: lib/policy.py:2203
msgid "The user is allowed to revoke a token"
msgstr "L'utilisateur est autorisé à révoquer un jeton"

#: lib/policy.py:2207
msgid "The user is allowed to reset the failcounter of his tokens."
msgstr ""
"L'utilisateur est autorisé à réinitialiser le compteur d'échecs de ses "
"jetons."

#: lib/policy.py:2211
msgid "The user is allowed to set the OTP PIN of his tokens."
msgstr "L'utilisateur est autorisé à définir le PIN OTP de ses jetons."

#: lib/policy.py:2215
msgid "The user is allowed to set a random OTP PIN of his tokens."
msgstr ""
"L'utilisateur est autorisé à définir un PIN OTP aléatoire pour ses jetons."

#: lib/policy.py:2220
msgid "The length of a random PIN set by the user."
msgstr ""
"La longueur d'un code PIN généré aléatoirement défini par l'utilisateur."

#: lib/policy.py:2223
msgid "The user is allowed to set the token description."
msgstr "L'utilisateur est autorisé à définir la description du jeton."

#: lib/policy.py:2227
msgid "The user is allowed to set the OTP PIN during enrollment."
msgstr "L'utilisateur est autorisé à définir un PIN TOP pendant l'enrôlement."

#: lib/policy.py:2238
msgid ""
"Specify the required contents of the OTP PIN. (c)haracters, (n)umeric, "
"(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgstr ""
"Spécifier le contenu requis du PIN OTP. (c)aractères, (n)umériques, "
"caractères (s)péciaux. Utiliser les boutons +/- ou une liste de caractères "
"autorisés [1234567890]"

#: lib/policy.py:2244
msgid "Allow the user to view his own token history."
msgstr "Autoriser l'utilisateur à consulter son propre historique de jetons."

#: lib/policy.py:2247
msgid "The user will only see audit entries of the last 10d, 3m or 2y."
msgstr ""
"L'utilisateur verra uniquement les entrées d'audit des 10 derniers jours, "
"des 3 derniers mois ou des 2 dernières années."

#: lib/policy.py:2250
msgid "The user will not see the specified columns in the audit."
msgstr "L'utilisateur ne verra pas les colonnes spécifiées dans l'audit."

#: lib/policy.py:2254
msgid "The user is allowed to view his own user information."
msgstr "L'utilisateur est autorisé à consulter ses propres informations."

#: lib/policy.py:2257
msgid ""
"The user is allowed to update his own user information, like changing his "
"password."
msgstr ""
"L'utilisateur est autorisé à mettre à jour ses propres informations, comme "
"modifier son mot de passe."

#: lib/policy.py:2262
msgid ""
"The user is allowed to do a password reset in an editable UserIdResolver."
msgstr ""
"L'utilisateur est autorisé à remettre à zéro son mot de passe dans un "
"UserIdResolver éditable."

#: lib/policy.py:2267
msgid ""
"The user is allowed to set certain custom user attributes. If the user "
"should be allowed to set any attribute, set this to '*:*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"L'utilisateur est autorisé à positionner certains attributs utilisateurs "
"personnalisés. Si l'utilisateur doit être autorisé à positionner n'importe "
"quel attribut, positionner la valeur à '*:*'. Utilisez '*' avec PRéCAUTION ! "
"Pour plus de détails, regardez la documentation."

#: lib/policy.py:2274
msgid ""
"The user is allowed to delete certain custom user attributes. If the user "
"should be allowed to delete any attribute, set this to '*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"L'utilisateur est autorisé à supprimer certains attributs utilisateurs "
"personnalisés. Si l'utilisateur doit être autorisé à supprimer n'importe "
"quel attribut, positionner la valeur à '*:*'. Utilisez '*' avec PRéCAUTION ! "
"Pour plus de détails, regardez la documentation."

#: lib/policy.py:2282
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the user."
msgstr ""
"Liste de type de jetons séparés par des espaces, qui sera affichée dans une "
"liste déroulante dans les détails du jeton."

#: lib/policy.py:2288
msgid "Users are allowed to edit the state of their own containers."
msgstr ""
"Les utilisateurs sont autorisés à modifier l'état de leurs propres "
"conteneurs."

#: lib/policy.py:2293
msgid "Users are allowed to edit the description of their own containers."
msgstr ""
"Les utilisateurs sont autorisés à modifier la description de leurs propres "
"conteneurs."

#: lib/policy.py:2297
msgid "Users are allowed to create containers."
msgstr "Les utilisateurs sont autorisés à créer des conteneurs."

#: lib/policy.py:2301
msgid "Users are allowed to delete their own containers."
msgstr "Les utilisateurs sont autorisés à supprimer leurs propres conteneurs."

#: lib/policy.py:2306
msgid "Users are allowed to add their own tokens to their own containers."
msgstr ""
"Les utilisateurs sont autorisés à ajouter leurs jetons à leurs conteneurs."

#: lib/policy.py:2310
msgid "Users are allowed to remove their own tokens from their own containers."
msgstr ""
"Les utilisateurs sont autorisés à supprimer leurs jetons de leurs conteneurs."

#: lib/policy.py:2315
msgid "Users are allowed to assign themselves to containers without an owner."
msgstr ""
"Les utilisateurs sont autorisés à s'assigner des conteneurs sans "
"propriétaire."

#: lib/policy.py:2320
msgid "Users are allowed to unassign themselves from containers."
msgstr "Les utilisateurs sont autorisés à se désassigner de leurs conteneurs."

#: lib/policy.py:2324
msgid "Users are allowed to list their own containers."
msgstr "Les utilisateurs sont autorisés à lister leurs propres conteneurs."

#: lib/policy.py:2329
msgid "Users are allowed to register their own containers."
msgstr ""
"Les utilisateurs sont autorisés à enregistrer leurs propres conteneurs."

#: lib/policy.py:2333
msgid "Users are allowed to unregister containers."
msgstr "Les utilisateurs sont autorisés à désinscrire des conteneurs."

#: lib/policy.py:2337
msgid ""
"Users are allowed to perform a container rollover of their own containers. "
"This includes a rollover of all contained tokens even if the user is not the "
"owner of a contained token."
msgstr ""
"Les utilisateurs sont autorisés à effectuer un renouvellement de leurs "
"propres conteneurs. Ceci inclut un renouvellement de tous les jetons "
"contenus même s'ils ne lui appartiennent pas."

#: lib/policy.py:2343
msgid "Users are allowed to create and edit container templates."
msgstr ""
"Les utilisateurs sont autorisés à créer et modifier des modèles de conteneur."

#: lib/policy.py:2347
msgid "Users are allowed to delete templates."
msgstr "Les utilisateurs sont autorisés à supprimer des modèles."

#: lib/policy.py:2351
msgid "Users are allowed to list templates and view their details."
msgstr ""
"Les utilisateurs sont autorisés à lister les modèles et à voir leurs détails."

#: lib/policy.py:2358
msgid "Limit the number of allowed tokens in a realm."
msgstr "Limiter le nombre de jetons autorisés dans un domaine."

#: lib/policy.py:2362
msgid ""
"During the rollout process, this policy makes the description required for "
"all selected tokentypes."
msgstr ""
"Durant le processus de déploiement, cette politique impose une description "
"pour tous les types de jetons sélectionnés."

#: lib/policy.py:2370
msgid "Limit the number of tokens a user may have assigned."
msgstr ""
"Limiter le nombre de jetons qui peuvent être assignés à un utilisateur."

#: lib/policy.py:2375
msgid "Limit the number of active tokens a user may have assigned."
msgstr ""
"Limiter le nombre de jetons actifs qui peuvent être assignés à un "
"utilisateur."

#: lib/policy.py:2380
msgid ""
"Set a random OTP PIN with this length for a token during the enrollment "
"process."
msgstr ""
"Définir un NIP à usage unique aléatoire avec cette longueur pour un jeton "
"pendant le processus d'enrôlement."

#: lib/policy.py:2385
msgid "In case of a random OTP PIN use this python module to process the PIN."
msgstr ""
"Dans le cas d'un NIP à usage unique aléatoire, utiliser ce module python "
"pour traiter le NIP."

#: lib/policy.py:2390
msgid ""
"If the administrator sets the OTP PIN during enrollment or later, the user "
"will have to change the PIN during first use."
msgstr ""
"Si l'administrateur définit le NIP à usage unique lors de l'inscription ou "
"ultérieurement, l'utilisateur devra modifier le NIP lors de la première "
"utilisation."

#: lib/policy.py:2397
msgid ""
"The user needs to change his PIN on a regular basis. To change the PIN every "
"180 days, enter '180d'."
msgstr ""
"L'utilisateur doit changer son PIN régulièrement. Pour changer le PIN tous "
"les 180 jours, saisissez '180d'."

#: lib/policy.py:2404
msgid ""
"The OTP PIN can be hashed or encrypted. Hashing the PIN is the default "
"behaviour."
msgstr ""
"Le PIN à usage unique peut être haché ou chiffré. Le hachage du PIN est le "
"comportement par défaut."

#: lib/policy.py:2409
#, python-brace-format
msgid ""
"The label for a new enrolled Smartphone token. Possible tags are <code>{user}"
"</code>, <code>{realm}</code>, <code>{serial}</code>, <code>{givenname}</"
"code> and <code>{surname}</code>."
msgstr ""
"L'étiquette pour un jeton de Smartphone nouvellement enrôlé. Les tags "
"possibles sont <code>{user}</code>, <code>{realm}</code>, <code>{serial}</"
"code>, <code>{givenname}</code> et <code>{surname}</code>."

#: lib/policy.py:2415
#, python-brace-format
msgid ""
"The issuer label for new enrolled Smartphone token.Possible tags are "
"<code>{user}</code>, <code>{realm}</code>, <code>{serial}</code>, "
"<code>{givenname}</code> and <code>{surname}</code>."
msgstr ""
"L'étiquette de l'émetteur pour un jeton de Smartphone nouvellement enrôlé. "
"Les tags possibles sont <code>{user}</code>, <code>{realm}</code>, "
"<code>{serial}</code>, <code>{givenname}</code> et <code>{surname}</code>."

#: lib/policy.py:2422
msgid ""
"This is the URL to the token image for the privacyIDEA Authenticator and "
"some other apps like FreeOTP (supported file formats: PNG, JPG and GIF)."
msgstr ""
"L'URL de l'image du jeton pour le PrivacyIDEA Authenticator et pour quelques "
"autres apps comme FreeOTP (format de fichiers supportés : PNG, JPG et GIF)."

#: lib/policy.py:2429
msgid ""
"Users can assign a token just by using the unassigned token to authenticate."
msgstr ""
"Les utilisateurs peuvent s'assigner un jeton simplement en utilisant un "
"jeton non assigné pour s'authentifier."

#: lib/policy.py:2435
msgid "The length of the password in case of temporary token (lost token)."
msgstr "Longueur du mot de passe en cas de jeton temporaire (jeton perdu)."

#: lib/policy.py:2439
msgid ""
"The contents of the temporary password, described by the characters C, c, n, "
"s, 8."
msgstr ""
"Contenu d'un mot de passe temporaire, décrit par les classes de caractères "
"C, c, n, s, 8."

#: lib/policy.py:2444
msgid "The length of the validity for the temporary token (in days)."
msgstr "Durée de validité d'un jeton temporaire (en jours)."

#: lib/policy.py:2449
msgid "Set the length of registration codes."
msgstr "Longueur des codes d'enregistrement."

#: lib/policy.py:2453
msgid ""
"Specify the required contents of the registration code. (c)haracters, "
"(n)umeric, (s)pecial. Use modifiers +/- or a list of allowed characters "
"[1234567890]"
msgstr ""
"Spécifier les classes de caractère d'un code d'enregistrement. (c)aractères, "
"(n)umériques, (s)péciaux. Utiliser les boutons +/- ou une liste des "
"caractères autorisés [1234567890]"

#: lib/policy.py:2462
msgid "Set the length of the password of generated password tokens."
msgstr ""
"Définir la longueur du mot de passe pour les jetons avec mot de passe auto-"
"généré."

#: lib/policy.py:2466
msgid ""
"Specify the required contents of the password of a password token. "
"(c)haracters, (n)umeric, (s)pecial. Use modifiers +/- or a list of allowed "
"characters [1234567890]"
msgstr ""
"Spécifier le contenu requis d'un mot de passe de jeton avec mot de passe. "
"(c)aractères, (n)umériques, (s)péciaux. Utiliser les boutons +/- ou une "
"liste de caractères autorisés [1234567890]"

#: lib/policy.py:2474
msgid ""
"Specify the email validator that should be used to validate email addresses "
"during enrollment."
msgstr ""
"Spécifier le validateur d'email qui doit être utilisé pour valider les "
"adresses email pendant l'enrôlement."

#: lib/policy.py:2480
msgid ""
"Specify the list of token types, that must be verified during enrollment."
msgstr ""
"Spécifier la liste des types de jetons qui doivent être vérifiés pendant "
"l'enrôlement."

#: lib/policy.py:2493
msgid ""
"Either use the Token PIN , use the Userstore Password or use no fixed "
"password component."
msgstr ""
"Utilisez le NIP du jeton, utilisez le mot de passe du magasin d'utilisateur "
"ou n'utilisez aucun composant de mot de passe fixe."

#: lib/policy.py:2498
msgid ""
"Specify the list of token types, that must be used with challenge response."
msgstr ""
"Spécifier la liste des types de jetons, qui doivent être utilisés lors de la "
"réponse au challenge."

#: lib/policy.py:2506
msgid ""
"Use an alternative challenge text for telling the user to enter an OTP "
"value. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr ""
"Utiliser un texte alternatif de challenge pour indiquer à l'utilisateur de "
"saisir une valeur OTP. Vous pouvez aussi utiliser des tags pour le "
"remplacement automatique. Consultez la documentation pour plus de détails."

#: lib/policy.py:2513
msgid ""
"If there are several different challenges, this text precedes the list of "
"the challenge texts."
msgstr "S'il y a plusieurs challenges, ce texte en précède la liste."

#: lib/policy.py:2518
msgid ""
"If there are several different challenges, this text follows the list of the "
"challenge texts."
msgstr "S'il y a plusieurs challenges, ce texte en suit la liste."

#: lib/policy.py:2523
msgid ""
"If the PIN of a token is to be changed, this will allow the user to change "
"the PIN during a validate/check request via challenge / response."
msgstr ""
"Si le PIN d'un jeton doit être modifié, cela permettra à l'utilisateur de "
"changer le PIN lors d'une demande de validation / vérification via "
"challenge / réponse."

#: lib/policy.py:2528
msgid ""
"The autoresync of a token can be done via a challenge response message.You "
"need to activate 'Automatic resync' in the general settings!"
msgstr ""
"La synchronisation automatique d'un jeton peut être faite via un message de "
"réponse au challenge. Vous devez activer 'Synchronisation automatique' dans "
"les paramètres généraux !"

#: lib/policy.py:2533
msgid ""
"In case of a successful authentication the following tokentype is enrolled. "
"The maximum number of tokens for a user is checked."
msgstr ""
"En cas d'authentification réussie, le type de jeton suivant est enrôlé. Le "
"nombre maximal de jetons de l'utilisateur est vérifié."

#: lib/policy.py:2539
msgid "Change the default text that is shown during enrolling a token."
msgstr "Change le texte affiché par défaut pendant l'enrôlement d'un jeton."

#: lib/policy.py:2544
msgid ""
"If set, the user in this realm will be authenticated against the userstore "
"or against the given RADIUS config, if the user has no tokens assigned."
msgstr ""
"Si positionné, l'utilisateur de ce royaume sera authentifié auprès de la "
"source d'identité ou selon la configuration RADIUS ,si l'utilisateur ne "
"dispose pas de jeton."

#: lib/policy.py:2551
msgid ""
"This allows to automatically assign a Token within privacyIDEA, if the user "
"was authenticated via passthru against a RADIUS server. The OTP value is "
"used to find the unassigned token in privacyIDEA. Enter the length of the "
"OTP value and where the PIN is set like 8:pin or pin:6."
msgstr ""
"Ceci permet d'assigner automatiquement un jeton avec privacyIDEA, si "
"l'utiisateur a été authentifié par passthru auprès du server RADIUS. La "
"valeur OTP est utilisée afin de trouver les jetons non assignés dans "
"privacyIDEA. Entrez la longueur de la valeur OTP and si le code PIN est "
"définit comme 8:pin ou pin:6."

#: lib/policy.py:2558
msgid ""
"If the user has no token, the authentication request for this user will "
"always be true."
msgstr ""
"Si l'utilisateur n'a pas de jeton, l'authentification d'un utilisateur sera "
"toujours vraie."

#: lib/policy.py:2563
msgid ""
"If the user user does not exist, the authentication request for this non-"
"existing user will always be true."
msgstr ""
"Si l'utilisateur n'existe pas, la requête d'authentification pour cet "
"utilisateur inconnu sera toujours vraie."

#: lib/policy.py:2569
msgid ""
"Can be used to modify the parameters pass, user and realm in an "
"authentication request. See the documentation for an example."
msgstr ""
"Peut être utilisé afin de modifier les paramètres, pass, user et realm dans "
"une requête d'authentification. Consultez la documentation pour un exemple."

#: lib/policy.py:2575
msgid ""
"If a user authenticates successfully reset the failcounter of all of his "
"tokens."
msgstr ""
"Si l'utilisateur s'authentifie avec succès, ceci remet à zéro le compteur "
"d'échec de tous ses jetons."

#: lib/policy.py:2580
msgid ""
"Increase the failcounter for all the tokens, for which a challenge has been "
"triggered."
msgstr ""
"Incrémente le compteur d'échecs de tous les jetons pour lesquels un "
"challenge a été déclenché."

#: lib/policy.py:2584
msgid ""
"Cache the password used for authentication and allow authentication with the "
"same credentials for a certain amount of time. Specify timeout like 4h or "
"4h/5m."
msgstr ""
"Met en cache le mot de passe et permet l'authentification avec les même "
"identifiants durant une certaine durée. Spécifier le délai comme 4h ou 4h/5m."

#: lib/policy.py:2591
msgid ""
"You can set the client modes in the order that you prefer. For example: "
"\"interactive webauthn poll u2f\". Accepted values are: <code>interactive "
"webauthn poll u2f</code>"
msgstr ""
"Vous pouvez définir les modes client dans l'ordre que vous préférez. Par "
"exemple : \"interactif webauthn poll u2f\". Les valeurs acceptées sont : "
"<code>interactif webauthn poll u2f</code>"

#: lib/policy.py:2597
msgid ""
"When enabled, authentication attempts will be interpreted as either the PIN "
"or the answer to a challenge. PIN concatenated with OTP can not be used "
"anymore! Does only work when authenticating with a username."
msgstr ""
"Quand activé, les tentatives d'authentifications seront interprétées comme "
"le PIN ou comme la réponse à un challenge. Le PIN concaténé avec l'OTP ne "
"peuvent plus être utilisés ! Fonctionne uniquement avec un nom d'utilisateur."

#: lib/policy.py:2605
#, python-brace-format
msgid ""
"Allow the user to authenticate (default). If set to '{0!s}', the "
"authentication of the user will be denied."
msgstr ""
"Permet à l'utilisateur de s'authentifier (par défaut). Si positionner à '{0!"
"s}', l'authentification de l'utilisateur sera refusée."

#: lib/policy.py:2612
msgid ""
"Allow the application to choose which token types should be used for "
"authentication. Application may set the parameter 'type' in the request. "
"Works with validate/check, validate/samlcheck and validate/triggerchallenge."
msgstr ""
"Autorise l'application à choisir quel jeton doit être utilisé pour "
"l'authentification. L'application doit indiquer le paramètre 'type' dans la "
"requête. Fonctionne avec validate/check, validate/samlcheck et validate/"
"triggerchallenge."

#: lib/policy.py:2619
msgid ""
"You can specify how many successful authentication requests a user is "
"allowed to do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h "
"being second, minute and hour."
msgstr ""
"Vous pouvez spécifier combien d'authentifications réussies un utilisateur "
"est autorisé à faire dans un temps donné. Spécifiez comme 1/5s, 2/10m, 10/1h "
"- s, m , h étant seconde, minute et heure."

#: lib/policy.py:2627
msgid ""
"You can specify how many failed authentication requests a user is allowed to "
"do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h being second, "
"minute and hour."
msgstr ""
"Vous pouvez spécifier combien d'échecs d'authentification un utilisateur est "
"autorisé à faire dans un temps imparti. Spécifiez comme 1/5s, 2/10m, 10/1h -"
"s, m, h étant seconde, minute et heure."

#: lib/policy.py:2635
msgid ""
"You can specify in which time frame the user needs to authenticate again "
"with this token. If the user authenticates later, authentication will fail. "
"Specify like 30h, 7d or 1y."
msgstr ""
"Vous pouvez spécifier dans quel laps de temps un utilisateur doit "
"s'authentifier avec son jeton. Si l'utilisateur s'authentifie plus tard, "
"l'authentification échouera. Spécifiez comme 30h, 7d ou 1y."

#: lib/policy.py:2643
msgid "The user will only be authenticated with this very tokentype."
msgstr "L'utilisateur ne sera authentifié qu'avec ce token spécifique."

#: lib/policy.py:2650
msgid ""
"The user will only be authenticated if the serial number of the token "
"matches this regexp."
msgstr ""
"L'utilisateur ne sera authentifié que si le numéro de série du jeton "
"correspond à cette expression régulière."

#: lib/policy.py:2656
msgid ""
"The user will only be authenticated if the tokeninfo field matches the "
"regexp (key/&lt;regexp&gt;/)."
msgstr ""
"L'utilisateur ne sera authentifié que si le champ tokeninfo correspond à "
"cette expression régulière (key/&lt;regexp&gt;/)."

#: lib/policy.py:2663
msgid ""
"The Realm of the user is set to this very realm. This is important if the "
"user is not contained in the default realm and can not pass his realm."
msgstr ""
"Le royaume de l'utilisateur est positionné à ce royaume spécifique. C'est "
"très important si l'utilisateur n'est pas contenu dans le royaume par défaut "
"et ne peut indiquer le sien."

#: lib/policy.py:2670
msgid ""
"In case of successful authentication additional no detail information will "
"be returned."
msgstr ""
"En cas d'authentification réussie, aucun détail supplémentaire ne sera "
"retourné."

#: lib/policy.py:2677
msgid ""
"In case of failed authentication additional no detail information will be "
"returned."
msgstr ""
"En cas d'authentification échouée, aucun détail supplémentaire ne sera "
"retourné."

#: lib/policy.py:2684
msgid ""
"In case of successful authentication user data will be added in the detail "
"branch of the authentication response."
msgstr ""
"En cas d'authentification réussie, les données utilisateur seront ajoutée "
"dans la section detail de la réponse à l'authentification."

#: lib/policy.py:2691
msgid ""
"In case of successful authentication the user resolver and realm will be "
"added in the detail branch of the authentication response."
msgstr ""
"En cas d'authentification réussie, la source d'authentification et le "
"royaume seront ajoutés dans la section detail de la réponse à "
"l'authentification."

#: lib/policy.py:2698
msgid ""
"The sending of an API Auth Key is required duringauthentication. This avoids "
"rogue authenticate requests against the /validate/check interface."
msgstr ""
"L'envoi d'une clé d'authentification API est requise durant "
"l'authentification. Cela évite les requêtes d'authentifications illégitimes "
"auprès de l'interface /valide/check."

#: lib/policy.py:2707
msgid ""
"If set, administrators will see a dashboard as start screen when logging in "
"to privacyIDEA WebUI."
msgstr ""
"Si positionné, les utilisateurs verront un dashboard sur l'écran d'acceuil "
"au login de l'interface Web de privacyIDEA."

#: lib/policy.py:2713
msgid ""
"If set to \"privacyIDEA\" the users and admins need to authenticate against "
"privacyIDEA when they log in to the Web UI. Defaults to \"userstore\"."
msgstr ""
"Si positionné à \"privacyIDEA\", les utilisateurs et administrateurs devront "
"s'authentifier auprès de privacyIDEA quand ils se connectent dans "
"l'interface WEB. Le défaut est \"userstore\"."

#: lib/policy.py:2721
msgid ""
"An alternative text to display on the WebUI login dialog instead of \"Please "
"sign in\"."
msgstr ""
"Un texte alternatif à afficher dans la page de connexion de l'interface WEB "
"à la place de \"Veuillez vous connecter\"."

#: lib/policy.py:2725
msgid ""
"When searching in the user list, the search will only performed when "
"pressing enter."
msgstr ""
"Lors des recherches dans la liste des utilisateurs, la recherche ne sera "
"effectuée que lors de l'appui sur entrée."

#: lib/policy.py:2730
msgid ""
"The action taken when a user is idle beyond the logout_time limit. Defaults "
"to \"lockscreen\"."
msgstr ""
"L'action effectuée quand un utilisateur est inactif au delà de la limite "
"logout_time. Par défaut \"lockscreen\" (verrouillage de l'écran)."

#: lib/policy.py:2738
msgid ""
"The REMOTE_USER set by the webserver can be used to login to privacyIDEA or "
"it will be ignored. Defaults to \"disable\"."
msgstr ""
"L'entête REMOTE_USER définie par le serveur web peut être utilisée pour "
"s'authentifier dans privacyIDEA ou être ignorée. Défaut à \"disable\"."

#: lib/policy.py:2744
msgid ""
"Set the time in seconds after which the user will be logged out from the "
"WebUI. Default: 120"
msgstr ""
"Spécifie la durée en secondes après laquelle l'utilisateur sera déconnecté "
"de l'interface WEB. Défaut : 120"

#: lib/policy.py:2749
msgid ""
"privacyIDEA issues a JWT when the user or admins logs in to the WebUI. The "
"default validity is 1 hour. You can specify different validity times in "
"seconds."
msgstr ""
"privacyIDEA émet un JWT quand les utilisateurs ou les admins se connectent "
"sur l'interface Web. La validité par défaut est de 1 heure. Vous pouvez "
"spécifier différentes durées de validité en secondes."

#: lib/policy.py:2754
msgid "Set how many tokens should be displayed in the token view on one page."
msgstr ""
"Spécifie combien de jetons doivent être affichés par page de la vue jeton."

#: lib/policy.py:2759
msgid "Set how many users should be displayed in the user view on one page."
msgstr ""
"Spécifie combien d'utilisateurs doivent être affichés par page de la vue "
"utilisateur."

#: lib/policy.py:2764
msgid ""
"Set how many audit entries should be displayed in the audit view on one page."
msgstr "Définit le nombre d'entrées affichées par page sur la vue audit."

#: lib/policy.py:2769
msgid "Use your own html template for the web UI menu."
msgstr ""
"Utilisez votre propre modèle de page html pour menu de l'interface WEB."

#: lib/policy.py:2773
msgid "Use your own html template for the web UI baseline/footer."
msgstr ""
"Utilisez votre propre modèle html pour les entêtes et pied de page de "
"l'interface WEB."

#: lib/policy.py:2777
msgid "Link your privacy statement to be displayed in the baseline/footer."
msgstr ""
"Lier votre politique de confidentialité à afficher en entête/pied de page."

#: lib/policy.py:2781
msgid ""
"Whether the user ID and the resolver should be displayed in the token list."
msgstr ""
"Si l'identifiant de l'utilisateur et sa source d'authentification doivent "
"être affichés dans la liste des jetons."

#: lib/policy.py:2786
msgid ""
"The URL of a repository, where the policy templates can be found.  (Default "
"https: //raw.githubusercontent.com/ privacyidea/policy-templates /master/"
"templates/)"
msgstr ""
"L'URL d'un emplacement, où les modèles de stratégies peuvent être trouvés. "
"( Défaut https://raw.githubusercontent.com/privacyidea/policy-templates/"
"master/templates/ )"

#: lib/policy.py:2793
msgid ""
"The URL of an SSO provider for redirect at logout.(The URL must start with "
"http:// or https://)"
msgstr ""
"L'URL d'un fournisseur SSO vers lequel rediriger à la déconnexion.(L'URL "
"doit commencer par http:// ou https://)"

#: lib/policy.py:2798
msgid ""
"As long as a user has no token, he will only see a token wizard in the UI."
msgstr ""
"Aussi longtemps qu'un utilisateur n'aura pas de jeton, il ne verra qu'un "
"assistant de création de jeton dans l'interface utilisateur."

#: lib/policy.py:2804
msgid ""
"The tokenwizard will be displayed in the token menu, even if the user "
"already has a token."
msgstr ""
"L'assistant de création de jeton s'affichera dans le menu jeton, même si "
"l'utilisateur a déjà un jeton."

#: lib/policy.py:2810
msgid ""
"This is a whitespace separated list of tokentypes, for which a rollover "
"button is displayed in the token details."
msgstr ""
"Liste de type de jetons séparés par des espaces, qui sera affichée dans une "
"liste déroulante dans les détails du jeton."

#: lib/policy.py:2817
msgid ""
"The welcome dialog will be displayed if the user has no tokens assigned."
msgstr ""
"La page de bienvenue sera affichée si l'utilisateur n'a aucun jeton associé."

#: lib/policy.py:2821
msgid "This is the default token type in the token enrollment dialog."
msgstr ""
"Format de jeton par défaut dans la fenêtre de dialogue de l'enrollement."

#: lib/policy.py:2827
msgid "This is the default container type in the container create dialog."
msgstr ""
"Le type de conteneur par défaut dans le dialogue de création de conteneur."

#: lib/policy.py:2832
msgid ""
"A list of realm names, which are displayed in a drop down menu in the WebUI "
"login screen. Realms are separated by white spaces."
msgstr ""
"Une liste de noms de royaume, qui seront affichés dans une liste déroulante "
"du menu de connexion de l'interface WEB. Les royaumes sont séparés par des "
"espaces."

#: lib/policy.py:2838
msgid ""
"If this checked, the administrator will not see the welcome dialog anymore."
msgstr "Si cochée, l'administrateur ne verra plus jamais la page de bienvenue."

#: lib/policy.py:2843
msgid ""
"Per default disabled actions result in disabled buttons. When checking this "
"action, buttons of disabled actions are hidden."
msgstr ""
"Par défaut, les actions désactivées entrainent des boutons désactivés. Quand "
"vous cochez cette action, les boutons désactivés sont cachés."

#: lib/policy.py:2848
msgid ""
"If this is checked, there will be a confirmation prompt when deleting "
"policies, events, mresolver, resolver or periodic tasks!"
msgstr ""
"Si coché, il y aura une demande de confirmation à l'effacement de "
"politiques, événements, mresolver, interpréteurs ou tâches périodiques !"

#: lib/policy.py:2853
msgid ""
"If this is checked, the seed will be displayed as text during enrollment."
msgstr "Si coché, la graine sera affiché comme texte durant l'enrollement."

#: lib/policy.py:2858
msgid ""
"If this is checked, the privacyIDEA Node name will be displayed in the menu "
"bar."
msgstr ""
"Si coché, le nom du noeud privacyIDEA sera affiché dans la barre de menu."

#: lib/policy.py:2863
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the Google "
"Play Store."
msgstr ""
"Si coché, la page d'enrollement pour HOTP, TOTP and les jetons PUSH "
"contiendront un QR code qui amène à l'application privacyIDEA Authenticator "
"dans le Google Play Store."

#: lib/policy.py:2870
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the iOS App "
"Store."
msgstr ""
"Si coché, la page d'enrollement pour HOTP, TOTP and les jetons PUSH "
"contiendront un QR code qui amène à l'application privacyIDEA Authenticator "
"dans IOS App Store."

#: lib/policy.py:2877
msgid ""
"This action adds a QR code in the enrollment page for HOTP, TOTP and Push "
"tokens, that lead to this given URL."
msgstr ""
"Cette action ajoute un QR code dans la page d'enrollement pour HOTP, TOTP et "
"jetons Push, qui mènent vers l'URL indiquée."

#: lib/policy.py:2882
msgid ""
"The RSS feeds fetched for the user defined in the format: "
"<code>'Title':'URL'-'Title':'URL'</code> "
msgstr ""
"Les flux RSS de l'utilisateur définis dans le format :"
"<code>'Title':'URL'-'Title':'URL'</code> "

#: lib/policy.py:2885
msgid ""
"The age of the RSS feed entries in days. Use <code>0</code> to hide the news "
"feed. For admins the default is 180 days and for users 0 days."
msgstr ""
"L'âge des entrées du flux RSS en jours. Utilisez <code>0</code> pour cacher "
"les nouveaux flux. 180 jours par défaut pour les administrateurs, 0 jour "
"pour les utilisateurs."

#: lib/policy.py:2889
msgid ""
"Container type to be created with the container wizard. It is required to "
"set at least this option to enable the container wizard. As long as the user "
"has no container assigned he will only see the container wizard in the UI."
msgstr ""
"Type de conteneur à créer avec l'assistant de création de conteneur. Il est "
"nécessaire de définir au moins cette option pour activer l'assistant. Tant "
"que l'utilisateur n'a pas de conteneur assigné il verra seulement "
"l'assistant de création de conteneur dans son interface."

#: lib/policy.py:2896
msgid ""
"Name of the container template to be used to create a container in the "
"container wizard (optional). Note that the template must be of the same type "
"as selected in the container_wizard_type."
msgstr ""
"Nom du modèle de conteneur à utiliser pour créer un conteneur dans "
"l'assistant (optionnel). Notez que le modèle doit être du même type que "
"celui sélectionné dans container_wizard_type."

#: lib/policy.py:2902
msgid ""
"In the container wizard, a QR code will be generated to register the new "
"container on the smartphone. (Only applicable for smartphone containers)"
msgstr ""
"Dans l'assistant de création de conteneur, un code QR sera généré pour "
"enregistrer le nouveau conteneur sur le smartphone. (S'applique seulement "
"pour les conteneurs de smartphone)"

#: lib/policy.py:2910
msgid ""
"The URL of your privacyIDEA server, e.g. <code>https://pi/</code>. It is "
"used to build URLs the container can contact for registration and "
"synchronization."
msgstr ""
"L'URL de votre serveur privacyIDEA, e.g. <code>https://pi/</code>. Il est "
"utilisé pour construire les URLs que le conteneur peut contacter pour "
"l'enregistrement et la synchronisation."

#: lib/policy.py:2916
msgid ""
"The time in minutes the client has to do the second step of the "
"registration. The default is ten minutes."
msgstr ""
"La durée en minutes que le client a pour faire la seconde étape "
"d'enregistrement. 10 minutes par défaut."

#: lib/policy.py:2922
msgid ""
"After the client (a registered container) has challenged an action such as "
"synchronization or unregistration, this defines the time in minutes the "
"client has to complete the action. The default is two minutes."
msgstr ""
"Après que le client (un conteneur enregistré) a demandé une action comme une "
"synchronisation ou une désinscription, ceci définit la durée en minutes que "
"le client dispose pour compléter l'action. 2 minutes par défaut."

#: lib/policy.py:2931
msgid ""
"The container needs to verify the SSL certificate of the privacyIDEA server "
"during registration and synchronization. (default True)"
msgstr ""
"Le conteneur doit vérifier le certificat SSL du serveur privacyIDEA pendant "
"l'enregistrement ou la synchronisation. (vrai par défaut)"

#: lib/policy.py:2938
msgid ""
"The client is allowed to perform a rollover of the container and the "
"included tokens."
msgstr ""
"Le client est autorisé à faire un roulement du conteneur et de ses jetons."

#: lib/policy.py:2943
msgid ""
"During the first synchronization, the server automatically adds the clients "
"tokens existing in privacyIDEA to the container. This allows to register "
"devices with existing tokens as container without having to manually add the "
"tokens on the device to the container."
msgstr ""
"Durant la première synchronisation, le serveur ajoute automatiquement les "
"jetons des clients existants de privacyIDEA au conteneur. Ceci permet "
"d'enregistrer des périphériques avec des jetons existants en tant que "
"conteneur sans avoir à ajouter manuellement les jetons du périphérique au "
"conteneur."

#: lib/policy.py:2950
msgid "The user is not allowed to delete tokens locally on the smartphone."
msgstr ""
"L'utilisateur n'est pas autorisé à supprimer des jetons sur le smartphone."

#: lib/policy.py:2955
msgid ""
"The client is not allowed to unregister the container. The user can not "
"delete the container locally on the smartphone."
msgstr ""
"Le client n'est pas autorisé à désinscrire le conteneur. L'utilisateur ne "
"peut pas supprimer le conteneur sur le smartphone."

#: lib/policy.py:3000
msgid ""
"The policy only matches if certain conditions on the user info are fulfilled."
msgstr ""
"Cette stratégie est effective que si certaines conditions dans les "
"informations utilisateurs sont remplies."

#: lib/policy.py:3003
msgid ""
"The policy only matches if certain conditions of the token attributes are "
"fulfilled."
msgstr ""
"La politique ne s'applique que si certaines conditions des attributs du "
"jeton sont remplies."

#: lib/policy.py:3006
msgid ""
"The policy only matches if certain conditions on the token info are "
"fulfilled."
msgstr ""
"La politique ne s'applique que si certaines conditions des infos du jeton "
"sont remplies."

#: lib/policy.py:3009
msgid ""
"The policy only matches if certain conditions on the HTTP Request header are "
"fulfilled."
msgstr ""
"Cette stratégie est effective que si certaines conditions dans les entêtes "
"de la requête HTTP sont remplies."

#: lib/policy.py:3012
msgid ""
"The policy only matches if certain conditions on the HTTP Environment are "
"fulfilled."
msgstr ""
"La politique correspond seulement si certaines conditions dans "
"l'environnement HTTP sont remplies."

#: lib/radiusserver.py:223 lib/radiusserver.py:255
msgid "The RADIUS secret is too long"
msgstr "Le secret RADIUS est trop long"

#: lib/subscriptions.py:43
msgid "My subscription has expired."
msgstr "Mon abonnement a expiré."

#: lib/token.py:169
#, python-brace-format
msgid "create_tokenclass_object failed:  {0!r}"
msgstr "create_tokenclass_object échoué :  {0!r}"

#: lib/token.py:335
msgid "I can only create SQL filters from tokeninfo of length 1."
msgstr "Je peux seulement créer des filtres SQL de tokeninfo de longueur 1."

#: lib/token.py:349
#, python-brace-format
msgid "No container with the serial {container_serial} exists."
msgstr "Aucun conteneur avec le numéro de série {container_serial} existe."

#: lib/token.py:742
msgid "The requested token could not be found."
msgstr "Le jeton demandé n'a pas pu être trouvé."

#: lib/token.py:747
msgid "More than one matching token was found."
msgstr "Plus d'un jeton correspondant trouvé."

#: lib/token.py:1051
msgid "multiple tokens are matching this OTP value!"
msgstr "plusieurs jetons correspondent à cette valeur OTP !"

#: lib/token.py:1270
msgid "init token failed. Unknown token type:"
msgstr "initialisation du jeton échouée : type de jeton inconnu :"

#: lib/token.py:1290
#, python-brace-format
msgid ""
"Token {serial} already exists with type {old_type}. Can not initialize token "
"with new type {token_type}"
msgstr ""
"Le jeton {serial} existe déjà avec le type {old_type}. Impossible "
"d'initialiser le jeton avec le nouveau type {token_type}"

#: lib/token.py:1294
msgid "init token failed:"
msgstr "initialisation jeton échouée :"

#: lib/token.py:1470
#, python-brace-format
msgid "Token already assigned to user {old_user!r}"
msgstr "Jeton déjà assigné à l'utilisateur {old_user!r}"

#: lib/token.py:1484
#, python-brace-format
msgid "Token assign failed for {0!r}/{1!s} : {2!r}"
msgstr "Assignation jeton échouée pour {0!r}/{1!s} : {2!r}"

#: lib/token.py:1512
msgid "Token unassign failed for"
msgstr "Désinscription du jeton échouée pour"

#: lib/token.py:1592
msgid "Parameter user must not be a string:"
msgstr "Le paramètre de l'utilisateur ne doit pas être une chaine :"

#: lib/token.py:2148
msgid "You can only define a lost token for an assigned token."
msgstr "Vous ne pouvez définir un jeton perdu que s'il est assigné."

#: lib/token.py:2174
#, python-brace-format
msgid "temporary replacement for {0!s}"
msgstr "Remplacement temporaire pour {0!s}"

#: lib/token.py:2230
msgid "There is no active and assigned token in this realm"
msgstr "Il n'y a aucun jeton actif ou assigné dans ce domaine"

#: lib/token.py:2242
#, python-brace-format
msgid ""
"There is no active and assigned token in this realm, included types: {0!s}, "
"excluded types: {1!s}"
msgstr ""
"Il n'y a aucun jeton actif ou attribué dans ce domaine, types inclus : {0!"
"s}, types exclus : {1!s}"

#: lib/token.py:2295
msgid "OTP verification failed."
msgstr "Echec de vérification OTP."

#: lib/token.py:2329
msgid "The user has no tokens assigned"
msgstr "L'utilisateur n'a pas de jeton assigné"

#: lib/token.py:2550
#, python-brace-format
msgid "matching {0:d} tokens"
msgstr "{0:d} jetons correspondants"

#: lib/token.py:2598
msgid "Challenge matches, but token is not fit for challenge"
msgstr ""
"Challenge correspondant, mais le jeton n'est pas compatible pour le challenge"

#: lib/token.py:2647
msgid "Response did not match the challenge."
msgstr "La réponse ne correspond pas au challenge."

#: lib/token.py:2649
#, python-brace-format
msgid "Response did not match for {0!s} tokens."
msgstr "La réponse ne correspond pas pour {0!s} jetons."

#: lib/token.py:2656
msgid "No active challenge response token found"
msgstr "Aucun jeton actif de réponse de challenge trouvé"

#: lib/token.py:2672
msgid "wrong otp value"
msgstr "mauvaise valeur otp"

#: lib/token.py:2679
msgid ". previous otp used again"
msgstr ". otp précédent encore utilisé"

#: lib/token.py:2693
msgid "wrong otp pin"
msgstr "mauvais pin otp"

#: lib/token.py:2701
msgid "No suitable token found for authentication."
msgstr "Aucun jeton compatible trouvé pour l'authentification."

#: lib/token.py:2726
#, python-brace-format
msgid "Admin is allowed to initialize {0!s} tokens."
msgstr "L'administrateur est autorisé a initialiser {0!s} jetons."

#: lib/token.py:2734
#, python-brace-format
msgid "The user is allowed to enroll a {0!s} token."
msgstr "L'utilisateur est autorisé à enrollé {0!s} jeton."

#: lib/token.py:2765
#, python-brace-format
msgid "Set the maximum allowed PIN length of the {0!s} token."
msgstr "Indiquer la longueur maximale d'un PIN du jeton {0!s}."

#: lib/token.py:2772
#, python-brace-format
msgid "Set the minimum required PIN length of the {0!s} token."
msgstr "Indiquer la longueur minimale d'un PIN du jeton {0!s}."

#: lib/token.py:2778
#, python-brace-format
msgid ""
"Specifiy the required PIN contents of the {0!s} token. (c)haracters, "
"(n)umeric, (s)pecial, (o)thers. [+/-]!"
msgstr ""
"Spécifier le contenu requis du PIN du jeton {0!s} . (c)aractères, "
"(n)umériques, (s)péciaux, (o)autres. [+/-] !"

#: lib/token.py:2823 lib/token.py:2839
msgid "The tokengroup does not exist."
msgstr "Le groupe de jetons n'existe pas."

#: lib/token.py:2976
#, python-brace-format
msgid " Please press: {presence_answer}"
msgstr " Veuillez presser : {presence_answer}"

#: lib/tokenclass.py:1700
msgid "please enter otp: "
msgstr "Veuillez saisir votre otp : "

#: lib/applications/ssh.py:105
msgid "The username on the SSH server."
msgstr "Le nom d'utilisateur sur le serveur SSH."

#: lib/applications/ssh.py:107
msgid ""
"The service ID of the SSH server. Several servers can have the same service "
"ID."
msgstr ""
"L'ID du service du serveur SSH. Plusieurs serveurs peuvent avoir le même ID "
"de service."

#: lib/containers/smartphone.py:123
msgid "A smartphone that uses an authenticator app."
msgstr "Un smartphone utilisant une application d'authentification."

#: lib/containers/smartphone.py:219
msgid "URL for privacyIDEA Container Registration"
msgstr "URL pour l'enregistrement de conteneur privacyIDEA"

#: lib/containers/yubikey.py:62
msgid ""
"Yubikey hardware device that can hold HOTP, certificate and webauthn token"
msgstr ""
"Périphérique Yubikey qui peut contenir des jetons HOTP, certificat et "
"webauthn"

#: lib/eventhandler/base.py:175
msgid ""
"The challenge session matches the string or regular expression (like "
"'challenge_declined' or 'enrollment')"
msgstr ""
"La session challenge correspond à la chaine ou à l'expression régulière "
"(comme 'challenge_declined' ou 'enrollment')"

#: lib/eventhandler/base.py:182
msgid "The challenge of a token during the authentication process is expired."
msgstr ""
"Le challenge d'un jeton durant le processus d'authentification est expiré."

#: lib/eventhandler/base.py:190
msgid ""
"The rollout_state of the token has a certain value like 'clientwait' or "
"'enrolled'."
msgstr ""
"Le retour de l'état du jeton a une valeur telle que 'clientwait' ou "
"'enrolled'."

#: lib/eventhandler/base.py:196
msgid "The realm of the user, for which this event should apply."
msgstr "Le royaume de l'utilisateur, pour qui cet événement doit s'appliquer."

#: lib/eventhandler/base.py:203
msgid "The resolver of the user, for which this event should apply."
msgstr ""
"La source d'authentification de l'utilisateur, pour qui cet événement doit "
"s'appliquer."

#: lib/eventhandler/base.py:210
msgid "The realm of the token, for which this event should apply."
msgstr "Le royaume du jeton, pour lequel cet événement doit s'appliquer."

#: lib/eventhandler/base.py:218
msgid "The resolver of the token, for which this event should apply."
msgstr ""
"La source d'authentification du jeton, pour lequel cet événement doit "
"s'appliquer."

#: lib/eventhandler/base.py:226
msgid "The type of the token."
msgstr "Le type de jeton."

#: lib/eventhandler/base.py:233
msgid "The logged in user is of the following type."
msgstr "L'utilisateur connecté est du type suivant."

#: lib/eventhandler/base.py:240
msgid "The result.value within the response is True or False."
msgstr "La valeur result.value de la réponse est True ou False."

#: lib/eventhandler/base.py:248
msgid "The result.status within the response is True or False."
msgstr "La valeur result.status de la réponse est True ou False."

#: lib/eventhandler/base.py:256
msgid "The result.authentication within the response is the given value."
msgstr ""
"La valeur result.authentication dans la réponse est la valeur attendue."

#: lib/eventhandler/base.py:264
msgid "Check if the max failcounter of the token is reached."
msgstr "Vérifier si le compteur d'échecs du jeton a atteint son maximum."

#: lib/eventhandler/base.py:272
msgid "The token has a user assigned."
msgstr "Le jeton a un utilisateur assigné."

#: lib/eventhandler/base.py:279
msgid ""
"The token has a user assigned, but the user does not exist in the userstore "
"anymore."
msgstr ""
"Le jeton a un utilisateur assigné, mais l'utilisateur n'existe plus dans la "
"source d'authentification."

#: lib/eventhandler/base.py:287
msgid "Check if the token is within its validity period."
msgstr "Vérifier si le jeton est dans sa période de validité."

#: lib/eventhandler/base.py:294
msgid "Action is triggered, if the serial matches this regular expression."
msgstr ""
"L'action est déclenchée, si le numéro de série correspond à cette expression "
"régulière."

#: lib/eventhandler/base.py:301
msgid "The token is in a container."
msgstr "Le jeton est dans un conteneur."

#: lib/eventhandler/base.py:308
msgid ""
"Action is triggered, if the user has this number of tokens assigned. > and < "
"can be used, like <8."
msgstr ""
"L'action est déclenchée, si l'utilisateur a ce nombre de jeton associé. > et "
"< peuvent être utilisés, comme <8."

#: lib/eventhandler/base.py:315
msgid ""
"Action is triggered, if the user has this number of containers assigned."
msgstr ""
"L'action est déclenchée, si l'utilisateur a ce nombre de conteneurs associés."

#: lib/eventhandler/base.py:322
msgid ""
"Action is triggered, if the counter of the token equals this setting. Can "
"also be '>100' or '<99' for no exact match."
msgstr ""
"L'action est déclenchée, si le compteur du jeton est égal à cette valeur. "
"Peut aussi être '>100' ou '<99' pour une correspondance non exacte."

#: lib/eventhandler/base.py:330
msgid ""
"Action is triggered, if the last authentication of the token is older than "
"7h, 10d or 1y."
msgstr ""
"L'action est déclenchée, si la dernière authentification de ce jeton est "
"plus vieille que 7h, 10d ou 1y."

#: lib/eventhandler/base.py:337
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth' is bigger than 100, less than 99 or exactly 100."
msgstr ""
"Cela peut être '>100', '<99', ou '=100', pour déclencher l'action, si le "
"champ tokeninfo 'count_auth' est plus grand que 100, moins que 99 ou pile "
"100."

#: lib/eventhandler/base.py:345
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth_success' is bigger than 100, less than 99 or "
"exactly 100."
msgstr ""
"Cela peut être '>100', '<99', ou '=100', pour déclencher l'action, si le "
"champ tokeninfo 'count_auth_success' est plus grand que 100, moins que 99 ou "
"pile 100."

#: lib/eventhandler/base.py:354
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"difference between the tokeninfo field 'count_auth' and 'count_auth_success "
"is bigger than 100, less than 99 or exactly 100."
msgstr ""
"Cela peut être '>100', '<99', ou '=100', pour déclencher l'action, si les "
"champ tokeninfo 'count_auth' et count_auth_success' sont plus grands que "
"100, moins que 99 ou pile 100."

#: lib/eventhandler/base.py:363
msgid ""
"This can be '>9', '<9', or '=10', to trigger the action, if the failcounter "
"of a token matches this value. Note that the failcounter stops increasing, "
"if the max_failcount is reached."
msgstr ""
"Cela peut être '>9', '<9', ou '=10', pour déclencher l'action, si le "
"compteur d'échec d'un jeton correspond à cette valeur. Notez que le compteur "
"d'échec n'est plus incrémenté si le max_failcount est atteint."

#: lib/eventhandler/base.py:372
msgid ""
"This condition can check any arbitrary tokeninfo field. You need to enter "
"something like '<fieldname> == <fieldvalue>', '<fieldname> > <fieldvalue>' "
"or '<fieldname> < <fieldvalue>'."
msgstr ""
"Cette condition peut vérifier n'importe quel champ tokeninfo. Vous devez "
"entrer quelque chose comme '<nom_champ>== <valeur_champ>', '<nom_champ> > "
"<valeur_champ>' ou '<nom_champ> < <valeur_champ>'."

#: lib/eventhandler/base.py:381
msgid ""
"This condition can check the value of an arbitrary event counter and compare "
"it like 'myCounter == 1000', 'myCounter > 1000' or 'myCounter < 1000'."
msgstr ""
"Cette condition peut vérifier la valeur d'un compteur d'événement et la "
"comparer comme ceci 'mon_compteur == 1000', 'mon_compteur > 1000', "
"'mon_compteur < 1000'."

#: lib/eventhandler/base.py:389
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->error->message in the response."
msgstr ""
"Vous pouvez rentrer ici une expression régulière. La condition ne s'applique "
"que si l'expression régulière est valide pour detail->error-> message de la "
"réponse."

#: lib/eventhandler/base.py:397
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->message in the response."
msgstr ""
"Vous pouvez rentrer ici une expression régulière. La condition ne s'applique "
"que si l'expression régulière est valide pour detail-> message de la réponse."

#: lib/eventhandler/base.py:405
msgid "Trigger the action, if the client IP matches."
msgstr "Déclenche l'action si l'ip du Client correspond."

#: lib/eventhandler/base.py:411
msgid ""
"The container is in the specified states, but can additionally be in other "
"states."
msgstr ""
"Le conteneur est dans l'état spécifié, mais peut additionnellement être dans "
"d'autres états."

#: lib/eventhandler/base.py:418
msgid "The container is only in the specified states."
msgstr "Le conteneur est seulement dans l'état spécifié."

#: lib/eventhandler/base.py:425
msgid "The container has a user assigned."
msgstr "Le conteneur a un utilisateur attribué."

#: lib/eventhandler/base.py:432
msgid "The container has at least one token assigned."
msgstr "Le conteneur a au moins un jeton assigné."

#: lib/eventhandler/base.py:439
msgid "The container is of a certain type."
msgstr "Le conteneur est d'un certain type."

#: lib/eventhandler/base.py:446
msgid ""
"The container is in this realm or in no realm at all. If multiple realms are "
"selected, the condition is fulfilled if the container is in at least one "
"realm of the list. The condition is not checked if the container has no "
"realm, hence the action would be triggered."
msgstr ""
"Le conteneur est dans ce domaine ou dans aucun domaine. Si plusieurs "
"domaines sont sélectionnés, la condition est vérifiée si le conteneur est au "
"moins dans un domaine de la liste. La condition n'est pas vérifiée si le "
"conteneur n'a pas de domaine, ainsi l'action serait déclenchée."

#: lib/eventhandler/base.py:456
msgid ""
"An owner of the container is in this resolver. If multiple resolvers are "
"selected, the condition is fulfilled if at least one owner is in one "
"resolver. The condition is not checked if the container has no owner, hence "
"the action would be triggered."
msgstr ""
"Un propriétaire de conteneur est dans ce résolveur. Si plusieurs résolveurs "
"sont sélectionnés, la condition est remplie si au moins un propriétaire est "
"dans un résolveur. La condition n'est pas vérifiée si le conteneur n'a pas "
"de propriétaire, ainsi l'action serait déclenchée."

#: lib/eventhandler/base.py:465
msgid ""
"This condition can check any arbitrary container info field. You need to "
"enter something like 'fieldname == fieldvalue', 'fieldname > fieldvalue' or "
"'fieldname < fieldvalue'."
msgstr ""
"Cette condition peut vérifier n'importe quel champ d'information de "
"conteneur. Vous devez entrer quelque chose comme 'nom_champ == "
"valeur_champ', 'nom_champ > valeur_champ' ou 'nom_champ < valeur_champ'."

#: lib/eventhandler/base.py:474
msgid ""
"Action is triggered, if the last authentication of the container is older "
"than the specified time. The time value has to be an integer followed by a "
"time unit. Supported units are 'y' (years), 'd' (days), 'h' (hours), "
"'m' (minutes), 's' (seconds). Only one unit is allowed. Examples: '8h', "
"'7d', '1y'"
msgstr ""
"L'action est déclenchée, si la dernière authentification du conteneur est "
"plus ancienne que la durée spécifiée. La valeur de temps doit être un entier "
"suivi d'une unité de temps. Les unités supportées sont 'y' (années), "
"'d' (jours), 'h' (heures), 'm' (minutes), 's' (secondes). Seule une unité "
"est autorisée. Exemples : '8h', '7d', '1y'"

#: lib/eventhandler/base.py:485
msgid ""
"Action is triggered, if the last synchronization of the container is older "
"than the specified time. The time value has to be an integer followed by a "
"time unit. Supported units are 'y' (years), 'd' (days), 'h' (hours), "
"'m' (minutes), 's' (seconds). Only one unit is allowed. Examples: '8h', "
"'7d', '1y'"
msgstr ""
"L'action est déclenchée, si la dernière synchronisation du conteneur est "
"plus ancienne que la durée spécifiée. La valeur de temps doit être un entier "
"suivi d'une unité de temps. Les unités supportées sont 'y' (années), "
"'d' (jours), 'h' (heures), 'm' (minutes), 's' (secondes). Seule une unité "
"est autorisée. Exemples : '8h', '7d', '1y'"

#: lib/eventhandler/containerhandler.py:89
#, python-brace-format
msgid "Set the state {state}"
msgstr "Définir l'état {state}"

#: lib/eventhandler/containerhandler.py:96
msgid "Container type to create"
msgstr "Type de conteneur à créer"

#: lib/eventhandler/containerhandler.py:102
#: lib/eventhandler/containerhandler.py:124
msgid "Description of the container"
msgstr "Description du conteneur"

#: lib/eventhandler/containerhandler.py:107
msgid "Assign container to user in request or to token/container owner"
msgstr ""
"Assigner le conteneur à l'utilisateur indiqué dans la requête ou au "
"propriétaire du jeton/conteneur"

#: lib/eventhandler/containerhandler.py:112
msgid "Add token from request to container"
msgstr "Ajouter le jeton indiqué dans la requête au conteneur"

#: lib/eventhandler/containerhandler.py:132
msgid "Set this container info key (deletes all existing keys)."
msgstr ""
"Définir la clé dans les infos de ce conteneur (efface toutes les clés "
"existantes)."

#: lib/eventhandler/containerhandler.py:136
#: lib/eventhandler/containerhandler.py:146
msgid "Set the value for the key above."
msgstr "Définir la valeur pour la clé ci-dessous."

#: lib/eventhandler/containerhandler.py:142
msgid "Add this key to the container info."
msgstr "Ajoute cette clé aux informations du conteneur."

#: lib/eventhandler/counterhandler.py:67 lib/eventhandler/counterhandler.py:72
#: lib/eventhandler/counterhandler.py:80
msgid "The identifier/key of the counter."
msgstr "L'identifiant/clé du compteur."

#: lib/eventhandler/counterhandler.py:75
msgid "Don't stop counter if it reaches zero."
msgstr "Ne pas arrêter le compteur s'il atteint zéro."

#: lib/eventhandler/customuserattributeshandler.py:61
msgid "The user for whom the custom attribute should be set."
msgstr "L'utilisateur pour lequel l'attribut personnalisé doit être défini."

#: lib/eventhandler/customuserattributeshandler.py:68
msgid "The key of the custom user attribute that should be set."
msgstr ""
"La clé de l'attribut personnalisé de l'utilisateur qui doit être définie."

#: lib/eventhandler/customuserattributeshandler.py:71
msgid "The value of the custom user attribute."
msgstr "La valeur de l'attribut personnalisé de l'utilisateur."

#: lib/eventhandler/customuserattributeshandler.py:77
msgid "The user from which the custom attribute should be deleted."
msgstr "L'utilisateur duquel l'attribut personnalisé doit être effacé."

#: lib/eventhandler/customuserattributeshandler.py:84
msgid "The key of the custom user attribute that should be deleted."
msgstr ""
"La clé de l'attribut personnalisé de l'utilisateur qui doit être effacée."

#: lib/eventhandler/federationhandler.py:74
msgid "The remote/child privacyIDEA Server."
msgstr "Le serveur distant/enfant privacyIDEA."

#: lib/eventhandler/federationhandler.py:79
msgid "Change the realm name to a realm on the child privacyIDEA system."
msgstr ""
"Change le nom du royaume en un royaume sur le système privacyIDEA enfant."

#: lib/eventhandler/federationhandler.py:85
msgid "Change the resolver name to a resolver on the child privacyIDEA system."
msgstr ""
"Change le nom de la source d'authentification en une source "
"d'authentification du système privacyIDEA enfant."

#: lib/eventhandler/federationhandler.py:91
msgid ""
"Forward the client IP to the child privacyIDEA server. Otherwise this server "
"will be the client."
msgstr ""
"Fait suivre l'IP du client au serveur privacyIDEA enfant. Autrement le "
"serveur sera le client."

#: lib/eventhandler/federationhandler.py:98
msgid ""
"Forward the authorization header. This allows to also forward request like "
"token- and system-requests."
msgstr ""
"Fait suivre l'entête d'autorisation. Cela permet de transmettre aussi les "
"requêtes comme token- et system-requests."

#: lib/eventhandler/logginghandler.py:85
msgid "The name of the logging facility"
msgstr "Le nom de la catégorie de journalisation (logging facility)"

#: lib/eventhandler/logginghandler.py:91
msgid "The string to write to the log"
msgstr "La chaîne à écrire dans le log"

#: lib/eventhandler/logginghandler.py:97
msgid "The logging level for this logging notification"
msgstr "Le niveau de log pour cette notification"

#: lib/eventhandler/requestmangler.py:87
msgid "The parameter that should be deleted."
msgstr "Le paramètre qui doit être supprimé."

#: lib/eventhandler/requestmangler.py:93
msgid "The parameter that should be added or modified."
msgstr "Le paramètre qui doit être ajouté ou modifié."

#: lib/eventhandler/requestmangler.py:98
#, python-brace-format
msgid ""
"The new value of the parameter. Can contain tags like {0}, {1} for the "
"matched sub strings."
msgstr ""
"La nouvelle valeur du paramètre. Peut contenir des tags tels que {0}, {1} "
"qui correspondent aux sous chaînes de caractères correspondantes."

#: lib/eventhandler/requestmangler.py:103
msgid "The parameter, that should match some values."
msgstr "Le paramètre, qui doit correspondre à certaines valeurs."

#: lib/eventhandler/requestmangler.py:107
msgid ""
"The value of the match_parameter. It can contain a regular expression and "
"'()' to transfer values to the new parameter."
msgstr ""
"La valeur du match_parameter. Il peut contenir une expression régulière et "
"'()' afin de transférer des valeurs au nouveau paramètre."

#: lib/eventhandler/requestmangler.py:112
msgid ""
"If the parameter is 'username', 'user' or 'realm', the user will be reset. "
"This can have an effect on any further actions on the user!"
msgstr ""
"Si le paramètre est 'username', 'user' or 'realm', l'utilisateur sera "
"réinitialisé. Ceci peut avoir un effet sur les actions futures de "
"l'utilisateur !"

#: lib/eventhandler/responsemangler.py:79
msgid ""
"The JSON pointer (key) that should be deleted. Please specify in the format "
"'/detail/message'."
msgstr ""
"Le pointeur JSON (key) qui doit être supprimé. Merci de le spécifier au "
"format '/detail/message'."

#: lib/eventhandler/responsemangler.py:86
msgid ""
"The JSON pointer (key) that should be set. Please specify in the format '/"
"detail/message'."
msgstr ""
"Le pointeur JSON (key) qui doit être positionné. Merci de le spécifier au "
"format '/detail/message'."

#: lib/eventhandler/responsemangler.py:92
msgid "The type of the value."
msgstr "Le type de la valeur."

#: lib/eventhandler/responsemangler.py:98
msgid "The value of the JSON key that should be set."
msgstr "La valeur du la clé JSON qui doit être positionnée."

#: lib/eventhandler/scripthandler.py:92
#: lib/smsprovider/ScriptSMSProvider.py:121
msgid ""
"Wait for script to complete or run script in background. This will either "
"return the HTTP request early or could also block the request."
msgstr ""
"Attend que le script se termine ou lance le script en arrière plan. Cela va "
"soit libérer la requête HTTP plus tôt ou peut aussi bloquer la requête."

#: lib/eventhandler/scripthandler.py:100
msgid "On script error raise exception in HTTP request."
msgstr "En cas d'erreur de script, renvoie une exception dans la requête HTTP."

#: lib/eventhandler/scripthandler.py:104
msgid ""
"Finish current transaction before running the script. This is useful if "
"changes to the database should be made available to the script or the "
"running request."
msgstr ""
"Termine la transaction actuelle avant de lancer le script. Ceci est utile si "
"les changements dans la base de donnée doivent être rendus disponibles pour "
"le script ou la requête en cours."

#: lib/eventhandler/scripthandler.py:111
msgid "Add '--serial <serial number>' as script parameter."
msgstr "Ajoute '--serial <serial number>' comme paramètre de script."

#: lib/eventhandler/scripthandler.py:116
msgid "Add '--user <username>' as script parameter."
msgstr "Ajoute '--user <username>' comme paramètre de script."

#: lib/eventhandler/scripthandler.py:121
msgid "Add '--realm <realm>' as script parameter."
msgstr "Ajoute '--realm <realm>' comme paramètre de script."

#: lib/eventhandler/scripthandler.py:126
msgid ""
"Add the username of the logged in user as script parameter like '--"
"logged_in_user <username>'."
msgstr ""
"Ajoute le nom d'utilisateur de l'utilisateur connecté comme paramètre de "
"script tel que '--logged_in_user <username>'."

#: lib/eventhandler/scripthandler.py:132
msgid ""
"Add the role (either admin or user) of the logged in user as script "
"parameter like '--logged_in_role <role>'."
msgstr ""
"Ajoute le rôle (soit admin, soit user) de l'utilisateur connecté, comme "
"paramètre de script tel que '--logged_in_role <role>'."

#: lib/eventhandler/tokenhandler.py:144
msgid "set a new realm of the token"
msgstr "Positionne un nouveau royaume au jeton"

#: lib/eventhandler/tokenhandler.py:150
msgid ""
"The new realm will be the only realm of the token. I.e. all other realms "
"will be removed from this token. If disabled, the realm will be added to the "
"token."
msgstr ""
"Le nouveau domaine sera le seul domaine du jeton. Tous les autres domaines "
"seront supprimés du jeton. Si désactivé, le domaine sera ajouté au jeton."

#: lib/eventhandler/tokenhandler.py:167
msgid "set the PIN of the token to a random PIN of this length."
msgstr "Positionne le PIN du jeton à un PIN aléatoire de cette longueur."

#: lib/eventhandler/tokenhandler.py:177
msgid "Token type to create"
msgstr "Type de jeton à créer"

#: lib/eventhandler/tokenhandler.py:183
msgid "Assign token to user in request or to tokenowner."
msgstr ""
"Assigner le jeton à l'utilisateur indiqué dans la requête ou au propriétaire "
"du jeton."

#: lib/eventhandler/tokenhandler.py:190
msgid "Set the realm of the newly created token."
msgstr "Positionne le royaume du jeton nouvellement crée."

#: lib/eventhandler/tokenhandler.py:199
msgid "Dynamically read the mobile number from the user store."
msgstr "Lire dynamiquement le numéro de mobile depuis la base utilisateur."

#: lib/eventhandler/tokenhandler.py:207
msgid "Dynamically read the email address from the user store."
msgstr "Lire dynamiquement l'adresse mail depuis la base utilisateur."

#: lib/eventhandler/tokenhandler.py:215
msgid "Use a specific SMTP server configuration for this token."
msgstr "Utilise une configuration de serveur SMTP spécifique pour ce jeton."

#: lib/eventhandler/tokenhandler.py:223
msgid "Use a specific SMS gateway configuration for this token."
msgstr "Utilise une passerelle SMS spécifique pour ce jeton."

#: lib/eventhandler/tokenhandler.py:229
msgid "A dictionary of additional init parameters."
msgstr "Un dictionnaire de paramètres d'initialisation additionnels."

#: lib/eventhandler/tokenhandler.py:236
msgid ""
"Set the MOTP PIN of the MOTP token during enrollment. This is a required "
"value for enrolling MOTP tokens."
msgstr ""
"Positionne le PIN du jeton mOTP durant l'enrôlement. C'est une valeur "
"requise pour enrôler des jetons mOTP."

#: lib/eventhandler/tokenhandler.py:244
msgid ""
"Add the token to the container if there is one identifiable in the request."
msgstr ""
"Ajoute le jeton au conteneur s'il y en a un identifiable dans la requête."

#: lib/eventhandler/tokenhandler.py:252
msgid "The new description of the token."
msgstr "La nouvelle description du jeton."

#: lib/eventhandler/tokenhandler.py:261
msgid ""
"The token will be valid starting at the given date. Can be a fixed date or "
"an offset like +10m, +24h, +7d."
msgstr ""
"Le jeton sera valide à partir de la date indiquée. Peut être une date fixe "
"ou un décalage tel que +10m, +24h, +7d."

#: lib/eventhandler/tokenhandler.py:269
msgid ""
"The token will be valid until the given date. Can be a fixed date or an "
"offset like +10m, +24h, +7d."
msgstr ""
"Le jeton sera valide jusqu'à la date indiquée. Peut être une date fixe ou un "
"décalage tel que +10m, +24h, +7d."

#: lib/eventhandler/tokenhandler.py:283
msgid "Set the new count window of the token."
msgstr "Positionner le nouveau compteur du jeton."

#: lib/eventhandler/tokenhandler.py:293
msgid "Set the failcounter of the token."
msgstr "Positionne le compteur d'échec du jeton."

#: lib/eventhandler/tokenhandler.py:303
msgid ""
"Increase or decrease the fail counter of the token. Values of +n, -n with n "
"being an integer are accepted."
msgstr ""
"Augmente ou diminue le compteur d'erreur du jeton. Les valeurs de +n, -n "
"avec n étant un entier sont acceptées."

#: lib/eventhandler/tokenhandler.py:313
msgid "Set the maximum failcounter of the token."
msgstr "Indiquer la valeur maximale du compteur d'erreur du jeton."

#: lib/eventhandler/tokenhandler.py:322
msgid "Set this tokeninfo key."
msgstr "Positionne cette clé tokeninfo."

#: lib/eventhandler/tokenhandler.py:327
msgid "Set the above key to this value."
msgstr "Donner à la clé ci-dessous cette valeur."

#: lib/eventhandler/tokenhandler.py:337
msgid ""
"Interpret the tokeninfo as 'int' and increase the tokeninfo value by the "
"given offset."
msgstr ""
"Interprète tokeninfo en tant que 'int' et augmente sa valeur du décalage "
"spécifié."

#: lib/eventhandler/tokenhandler.py:343
msgid ""
"The increment the tokeninfo key should be increased. Can be positive or "
"negative, s.th. like +1 or -7."
msgstr ""
"L'incrément de la clé tokeninfo doit être augmenté. Il peut être positif ou "
"négatif, comme +1 or -7."

#: lib/eventhandler/tokenhandler.py:353
msgid "Delete this tokeninfo key."
msgstr "Supprimer cette clé tokeninfo."

#: lib/eventhandler/tokenhandler.py:362
msgid "Add a tokengroup to the token."
msgstr "Ajouter un groupe au jeton."

#: lib/eventhandler/tokenhandler.py:372
msgid "Remove a tokengroup from the token."
msgstr "Supprimer un groupe du jeton."

#: lib/eventhandler/tokenhandler.py:382
msgid "The ID of the machine you want to attach the token to"
msgstr "L'ID de la machine que vous voulez attacher à ce jeton"

#: lib/eventhandler/tokenhandler.py:389
msgid "Set the service_id for an SSH application."
msgstr "Spécifie le service_id pour une application SSH."

#: lib/eventhandler/tokenhandler.py:398
msgid ""
"Set a token application like 'offline' or 'SSH'. Note: Not all tokens work "
"well with all applications!"
msgstr ""
"Définit une application de jeton comme 'offline' ou 'SSH'. Note : tous les "
"jetons ne fonctionnent pas correctement avec toutes les applications !"

#: lib/eventhandler/tokenhandler.py:408
msgid "The number of offline OTP values available"
msgstr "Le nombre de valeurs OTP hors ligne disponibles"

#: lib/eventhandler/tokenhandler.py:416
msgid "The number of rounds for password hashing"
msgstr "Le nombre de passes pour le hachage du mot de passe"

#: lib/eventhandler/usernotification.py:146
msgid "Send notification email via this email server."
msgstr "Envoyez un courriel de notification via ce serveur de messagerie."

#: lib/eventhandler/usernotification.py:150
msgid "Either send email as plain text or HTML."
msgstr "Envoyez un courriel sous forme de texte brut ou HTML."

#: lib/eventhandler/usernotification.py:154
msgid "Send QR-Code image as an attachment (cid URL: token_image)"
msgstr "Envoyer l'image QR-Code comme une pièce jointe (cid URL : token_image)"

#: lib/eventhandler/usernotification.py:159
msgid "The subject of the mail that is sent."
msgstr "L'objet du courriel envoyé."

#: lib/eventhandler/usernotification.py:163
msgid "The Reply-To header in the sent email."
msgstr "L'en-tête Répondre-à dans le courriel envoyé."

#: lib/eventhandler/usernotification.py:185
#: lib/eventhandler/usernotification.py:224
msgid "Any email address, to which the notification should be sent."
msgstr ""
"Toute adresse électronique à laquelle la notification doit être envoyée."

#: lib/eventhandler/usernotification.py:192
#, python-brace-format
msgid ""
"The template of the mail body that will be sent. It may contain the "
"following tags as specified in the documentation: <code>{admin}, {realm}, "
"{action}, {serial}, {url}, {user}, {givenname}, {surname}, {username}, "
"{userrealm}, {tokentype}, {tokendescription}, {registrationcode}, "
"{recipient_givenname}, {recipient_surname}, {googleurl_value}, "
"{googleurl_img}, {pushurl_value}, {pushurl_img}, {container_url_value}, "
"{container_url_img}, {time}, {date}, {client_ip}, {ua_browser}, {ua_string}, "
"{pin}.</code>"
msgstr ""
"Le modèle du corps du courriel qui sera envoyé. Il peut contenir les balises "
"suivantes comme spécifié dans la documentation : <code>{admin}, {realm}, "
"{action}, {serial}, {url}, {user}, {givenname}, {surname}, {username}, "
"{userrealm}, {tokentype}, {tokendescription}, {registrationcode}, "
"{recipient_givenname}, {recipient_surname}, {googleurl_value}, "
"{googleurl_img}, {pushurl_value}, {pushurl_img}, {container_url_value}, "
"{container_url_img}, {time}, {date}, {client_ip}, {ua_browser}, {ua_string}, "
"{pin}.</code>"

#: lib/eventhandler/usernotification.py:203
#: lib/eventhandler/usernotification.py:248
msgid "Send notification to this user."
msgstr "Envoyez une notification à cet utilisateur."

#: lib/eventhandler/usernotification.py:233
msgid "Send the user notification via a predefined SMS gateway."
msgstr "Envoyer la notification utilisateur via une passerelle SMS prédéfinie."

#: lib/eventhandler/usernotification.py:238
#, python-brace-format
msgid ""
"The text template of the SMS. It may contain the following tags as specified "
"in the documentation: <code>{admin}, {realm}, {action}, {serial}, {url}, "
"{user}, {givenname}, {surname}, {username}, {userrealm}, {tokentype}, "
"{tokendescription}, {registrationcode}, {recipient_givenname}, "
"{recipient_surname}, {googleurl_value}, {googleurl_img}, {pushurl_value}, "
"{pushurl_img}, {container_url_value}, {container_url_img}, {time}, {date}, "
"{client_ip}, {ua_browser}, {ua_string}, {pin}.</code>"
msgstr ""
"Le modèle de texte du SMS. Il peut contenir les balises suivantes comme "
"spécifié dans la documentation : <code>{admin}, {realm}, {action}, {serial}, "
"{url}, {user}, {givenname}, {surname}, {username}, {userrealm}, {tokentype}, "
"{tokendescription}, {registrationcode}, {recipient_givenname}, "
"{recipient_surname}, {googleurl_value}, {googleurl_img}, {pushurl_value}, "
"{pushurl_img}, {container_url_value}, {container_url_img}, {time}, {date}, "
"{client_ip}, {ua_browser}, {ua_string}, {pin}.</code>"

#: lib/eventhandler/usernotification.py:255
#, python-brace-format
msgid ""
"This is the template content of the new file. It may contain the following "
"tags as specified in the documentation: <code>{admin}, {realm}, {action}, "
"{serial}, {url}, {user}, {givenname}, {surname}, {username}, {userrealm}, "
"{tokentype}, {tokendescription}, {registrationcode}, {recipient_givenname}, "
"{recipient_surname}, {googleurl_value}, {googleurl_img}, {pushurl_value}, "
"{pushurl_img}, {container_url_value}, {container_url_img}, {time}, {date}, "
"{client_ip}, {ua_browser}, {ua_string}, {pin}.</code>"
msgstr ""
"Ceci est le contenu du modèle du nouveau fichier. Il peut contenir les "
"balises suivantes comme spécifié dans la documentation : <code>{admin}, "
"{realm}, {action}, {serial}, {url}, {user}, {givenname}, {surname}, "
"{username}, {userrealm}, {tokentype}, {tokendescription}, "
"{registrationcode}, {recipient_givenname}, {recipient_surname}, "
"{googleurl_value}, {googleurl_img}, {pushurl_value}, {pushurl_img}, "
"{container_url_value}, {container_url_img}, {time}, {date}, {client_ip}, "
"{ua_browser}, {ua_string}, {pin}.</code>"

#: lib/eventhandler/usernotification.py:266
#, python-brace-format
msgid ""
"The filename of the notification. Existing files are overwritten. The name "
"can contain tags as specified in the documentation and can also contain the "
"tag {random}."
msgstr ""
"Le nom de fichier de la notification. Les fichiers existants sont écrasés. "
"Le nom peut contenir des tags comme spécifié dans la documentation et peut "
"aussi contenir le tag {random}."

#: lib/eventhandler/webhookeventhandler.py:82
msgid "The URL the WebHook is posted to"
msgstr "L'URL où est posté le WebHook"

#: lib/eventhandler/webhookeventhandler.py:87
msgid "The encoding that is sent to the WebHook, for example json"
msgstr "L'encodage qui est envoyé au WebHook, par exemple json"

#: lib/eventhandler/webhookeventhandler.py:95
#, python-brace-format
msgid ""
"You can use the following placeholders: {logged_in_user}, {realm}, "
"{surname}, {token_owner}, {user_realm}, {token_serial}. However, tag "
"availability is depending on the endpoint."
msgstr ""
"Vous pouvez utiliser les balises réservées suivantes : {logged_in_user}, "
"{realm}, {surname}, {token_owner}, {user_realm}, {token_serial}. Toutefois, "
"la disponibilité des balises dépend du terminal."

#: lib/eventhandler/webhookeventhandler.py:102
msgid "The data posted in the WebHook"
msgstr "Les données postées dans le WebHook"

#: lib/machines/ldap.py:336
#, python-format
msgid "Your LDAP config seems to be OK, %i machine objects found."
msgstr ""
"Votre configuration LDAP semble correcte, %i objets machines ont été "
"trouvées."

#: lib/resolvers/LDAPIdResolver.py:1146
#, python-brace-format
msgid ""
"Your LDAP config found {0!s} user objects in {2:.4f}s, but only {1!s} with "
"the specified uidtype."
msgstr ""
"Votre configuration LDAP a trouvé {0!s} objets utilisateurs en {2:.4f}s, "
"mais seulement {1!s} avec le uidtype spécifié."

#: lib/resolvers/LDAPIdResolver.py:1150
#, python-brace-format
msgid "Your LDAP config seems to be OK, {0!s} user objects found in {1:.4f}s."
msgstr ""
"Votre configuration LDAP semble correcte, {0!s} objets utilisateurs ont été "
"trouvés en {1:.4f}s."

#: lib/smsprovider/FirebaseProvider.py:199
msgid ""
"The filename of the JSON config file, that allows privacyIDEA to talk to the "
"Firebase REST API."
msgstr ""
"Le nom de fichier de la configuration JSON qui permet à PrivacyIdea de "
"parler avec l'API REST Firebase."

#: lib/smsprovider/FirebaseProvider.py:204
msgid "Proxy setting for HTTPS connections to googleapis.com."
msgstr "Configuration proxy pour les connections HTTPS vers googleapis.com."

#: lib/smsprovider/HttpSMSProvider.py:249
msgid "The base URL of the HTTP Gateway"
msgstr "L'adresse URL de base de la passerelle HTTP"

#: lib/smsprovider/HttpSMSProvider.py:252
msgid "Should the HTTP Gateway be connected via an HTTP GET or POST request."
msgstr ""
"La passerelle HTTP devrait se connecter via une requête HTTP GET ou POST."

#: lib/smsprovider/HttpSMSProvider.py:257
msgid ""
"Specify a substring, that indicates, that the SMS was delivered successfully."
msgstr ""
"Spécifie une sous-chaine qui indique que le SMS a été délivré avec succès."

#: lib/smsprovider/HttpSMSProvider.py:261
msgid ""
"Specify a substring, that indicates, that the SMS failed to be delivered."
msgstr "Spécifie une sous-chaine qui indique que le SMS n'a pas été délivré."

#: lib/smsprovider/HttpSMSProvider.py:265
msgid "Username in case of basic authentication."
msgstr "Nom d'utilisateur en cas d'authentification de base."

#: lib/smsprovider/HttpSMSProvider.py:269
msgid "Password in case of basic authentication."
msgstr "Mot de passe en cas d'authentification de base."

#: lib/smsprovider/HttpSMSProvider.py:274
msgid "Should the SSL certificate be verified."
msgstr "Le certificat SSL doit-il être vérifié."

#: lib/smsprovider/HttpSMSProvider.py:280
msgid "Should the data in a POST Request be sent as JSON."
msgstr "Les données dans la requête POST doivent-elles être envoyées en JSON."

#: lib/smsprovider/HttpSMSProvider.py:287
msgid ""
"An optional proxy string. DEPRECATED. Do not use this anymore. Rather use "
"HTTP_PROXY for http connections and HTTPS_PROXY for https connection. The "
"PROXY option will be removed in future."
msgstr ""
"Une chaine optionnelle de proxy. OBSOLETE. Ne plus utiliser. Utiliser plutôt "
"HTTP_PROXY pour les connexions http et HTTPS_PROXY pour les connexions "
"https. L'option PROXY sera supprimée dans le futur."

#: lib/smsprovider/HttpSMSProvider.py:292
msgid "Proxy setting for HTTP connections."
msgstr "Paramètre proxy pour les connexions HTTP."

#: lib/smsprovider/HttpSMSProvider.py:293
msgid "Proxy setting for HTTPS connections."
msgstr "Paramètre proxy pour les connexions HTTPS."

#: lib/smsprovider/HttpSMSProvider.py:294
msgid "The timeout in seconds."
msgstr "Le délai d'expiration en secondes."

#: lib/smsprovider/SMSProvider.py:74
msgid ""
"Regular expression to modify the phone number to make it compatible with the "
"provider. For example to remove pluses and slashes enter something like '/[\\"
"+/]//'."
msgstr ""
"Expression régulière pour modifier le numéro de téléphone le rendant "
"compatible avec le fournisseur. Par exemple, pour enlever les plus et "
"slashs, entrez quelque chose comme '/[\\\\+/]//'."

#: lib/smsprovider/ScriptSMSProvider.py:113
msgid ""
"The script in script directory PI_SCRIPT_SMSPROVIDER_DIRECTORY to call. "
"Expects phone as the parameter and the message from stdin."
msgstr ""
"Le script dans le dossier des scripts PI_SCRIPT_SMSPROVIDER_DIRECTORY à "
"appeler. Attend le numéro de téléphone comme paramètre et le message de "
"stdin."

#: lib/smsprovider/SmppSMSProvider.py:125
msgid "SMSC Host IP"
msgstr "IP Hôte SMSC"

#: lib/smsprovider/SmppSMSProvider.py:128
msgid "SMSC Port"
msgstr "Port SMSC"

#: lib/smsprovider/SmppSMSProvider.py:130
msgid "SMSC Service ID"
msgstr "ID service SMSC"

#: lib/smsprovider/SmppSMSProvider.py:132
msgid "Password for authentication on SMSC"
msgstr "Mot de passe pour authentification SMSC"

#: lib/smsprovider/SmppSMSProvider.py:134
msgid "SOURCE_ADDR_TON Special Flag"
msgstr "Drapeau spécial SOURCE_ADDR_TON"

#: lib/smsprovider/SmppSMSProvider.py:136
msgid "S_ADDR_NPI Special Flag"
msgstr "Drapeau spécial S_ADDR_NPI"

#: lib/smsprovider/SmppSMSProvider.py:138
msgid "Source address (SMS sender)"
msgstr "Adresse source (expéditeur SMS)"

#: lib/smsprovider/SmppSMSProvider.py:139
msgid "DESTINATION_ADDR_TON Special Flag"
msgstr "Drapeau spécial DESTINATION_ADDR_TON"

#: lib/smsprovider/SmppSMSProvider.py:140
msgid "D_ADDR_NPI Special Flag"
msgstr "Drapeau spécial D_ADDR_NPI"

#: lib/task/eventcounter.py:41
msgid "The name of the event counter to read."
msgstr "Le nom du compteur d'événements à lire."

#: lib/task/eventcounter.py:46
msgid "The name of the stats key to write to the MonitoringStats table."
msgstr "Le nom de la clé stats à écrire dans la table MonitoringStats."

#: lib/task/eventcounter.py:52
msgid ""
"Whether to reset the event_counter, if it is read and written to the "
"MonitoringStats table."
msgstr ""
"S'il faut réinitialiser event_counter, s'il est lu ou écrit dans la table "
"MonitoringStats."

#: lib/task/simplestats.py:46
msgid "Total number of tokens"
msgstr "Nombre total de jetons"

#: lib/task/simplestats.py:49
msgid "Total number of hardware tokens"
msgstr "Nombre total de jetons matériels"

#: lib/task/simplestats.py:52
msgid "Total number of software tokens"
msgstr "Nombre total de jetons logiciels"

#: lib/task/simplestats.py:55
msgid "Number of hardware tokens not assigned to a user"
msgstr "Nombre de jetons matériels non assignés à un utilisateur"

#: lib/task/simplestats.py:58
msgid "Number of tokens assigned to users"
msgstr "Nombre de jetons assignés aux utilisateurs"

#: lib/task/simplestats.py:61
msgid "Number of users with tokens assigned"
msgstr "Nombre d'utilisateurs avec des jetons assignés"

#: lib/tokens/applicationspecificpasswordtoken.py:74
msgid ""
"Application Specific Password: A token with a fixed password. Can be used "
"for certain applications or services."
msgstr ""
"Mot de passe spécifique d'application : un jeton avec un mot de passe fixe. "
"Peut être utilisé pour certaines applications et services."

#: lib/tokens/applicationspecificpasswordtoken.py:85
msgid ""
"The user may only have this maximum number of application specific password "
"tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons "
"d'application avec mot de passe fixe."

#: lib/tokens/applicationspecificpasswordtoken.py:91
msgid ""
"The user may only have this maximum number of active application specific "
"password tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"d'application avec mot de passe fixe actifs."

#: lib/tokens/certificatetoken.py:282
msgid "Certificate: Enroll an x509 Certificate Token."
msgstr "Certificat : Enrôle un jeton certificat x509."

#: lib/tokens/certificatetoken.py:293
msgid "The user may only have this maximum number of certificates assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de certificats."

#: lib/tokens/certificatetoken.py:298
msgid ""
"The user may only have this maximum number of active certificates assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de certificats "
"actifs."

#: lib/tokens/certificatetoken.py:303
msgid ""
"Enrolling a certificate token can require an attestation certificate. "
"(Default: ignore)"
msgstr ""
"Enrôler un jeton certificat peut nécessiter un certificat d'attestation. "
"(Défaut : ignorer)"

#: lib/tokens/certificatetoken.py:312
msgid "The CA connector that should be used during certificate enrollment."
msgstr ""
"Le connecteur CA qui doit être utilisé pendant l'enrôlement de certificats."

#: lib/tokens/certificatetoken.py:318
msgid "The template that should be used to issue a certificate."
msgstr "Le modèle qui doit être utilisé pour émettre un certificat."

#: lib/tokens/certificatetoken.py:323
msgid ""
"This takes a space separated list of elements to be added to the subject. "
"Can be 'email' and 'realm'."
msgstr ""
"Une liste d'éléments séparés par des espaces qui sont ajoutés au sujet. Peut "
"être 'email' et 'domaine'."

#: lib/tokens/certificatetoken.py:331 lib/tokens/certificatetoken.py:338
msgid "The directory containing attestation certificate chains."
msgstr "Le dossier contenant les chaines de certificats d'attestation."

#: lib/tokens/daplugtoken.py:124
msgid "event based OTP token using the HOTP algorithm"
msgstr "Jeton OTP basé événement utilisant l'algorithme HOTP"

#: lib/tokens/daplugtoken.py:130
msgid "The user may only have this maximum number of daplug tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons "
"daplug."

#: lib/tokens/daplugtoken.py:135
msgid ""
"The user may only have this maximum number of active daplug tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons "
"daplug actifs."

#: lib/tokens/daypasswordtoken.py:35
msgid "Specify the time step of the DayPassword token. For example: \"24h\""
msgstr ""
"Spécifie la durée de validité du jeton DayPassword. Par exemple : \"24h\""

#: lib/tokens/daypasswordtoken.py:83
msgid ""
"DayPassword: A time-based token with a variable timestep and the possibility "
"to use the OTP more than once."
msgstr ""
"DayPassword : Un jeton basé sur le temps avec une variable temps et la "
"possibilité d'utiliser l'OTP plus d'une fois."

#: lib/tokens/daypasswordtoken.py:120 lib/tokens/hotptoken.py:173
#: lib/tokens/totptoken.py:158
msgid "Enforce setting an app pin for the privacyIDEA Authenticator App"
msgstr "Force à mettre un PIN sur l'application PrivacyIDEA Authenticator"

#: lib/tokens/daypasswordtoken.py:125
msgid ""
"The user may only have this maximum number of daypassword tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"DayPassword."

#: lib/tokens/daypasswordtoken.py:131
msgid ""
"The user may only have this maximum number of active daypassword tokens "
"assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"DayPassword actifs."

#: lib/tokens/emailtoken.py:156
msgid "EMail Token"
msgstr "Jeton du courriel"

#: lib/tokens/emailtoken.py:158
msgid "EMail: Send a One Time Password to the users email address."
msgstr ""
"Courriel : envoyez un mot de passe à usage unique à l'adresse électronique "
"des utilisateurs."

#: lib/tokens/emailtoken.py:166
#, python-brace-format
msgid ""
"The text that will be sent via EMail for an EMail-token. Several tags like "
"{otp} and {serial} can be used as parameters. You may also specify a "
"filename as email template starting with \"file:\"."
msgstr ""
"Le texte qui sera envoyé par courriel pour un jeton de courriel. Plusieurs "
"tags comme {otp} et {serial} peuvent être utilisés comme paramètres. Vous "
"pouvez également spécifier un nom de fichier comme modèle de courriel "
"commençant par \"file:\"."

#: lib/tokens/emailtoken.py:175
#, python-brace-format
msgid ""
"The subject of the EMail for an EMail token. Use tags like {otp} and "
"{serial} as parameters."
msgstr ""
"L'objet du courriel pour un jeton de courriel. Utilisez {otp} et {serial} "
"comme paramètres."

#: lib/tokens/emailtoken.py:180
msgid ""
"If set, a new EMail OTP will be sent after successful authentication with "
"one EMail OTP."
msgstr ""
"S'il est défini, un nouveau mot de passe à usage unique de courriel sera "
"envoyé après une authentification réussie avec un mot de passe précédemment "
"envoyé par courriel."

#: lib/tokens/emailtoken.py:185
msgid ""
"Use an alternative challenge text for telling the user to enter the code "
"from the e-mail. You can also use tags for automated replacement. Check out "
"the documentation for more details."
msgstr ""
"Utiliser un texte alternatif de challenge pour indiquer à l'utilisateur de "
"saisir le code reçu par courriel. Vous pouvez aussi utiliser des tags pour "
"le remplacement automatique. Consultez la documentation pour plus de détails."

#: lib/tokens/emailtoken.py:195
msgid "The user may only have this maximum number of email tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons de "
"messagerie."

#: lib/tokens/emailtoken.py:200
msgid ""
"The user may only have this maximum number of active email tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons de "
"messagerie actifs."

#: lib/tokens/emailtoken.py:282
msgid "Enter the OTP from the Email"
msgstr "Entrez le code OTP du courriel"

#: lib/tokens/emailtoken.py:324
msgid "The PIN was correct, but the EMail could not be sent!"
msgstr "Le PIN était correct, mais l'email n'a pas pu être envoyé !"

#: lib/tokens/emailtoken.py:561
msgid "Please enter your new email address!"
msgstr "Veuillez entrer votre nouvelle adresse email !"

#: lib/tokens/emailtoken.py:601
msgid "The email address is not valid!"
msgstr "L'adresse email n'est pas valide !"

#: lib/tokens/foureyestoken.py:130
msgid "4Eyes Token: Use tokens of two or more users to authenticate"
msgstr ""
"4Eyes Token : Utilise les jetons de 2 utilisateurs ou plus pour "
"s'authentifier"

#: lib/tokens/foureyestoken.py:141
msgid "The user may only have this maximum number of 4eyes tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons 4eyes."

#: lib/tokens/foureyestoken.py:146
msgid ""
"The user may only have this maximum number of active 4eyes tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"4eyes actifs."

#: lib/tokens/hotptoken.py:84
msgid "Please enter a valid OTP value of the new token."
msgstr "Veuillez saisir une valeur OTP valide du nouveau jeton."

#: lib/tokens/hotptoken.py:97
msgid "Specify the hashing function to be used. Can be SHA1, SHA256 or SHA512."
msgstr ""
"Spécifier la fonction de hachage à utiliser. Peut être SHA1, SHA256 ou "
"SHA512."

#: lib/tokens/hotptoken.py:99
msgid "Specify the OTP length to be used. Can be 6 or 8 digits."
msgstr "Spécifier la longueur OTP à utiliser. Peut être 6 ou 8 digits."

#: lib/tokens/hotptoken.py:100
msgid "Force the key to be generated on the server."
msgstr "Forcer la génération de la clé sur le serveur."

#: lib/tokens/hotptoken.py:101
msgid "Specify whether users are allowed or forced to use two-step enrollment."
msgstr ""
"Spécifier si les utilisateurs sont autorisés ou forcés à utiliser "
"l'enrôlement en 2 étapes."

#: lib/tokens/hotptoken.py:103
msgid ""
"Specify whether admins are allowed or forced to use two-step enrollment."
msgstr ""
"Spécifier si les admins sont autorisés ou forcés à utiliser l'enrôlement en "
"2 étapes."

#: lib/tokens/hotptoken.py:140
msgid "HOTP: Event based One Time Passwords."
msgstr "HOTP : Mots de passe uniques basés sur un événement."

#: lib/tokens/hotptoken.py:148
msgid "The user may only have this maximum number of HOTP tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons HOTP."

#: lib/tokens/hotptoken.py:153
msgid ""
"The user may only have this maximum number of active HOTP tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons HOTP "
"actifs."

#: lib/tokens/hotptoken.py:158 lib/tokens/totptoken.py:147
msgid "The size of the OTP seed part contributed by the client (in bytes)"
msgstr ""
"La taille d'une partie de la graine OTP contribuée par le client (en octets)"

#: lib/tokens/hotptoken.py:163 lib/tokens/totptoken.py:150
msgid "The size of the OTP seed part contributed by the server (in bytes)"
msgstr ""
"La taille d'une partie de la graine OTP contribuée par le serveur (en octets)"

#: lib/tokens/hotptoken.py:168 lib/tokens/totptoken.py:153
msgid ""
"The difficulty factor used for the OTP seed generation (should be at least "
"10000)"
msgstr ""
"Le facteur de difficulté utilisé pour la génération de la graine OTP (doit "
"être au moins 10000)"

#: lib/tokens/hotptoken.py:279
msgid "URL for google Authenticator"
msgstr "URL pour Google Authenticator"

#: lib/tokens/hotptoken.py:291
msgid "URL for OATH token"
msgstr "URL pour jeton OATHURL pour jeton OATH"

#: lib/tokens/hotptoken.py:840
msgid "Please scan the QR code and enter the OTP value!"
msgstr "Veuillez scanner le code QR et entrer la valeur OTP !"

#: lib/tokens/indexedsecrettoken.py:50
#, python-brace-format
msgid "Please enter the positions {0!s} from your secret."
msgstr "Veuillez entrer les positions {0!s} de votre secret."

#: lib/tokens/indexedsecrettoken.py:99
msgid "Indexed Secret Token"
msgstr "Jeton Secret indexé"

#: lib/tokens/indexedsecrettoken.py:101
msgid ""
"IndexedSecret: Request certain positions of a shared secret from the user."
msgstr ""
"SecretIndexé : Demande certaines positions d'un secret partagé de "
"l'utilisateur."

#: lib/tokens/indexedsecrettoken.py:109
msgid ""
"Use an alternative challenge text for telling the user which positions of "
"the secret he should enter. You can also use tags for automated replacement. "
"Check out the documentation for more details."
msgstr ""
"Utiliser un texte alternatif de challenge pour dire à l'utilisateur quelles "
"positions du secret il doit saisir. Vous pouvez aussi utiliser des tags pour "
"un remplacement automatique. Consultez la documentation pour plus de détails."

#: lib/tokens/indexedsecrettoken.py:117
msgid "Number of necessary positions to be answered by the user."
msgstr "Nombre de positions nécessaires à répondre par l'utilisateur."

#: lib/tokens/indexedsecrettoken.py:124
msgid "Preset the enrollment with the value of the given attribute."
msgstr "Prérègle l'enrôlement avec la valeur de l'attribut donné."

#: lib/tokens/indexedsecrettoken.py:131 lib/tokens/indexedsecrettoken.py:138
msgid "The attribute whose value should be force set during enrollment."
msgstr "L'attribut dont la valeur doit être forcée pendant l'enrôlement."

#: lib/tokens/indexedsecrettoken.py:145
msgid ""
"The user may only have this maximum number of indexed secret tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons de "
"secret indexé."

#: lib/tokens/indexedsecrettoken.py:150
msgid ""
"The user may only have this maximum number of active indexed secret tokens "
"assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons de "
"secret indexé actifs."

#: lib/tokens/motptoken.py:84
msgid "mOTP: Classical mobile One Time Passwords."
msgstr "mOTP : Mot de passe unique mobile classique."

#: lib/tokens/motptoken.py:102
msgid "The user may only have this maximum number of mOTP tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons mOTP."

#: lib/tokens/motptoken.py:107
msgid ""
"The user may only have this maximum number of active mOTP tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons mOTP "
"actifs."

#: lib/tokens/motptoken.py:149
msgid "URL for mOTP token"
msgstr "URL pour jeton mOTP"

#: lib/tokens/ocratoken.py:89
msgid "OCRA: Enroll an OCRA token."
msgstr "OCRA : enrôler un jeton OCRA."

#: lib/tokens/ocratoken.py:99
msgid "The user may only have this maximum number of OCRA tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons OCRA."

#: lib/tokens/ocratoken.py:104
msgid ""
"The user may only have this maximum number of active OCRA tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons OCRA "
"actifs."

#: lib/tokens/papertoken.py:93
msgid "PPR: One Time Passwords printed on a sheet of paper."
msgstr "PPR : Mots de passe uniques imprimés sur une feuille de papier."

#: lib/tokens/papertoken.py:104 lib/tokens/tantoken.py:106
msgid "The number of OTP values, which are printed on the paper."
msgstr "Le nombre de valeurs OTP qui sont imprimées sur le papier."

#: lib/tokens/papertoken.py:109
msgid "The user may only have this maximum number of paper tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons "
"papier."

#: lib/tokens/papertoken.py:114
msgid ""
"The user may only have this maximum number of active paper tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"papier actifs."

#: lib/tokens/passkeytoken.py:95
msgid "Passkey: A secret stored on a device, unlocked with biometrics."
msgstr ""
"Clé d'accès : Un secret stocké sur un périphérique, débloqué par biométrie."

#: lib/tokens/passkeytoken.py:104
msgid ""
"Alternative challenge message to use when authenticating with a passkey.You "
"can also use tags for replacement, check the documentation for more details."
msgstr ""
"Texte alternatif de challenge à utiliser lors de l'authentification avec une "
"clé d'accès. Vous pouvez aussi utiliser des balises pour le remplacement, "
"consultez la documentation pour plus de détails."

#: lib/tokens/passkeytoken.py:110
msgid ""
"When enabled, passkey token can be triggered with the PIN or via the /"
"validate/triggerchallenge endpoint. For privacyIDEA plugins, this is not "
"recommended. It is advised to use a condition, for example on a user-agent, "
"with this policy."
msgstr ""
"Quand activé, le jeton avec clé d'accès peut être déclenché avec le PIN ou "
"via le terminal /validate/triggerchallenge. Pour les plugins privacyIDEA, ce "
"n'est pas recommandé. Il est conseillé d'utiliser une condition, sur un user-"
"agent par exemple, avec cette politique."

#: lib/tokens/passkeytoken.py:119
msgid ""
"Request attestation from the authenticator during the registration. The "
"attestation certificate will be saved in the token info. The default value "
"is 'none'."
msgstr ""
"Demande une attestation de l'authentificateur pendant l'enregistrement. Le "
"certificat d'attestation sera sauvegardé dans les informations du jeton. La "
"valeur par défaut est 'aucun'."

#: lib/tokens/passkeytoken.py:400
msgid "Please authenticate with your passkey!"
msgstr "Veuillez vous authentifier avec votre clé d'accès !"

#: lib/tokens/passkeytoken.py:404
msgid "Please confirm the registration with your passkey!"
msgstr "Veuillez confirmer l'enregistrement avec votre clé d'accès !"

#: lib/tokens/passwordtoken.py:113
msgid ""
"A token with a fixed password. Can be combined  with the OTP PIN. Is used "
"for the lost token scenario."
msgstr ""
"Un jeton avec un mot de passe fixe. Peut être combiné avec le code PIN OTP. "
"Est utilisé pour un scénario de jeton perdu."

#: lib/tokens/passwordtoken.py:125
msgid "The user may only have this maximum number of password tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons avec "
"mot de passe."

#: lib/tokens/passwordtoken.py:130
msgid ""
"The user may only have this maximum number of active password tokens "
"assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons avec "
"mot de passe actifs."

#: lib/tokens/pushtoken.py:72
msgid "Please confirm the authentication on your mobile device!"
msgstr "Veuillez confirmer l'authentification sur votre téléphone !"

#: lib/tokens/pushtoken.py:73
msgid ""
"Use the polling feature of your privacyIDEA Authenticator App to check for a "
"new Login request."
msgstr ""
"Utiliser la fonction PUSH de votre application PrivacyIDEA Authenticator "
"pour vérifier une nouvelle requête de connexion."

#: lib/tokens/pushtoken.py:75
msgid "Do you want to confirm the login?"
msgstr "Voulez-vous confirmer la connexion ?"

#: lib/tokens/pushtoken.py:372
msgid "PUSH Token"
msgstr "Jeton PUSH"

#: lib/tokens/pushtoken.py:374
msgid "PUSH: Send a push notification to a smartphone."
msgstr "PUSH : Envoie une notification push à un smartphone."

#: lib/tokens/pushtoken.py:383
msgid "The configuration of your Firebase application."
msgstr "La configuration de votre application Firebase."

#: lib/tokens/pushtoken.py:391
msgid ""
"The URL the Push App should contact in the second enrollment step. Usually "
"it is the endpoint /ttype/push of the privacyIDEA server."
msgstr ""
"L'URL que l'application PUSH doit contacter dans la seconde étape de "
"l'enrôlement. Habituellement, c'est le endpoint /ttype/push du serveur "
"privacyIDEA."

#: lib/tokens/pushtoken.py:397
msgid ""
"The second enrollment step must be completed within this time (in minutes)."
msgstr ""
"La seconde étape de l'enrôlement doit être complétée durant cette période "
"(en minutes)."

#: lib/tokens/pushtoken.py:401
msgid "The smartphone needs to verify SSL during the enrollment. (default 1)"
msgstr ""
"Le smartphone nécessite de vérifier SSL pendant l'enrôlement. (défaut 1)"

#: lib/tokens/pushtoken.py:407
msgid "The user may only have this maximum number of Push tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons Push."

#: lib/tokens/pushtoken.py:412
msgid ""
"The user may only have this maximum number of active Push tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons Push "
"actifs."

#: lib/tokens/pushtoken.py:418
msgid "Require to unlock the Smartphone before Push requests can be accepted"
msgstr ""
"Nécessite de débloquer le smartphone avant d'accepter les requêtes Push"

#: lib/tokens/pushtoken.py:425
#, python-brace-format
msgid ""
"The question the user sees on his mobile phone. Several tags like {serial} "
"and {client_ip} can be used as parameters."
msgstr ""
"La question que l'utilisateur voit sur son téléphone. Plusieurs tags comme "
"{serial} et {client_ip} peuvent être utilisés comme paramètres."

#: lib/tokens/pushtoken.py:431
msgid "The title of the notification, the user sees on his mobile phone."
msgstr "Le titre de la notification que l'utilisateur voit sur son téléphone."

#: lib/tokens/pushtoken.py:436
msgid "The smartphone needs to verify SSL during authentication. (default 1)"
msgstr ""
"Le smartphone nécessite de vérifier SSL pendant l'authentification. (défaut "
"1)"

#: lib/tokens/pushtoken.py:442
msgid "Require the user to confirm the login with a presence check."
msgstr ""
"Exige que l'utilisateur confirme la connexion avec une vérification de "
"présence."

#: lib/tokens/pushtoken.py:447
#, python-brace-format
msgid ""
"The options that can be presented to the user to confirm the login. "
"<code>ALPHABETIC</code>: A-Z, <code>NUMERIC</code>: 01-99, <code>CUSTOM</"
"code>: user defined. Does only apply if <em>{0!s}</em> is set."
msgstr ""
"Les options qui peuvent être présentées à l'utilisateur pour confirmer la "
"connexion. <code>ALPHABETIQUE</code>: A-Z, <code>NUMERIQUE</code>: 01-99, "
"<code>PERSO</code>: prédéfinies. S'applique seulement si <em>{0!s}</em> est "
"défini."

#: lib/tokens/pushtoken.py:457
#, python-brace-format
msgid ""
"Custom options that can be presented to the user to confirm the login. The "
"string must contain at least 2 options and should be unique. The options are "
"separated by <code>:</code>. e.g.: <code>01:02:03:1A:1B:1C</code>. Does only "
"apply if <em>{0!s}</em> is set to <code>CUSTOM</code>."
msgstr ""
"Options personnalisées qui peuvent être présentées à l'utilisateur pour "
"confirmer la connexion. La chaine doit contenir au moins 2 options et doit "
"être unique. Les options sont séparées par <code>:</code>. e.g. : "
"<code>01:02:03:1A:1B:1C</code>. S'applique seulement si <em>{0!s}</em> est "
"défini à <code>CUSTOM</code>."

#: lib/tokens/pushtoken.py:467
#, python-brace-format
msgid ""
"The number of options the user is presented with to confirm the login. Does "
"only apply if <em>{0!s}</em> is set."
msgstr ""
"Le nombre d'options présentées à l'utilisateur pour confirmer la connexion. "
"S'applique seulement si <em>{0!s}</em> est défini."

#: lib/tokens/pushtoken.py:475
msgid ""
"Wait for number of seconds for the user to confirm the challenge in the "
"first request."
msgstr ""
"Temps d'attente en secondes pour que l'utilisateur confirme le challenge "
"dans la première requête."

#: lib/tokens/pushtoken.py:481
msgid "Configure whether to allow push tokens to poll for challenges"
msgstr "Configure l'autorisation des jetons push pour les challenges"

#: lib/tokens/pushtoken.py:616
msgid "URL for privacyIDEA Push Token"
msgstr "URL pour le jeton Push privacyIDEA"

#: lib/tokens/pushtoken.py:1195
msgid "Please scan the QR code!"
msgstr "Veuillez scanner le code QR !"

#: lib/tokens/questionnairetoken.py:96
msgid "Questionnaire: Enroll Questions for the user."
msgstr "Questionnaire : Enrôle les questions pour l'utilisateur."

#: lib/tokens/questionnairetoken.py:107
msgid "The user has to answer this number of questions during authentication."
msgstr ""
"L'utilisateur doit répondre à ce nombre de questions pendant "
"l'authentification."

#: lib/tokens/questionnairetoken.py:115
msgid ""
"The user may only have this maximum number of questionaire tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"questionnaire."

#: lib/tokens/questionnairetoken.py:120
msgid ""
"The user may only have this maximum number of active questionaire tokens "
"assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"questionnaire actifs."

#: lib/tokens/questionnairetoken.py:164
#, python-format
msgid "You need to provide at least %s answers."
msgstr "Vous devez fournir au moins %s réponses."

#: lib/tokens/radiustoken.py:106
msgid "RADIUS: Forward authentication request to a RADIUS server."
msgstr "RADIUS : transfère la requête d'authentification à un serveur RADIUS."

#: lib/tokens/radiustoken.py:115
msgid "The user may only have this maximum number of RADIUS tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"RADIUS."

#: lib/tokens/radiustoken.py:121
msgid ""
"The user may only have this maximum number of active RADIUS tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"RADIUS actifs."

#: lib/tokens/registrationtoken.py:127
msgid ""
"Registration: A token that creates a registration code that can be used as a "
"second factor once."
msgstr ""
"Enregistrement : Un jeton qui créé un code d'enregistrement qui peut être "
"utilisé une seule fois comme second facteur d'authentification."

#: lib/tokens/registrationtoken.py:139
msgid ""
"The user may only have this maximum number of registration tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons "
"d'enregistrement."

#: lib/tokens/registrationtoken.py:145
msgid ""
"The user may only have this maximum number of active registration tokens "
"assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"d'enregistrement actifs."

#: lib/tokens/remotetoken.py:112
msgid "Remote Token: Forward authentication request to another server."
msgstr ""
"Jeton distant : transfère la requête d'authentification à un autre serveur."

#: lib/tokens/remotetoken.py:121 lib/tokens/totptoken.py:163
msgid "The user may only have this maximum number of remote tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons "
"distants."

#: lib/tokens/remotetoken.py:127 lib/tokens/totptoken.py:169
msgid ""
"The user may only have this maximum number of active remote tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"distants actifs."

#: lib/tokens/smstoken.py:195
msgid "SMS Token"
msgstr "Jeton SMS"

#: lib/tokens/smstoken.py:197
msgid "SMS: Send a One Time Password to the users mobile phone."
msgstr ""
"SMS : Envoyer un mot de passe à usage unique sur le téléphone portable des "
"utilisateurs."

#: lib/tokens/smstoken.py:206
#, python-brace-format
msgid ""
"The text that will be send via SMS for an SMS token. Use tags like {otp} and "
"{serial} as parameters."
msgstr ""
"Le texte qui sera envoyé par SMS pour un jeton SMS. Utilisez les tags comme "
"{otp} et {serial} comme paramètres."

#: lib/tokens/smstoken.py:213
msgid ""
"If set, a new SMS OTP will be sent after successful authentication with one "
"SMS OTP."
msgstr ""
"Si défini, un nouveau code OTP SMS sera envoyé après l'authentification "
"réussie avec un code OTP SMS."

#: lib/tokens/smstoken.py:218
msgid ""
"Use an alternative challenge text for telling the user to enter the code "
"from the SMS. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr ""
"Utiliser un texte alternatif de challenge pour indiquer à l'utilisateur de "
"saisir le code reçu par SMS. Vous pouvez aussi utiliser les balises pour un "
"remplacement automatique. Consultez la documentation pour plus de détails."

#: lib/tokens/smstoken.py:229
msgid "Choose the gateways the administrator is allowed to set."
msgstr "Choisir les passerelles que l'administrateur est autorisé à définir."

#: lib/tokens/smstoken.py:237
msgid "Choose the gateways the user is allowed to set."
msgstr "Choisir les passerelles que l'utilisateur est autorisé à définir."

#: lib/tokens/smstoken.py:244
msgid "The user may only have this maximum number of SMS tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons SMS."

#: lib/tokens/smstoken.py:250
msgid ""
"The user may only have this maximum number of active SMS tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons SMS "
"actifs."

#: lib/tokens/smstoken.py:326
msgid "Enter the OTP from the SMS:"
msgstr "Entrez le code OTP reçu par SMS :"

#: lib/tokens/smstoken.py:360
msgid "The PIN was correct, but the SMS could not be sent!"
msgstr "Le PIN était correct mais le SMS n'a pas pu être envoyé !"

#: lib/tokens/smstoken.py:611
msgid "Please enter your new phone number!"
msgstr "Veuillez entrer votre nouveau numéro de téléphone !"

#: lib/tokens/spasstoken.py:86
msgid "SPass: Simple Pass token. Static passwords."
msgstr "SPass : jeton avec mot de passe simple. Mots de passe statiques."

#: lib/tokens/spasstoken.py:98
msgid "The user may only have this maximum number of SPASS tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"SPASS."

#: lib/tokens/spasstoken.py:104
msgid ""
"The user may only have this maximum number of active SPASS tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"SPASS actifs."

#: lib/tokens/sshkeytoken.py:82
msgid "SSH Public Key: The public SSH key."
msgstr "Clé SSH Publique : La clé publique SSH."

#: lib/tokens/sshkeytoken.py:91
msgid "The user may only have this maximum number of SSH keys assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de clés SSH."

#: lib/tokens/sshkeytoken.py:97
msgid "The user may only have this maximum number of active SSH keys assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de clés SSH "
"actives."

#: lib/tokens/tantoken.py:96
msgid "TAN: TANs printed on a sheet of paper."
msgstr "TAN : TANs imprimés sur une feuille de papier."

#: lib/tokens/tantoken.py:111
msgid "The user may only have this maximum number of TAN tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons TAN."

#: lib/tokens/tantoken.py:117
msgid ""
"The user may only have this maximum number of active TAN tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons TAN "
"actifs."

#: lib/tokens/tiqrtoken.py:156
msgid "TiQR: Enroll a TiQR token."
msgstr "TiQR : Enrôle un jeton TiQR."

#: lib/tokens/tiqrtoken.py:166
msgid "The user may only have this maximum number of TiQR tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons TiQR."

#: lib/tokens/tiqrtoken.py:172
msgid ""
"The user may only have this maximum number of active TiQR tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons TiQR "
"actifs."

#: lib/tokens/tiqrtoken.py:236
msgid "URL for TiQR enrollment"
msgstr "URL pour l'enrôlement TiQR"

#: lib/tokens/tiqrtoken.py:394
msgid "Please scan the QR Code"
msgstr "Veuillez scanner le code QR"

#: lib/tokens/totptoken.py:59
msgid "Specify the time step of the time-based OTP token."
msgstr "Spécifie la durée du jeton OTP basé sur le temps."

#: lib/tokens/totptoken.py:106
msgid "TOTP: Time based One Time Passwords."
msgstr "TOTP : Mots de passe basés sur le temps."

#: lib/tokens/u2ftoken.py:248
msgid "U2F: Enroll a U2F token."
msgstr "U2F : Enrôle un jeton U2F."

#: lib/tokens/u2ftoken.py:258
msgid "This is a list of FQDN hostnames trusting the registered U2F tokens."
msgstr ""
"Liste de noms d'hôtes FQDN faisant confiance aux jetons U2F enregistrés."

#: lib/tokens/u2ftoken.py:262
msgid ""
"Use an alternative challenge text for telling the user to confirm with his "
"U2F device. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr ""
"Utiliser un texte alternatif de challenge pour indiquer à l'utilisateur de "
"confirmer avec son jeton U2F. Vous pouvez aussi utiliser des balises pour un "
"remplacement automatique. Consultez la documentation pour plus de détails."

#: lib/tokens/u2ftoken.py:272
msgid "Only specified U2F tokens are authorized."
msgstr "Seuls les jetons U2F spécifiés sont autorisés."

#: lib/tokens/u2ftoken.py:280
msgid "Only specified U2F tokens are allowed to be registered."
msgstr "Seuls les jetons spécifiés sont autorisés à s'enregistrer."

#: lib/tokens/u2ftoken.py:285
msgid "Do not verify the U2F attestation certificate."
msgstr "Ne pas vérifier le certificat d'attestation U2F."

#: lib/tokens/u2ftoken.py:290
msgid "The user may only have this maximum number of U2F tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir assigner que ce nombre maximal de jetons U2F."

#: lib/tokens/u2ftoken.py:296
msgid ""
"The user may only have this maximum number of active U2F tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons U2F "
"actifs."

#: lib/tokens/u2ftoken.py:380
msgid "You need to define the appId in the token config!"
msgstr "Vous devez définir l'appId dans la configuration du jeton !"

#: lib/tokens/u2ftoken.py:444
#, python-brace-format
msgid "Please confirm with your U2F token ({0!s})"
msgstr "Veuillez confirmer avec votre jeton U2F ({0!s})"

#: lib/tokens/vascotoken.py:99
msgid "VASCO Token: Authentication using VASCO tokens"
msgstr "Jeton VASCO : Authentification grâce aux jetons VASCO"

#: lib/tokens/vascotoken.py:108
msgid "The user may only have this maximum number of Vasco tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"Vasco."

#: lib/tokens/vascotoken.py:114
msgid ""
"The user may only have this maximum number of active Vasco tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"Vasco actifs."

#: lib/tokens/webauthntoken.py:462
msgid "Generic WebAuthn Token"
msgstr "Jeton générique WebAuthn"

#: lib/tokens/webauthntoken.py:472
#, python-brace-format
msgid "Please confirm with your WebAuthn token ({0!s})"
msgstr "Veuillez confirmer avec votre jeton WebAuthn ({0!s})"

#: lib/tokens/webauthntoken.py:473
msgid "Please confirm with your WebAuthn token"
msgstr "Veuillez confirmer avec votre jeton WebAuthn"

#: lib/tokens/webauthntoken.py:554
msgid "WebAuthn: Enroll a Web Authentication token."
msgstr "WebAuthn : Enrôle un jeton d'authentification Web."

#: lib/tokens/webauthntoken.py:564
msgid ""
"A list of transports to prefer to communicate with WebAuthn tokens. Default: "
"usb ble nfc internal (All standard transports)"
msgstr ""
"Une liste de transports préférés pour communiquer avec les jetons WebAuthn. "
"Défaut : usb ble nfc interne (Tous les transports standards)"

#: lib/tokens/webauthntoken.py:569
msgid ""
"The time in seconds the user has to confirm authorization on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"La durée en secondes que l'utilisateur a pour confirmer l'autorisation sur "
"son jeton WebAuthn. Note : Vous pourrez incrémenter le ChallengeValidityTime "
"si besoin. Défaut : 60"

#: lib/tokens/webauthntoken.py:575
msgid ""
"Whether the user's identity should be verified when authenticating with a "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"Si l'identité de l'utilisateur doit être vérifiée en s'authentifiant avec un "
"jeton WebAuthn. Défaut : préféré (vérifie l'utilisateur si supporté par le "
"jeton)"

#: lib/tokens/webauthntoken.py:585
msgid ""
"Use an alternative challenge text for telling the user to confirm the login "
"with his WebAuthn token. You can also use tags for automated replacement. "
"Check out the documentation for more details."
msgstr ""
"Utiliser un texte alternatif de challenge pour indiquer à l'utilisateur de "
"confirmer la connexion avec son jeton WebAuthn. Vous pouvez aussi utiliser "
"des balises pour un remplacement automatique. Consultez la documentation "
"pour plus de détails."

#: lib/tokens/webauthntoken.py:594
msgid ""
"A list of WebAuthn authenticators acceptable for authorization, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"Une liste d'authentificateurs WebAuthn acceptés pour l'autorisation, fournie "
"comme une liste de AAGUIDSS séparés par des espaces. Par défaut, tous les "
"authentificateurs sont acceptés."

#: lib/tokens/webauthntoken.py:600
msgid "Only the specified WebAuthn-tokens are authorized."
msgstr "Seuls les jetons WebAuthn spécifiés sont autorisés."

#: lib/tokens/webauthntoken.py:607
msgid "One webauthn token can not be registered to a user more than once."
msgstr ""
"Un jeton webauthn ne peut pas être enregistré plus d'une fois par "
"utilisateur."

#: lib/tokens/webauthntoken.py:612
msgid "A human-readable name for the organization rolling out WebAuthn tokens."
msgstr "Un nom lisible pour l'organisation déployant les jetons WebAuthn."

#: lib/tokens/webauthntoken.py:617
msgid ""
"A domain name that is a subset of the respective FQDNs for all the "
"webservices the users should be able to sign in to using WebAuthn tokens."
msgstr ""
"Un nom de domaine qui est un sous-ensemble des FQDN respectifs pour tous les "
"services web où les utilisateurs sont susceptibles de se connecter en "
"utilisant des jetons WebAuthn."

#: lib/tokens/webauthntoken.py:623
msgid ""
"The time in seconds the user has to confirm enrollment on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"La durée en secondes que l'utilisateur a pour confirmer l'enrôlement de son "
"jeton WebAuthn. Note : vous pourrez incrémenter le ChallengeValidityTime si "
"besoin. Défaut : 60"

#: lib/tokens/webauthntoken.py:630
msgid ""
"Whether to limit roll out of WebAuthn tokens to either only platform "
"authenticators, or only cross-platform authenticators. Default: either"
msgstr ""
"Limiter le déploiement de jetons WebAuthn à des authentificateurs mono-"
"plateforme, ou aux authentificateurs multiplateformes. Défaut : tous"

#: lib/tokens/webauthntoken.py:641
msgid ""
"A list of WebAuthn authenticators acceptable for enrollment, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"Une liste d'authentificateurs WebAuthn acceptés pour l'enrôlement, fournie "
"comme une liste de AAGUID séparés par des espaces. Par défaut, tous les "
"authentificateurs sont acceptés."

#: lib/tokens/webauthntoken.py:647
msgid ""
"Whether the user's identity should be verified when rolling out a new "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"Si l'identité de l'utilisateur doit être vérifiée lors du déploiement d'un "
"nouveau jeton WebAuthn. Défaut : préféré (vérifie l'utilisateur si supporté "
"par le jeton)"

#: lib/tokens/webauthntoken.py:658
#, python-brace-format
msgid ""
"Which algorithm are available to use for creating public key credentials for "
"WebAuthn tokens. (Default: [{0!s}], Order: [{1!s}])"
msgstr ""
"Algorithmes disponibles à l'utilisation pour la création des identifiants de "
"clé publique pour les jetons WebAuthn. (Défaut : [{0!s}], Ordre : [{1!s}])"

#: lib/tokens/webauthntoken.py:668
msgid ""
"Whether to request attestation data when enrolling a new WebAuthn token. "
"Note: for u2f_req to work with WebAuthn, this cannot be set to none. "
"Default: direct (ask for non-anonymized attestation data)"
msgstr ""
"Si les données de l'attestation sont demandées lors de l'enrôlement d'un "
"nouveau jeton WebAuthn. Note : pour que u2f_req fonctionne avec WebAuthn, il "
"ne doit pas être défini à aucun. Défaut : direct (demande pour les données "
"d'attestation non anonymes)"

#: lib/tokens/webauthntoken.py:680
msgid ""
"Whether and how strictly to check authenticator attestation data. Note: If "
"the attestation form is none, the attestation level needs to also be none. "
"Default: untrusted (attestation is required, but can be unknown or self-"
"signed)"
msgstr ""
"Si et à quel point les données d'attestation de l'authentificateur sont "
"vérifiées. Note : si le formulaire d'attestation est aucun, le niveau "
"d'attestation doit aussi être à aucun. Défaut : non fiable (l'attestation "
"est requise, mais peut être inconnue ou auto-signée)"

#: lib/tokens/webauthntoken.py:692
msgid "Only the specified WebAuthn-tokens are allowed to be registered."
msgstr "Seuls les jetons WebAuthn spécifiés sont autorisés à s'enregistrer."

#: lib/tokens/webauthntoken.py:697
msgid "The user may only have this number of WebAuthn tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"WebAuthn."

#: lib/tokens/webauthntoken.py:702
msgid "The user may only have this number of active WebAuthn tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"WebAuthn actifs."

#: lib/tokens/webauthntoken.py:707
msgid ""
"Use an alternative challenge text for telling the user to confirm the "
"enrollment with his WebAuthn device. You can also use tags for automated "
"replacement. Check out the documentation for more details."
msgstr ""
"Utiliser un texte alternatif de challenge pour indiquer à l'utilisateur de "
"confirmer l'enrôlement avec son appareil WebAuthn. Vous pouvez aussi "
"utiliser des tags pour le remplacement automatique. Consultez la "
"documentation pour plus de détails."

#: lib/tokens/yubicotoken.py:101
msgid "Yubikey Cloud mode: Forward authentication request to YubiCloud."
msgstr ""
"Yubikey Mode Cloud : Transfère la requête d'authentification à YubiCloud."

#: lib/tokens/yubicotoken.py:110
msgid "The user may only have this maximum number of Yubico tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"Yubico."

#: lib/tokens/yubicotoken.py:116
msgid ""
"The user may only have this maximum number of active Yubico tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"Yubico actifs."

#: lib/tokens/yubikeytoken.py:164
msgid "Yubikey AES mode: One Time Passwords with Yubikey."
msgstr "Yubikey Mode AES : Mots de passe uniques avec Yubikey."

#: lib/tokens/yubikeytoken.py:173
msgid "The user may only have this maximum number of Yubikey tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"Yubikey."

#: lib/tokens/yubikeytoken.py:179
msgid ""
"The user may only have this maximum number of active Yubikey tokens assigned."
msgstr ""
"L'utilisateur ne peut se voir attribuer que ce nombre maximal de jetons "
"Yubikey actifs."

#: lib/tokens/yubikeytoken.py:184
msgid ""
"The Yubikey access code can be read by an enrollment client to initialize "
"Yubikeys."
msgstr ""
"Le code d'accès Yubikey peut être lu par un client d'enrôlement pour "
"initialiser Yubikeys."

#: lib/utils/compare.py:189
msgid "true if the value of the left attribute contains the right value"
msgstr "vrai si la valeur de l'attribut de gauche contient la valeur de droite"

#: lib/utils/compare.py:190
msgid "false if the value of the left attribute contains the right value"
msgstr "faux si la valeur de l'attribut de gauche contient la valeur de droite"

#: lib/utils/compare.py:192
msgid "true if the value of the left attribute equals the right value"
msgstr "vrai si la valeur de l'attribut de gauche égale celle de droite"

#: lib/utils/compare.py:193
msgid "false if the value of the left attribute equals the right value"
msgstr ""
"faux si la valeur de l'attribut de gauche équivaut à la valeur de droite"

#: lib/utils/compare.py:195
msgid ""
"true if the value of the left attribute completely matches the given regular "
"expression pattern on the right"
msgstr ""
"vrai si la valeur de l'attribut de gauche correspond exactement au modèle "
"donné de l'expression régulière de droite"

#: lib/utils/compare.py:196
msgid ""
"false if the value of the left attribute completely matches the given "
"regular expression pattern on the right"
msgstr ""
"faux si la valeur de l'attribut de gauche correspond exactement au modèle "
"donné de l'expression régulière de droite"

#: lib/utils/compare.py:198
msgid ""
"true if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr ""
"vrai si la valeur de l'attribut de gauche est contenue dans les valeurs "
"séparées par des virgules de la valeur de droite"

#: lib/utils/compare.py:199
msgid ""
"false if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr ""
"faux si la valeur de l'attribut de gauche est contenue dans les valeurs "
"séparées par des virgules de la valeur de droite"

#: lib/utils/compare.py:201
msgid ""
"true if the integer value of the left attribute is smaller than the right "
"integer value"
msgstr ""
"vrai si la valeur entière de l'attribut de gauche est inférieure à celle de "
"droite"

#: lib/utils/compare.py:202
msgid ""
"true if the integer value of the left attribute is bigger than the right "
"integer value"
msgstr ""
"vrai si la valeur entière de l'attribut de gauche est supérieure à celle de "
"droite"

#, fuzzy
#~| msgid "Admin is allowed to edit the container description."
#~ msgid "Admin is allowed to register containers for synchronization."
#~ msgstr "L'administrateur est autorisé à éditer la description du conteneur."

#, fuzzy
#~| msgid "Admin is allowed to edit the container description."
#~ msgid "Admin is allowed to unregister containers from synchronization."
#~ msgstr "L'administrateur est autorisé à éditer la description du conteneur."

#, fuzzy
#~| msgid "Users are allowed to list their own containers."
#~ msgid ""
#~ "Users are allowed to register their own containers for synchronization."
#~ msgstr "Les utilisateurs sont autorisés à lister leurs propres conteneurs."

#, fuzzy
#~| msgid "Users are allowed to create containers."
#~ msgid "Users are allowed to unregister containers from synchronization."
#~ msgstr "Les utilisateurs sont autorisés à créer des conteneurs."

#~ msgid "The body of the mail that is sent."
#~ msgstr "Le corps du courriel envoyé."

#~ msgid "The text of the SMS."
#~ msgstr "Le texte du SMS."

#~ msgid ""
#~ "This is the template content of the new file. Can contain the tags as "
#~ "specified in the documentation."
#~ msgstr ""
#~ "Ceci est le contenu type du nouveau fichier. Il peut contenir des tags "
#~ "comme indiqué dans la documentation."

#~ msgid "You can replace placeholder like {logged_in_user}"
#~ msgstr "Vous pouvez remplacer l'attribut par défaut comme {logged_in_user}"

#~ msgid ""
#~ "Use an alternate challenge text for telling the user to enter an OTP "
#~ "value."
#~ msgstr ""
#~ "Utiliser un texte de challenge alternatif pour indiquer à l'utilisateur "
#~ "qu'il doit saisir une valeur OTP."

#~ msgid ""
#~ "Set label for a new enrolled Google Authenticator. Possible tags are &lt;"
#~ "u&gt; (user), &lt;r&gt; (realm), &lt;s&gt; (serial)."
#~ msgstr ""
#~ "Label pour les jetons Google Authenticator. Les tags possibles sont &lt;"
#~ "u&gt; (user), &lt;r&gt; (realm), &lt;s&gt; (serial)."

#~ msgid "This is the issuer label for new enrolled Google Authenticators."
#~ msgstr ""
#~ "Label du fournisseur pour les nouveaux jetons Google Authenticators."

#~ msgid "This is the URL to the token image for smartphone apps like FreeOTP."
#~ msgstr ""
#~ "Il s'agit de l'URL de l'image du jeton pour les applications pour "
#~ "téléphone telles que FreeOTP."

#~ msgid ""
#~ "The project ID, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "L'identifiant (ID) projet que le client devrait utiliser. Vous pouvez le "
#~ "récupérer depuis votre console Firebase."

#~ msgid ""
#~ "The project number, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Le numéro de projet que le client devrait utiliser. Vous pouvez le "
#~ "récupérer depuis votre console Firebase."

#~ msgid ""
#~ "The App ID, that the Android client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "L'identifiant Application (App ID) que le client Android devrait "
#~ "utiliser. Vous pouvez le récupérer depuis votre console Firebase."

#~ msgid ""
#~ "The API Key, that the Android client should use. Get it from your "
#~ "Firebase console."
#~ msgstr ""
#~ "La clé API que le client Android devrait utiliser. Vous pouvez la "
#~ "récupérer depuis votre console Firebase."

#~ msgid ""
#~ "The App ID, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "L'identifiant application (App ID) que le client IOS devrait utiliser. "
#~ "Vous pouvez la récupérer depuis votre console Firebase."

#~ msgid ""
#~ "The API Key, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "La clé API que le client iOS devrait utiliser. Vous pouvez la récupérer "
#~ "depuis votre console Firebase."
