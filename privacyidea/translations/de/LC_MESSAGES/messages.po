# German translations for PROJECT.
# Copyright (C) 2017 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
# Paul Lettich <paul.lettich@netknights.it>, 2023, 2024.
# Jelina Unger <jelina.unger@netknights.it>, 2024.
# Nils Behlen <nils.behlen@netknights.it>, 2024.
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2024-09-02 17:05+0200\n"
"PO-Revision-Date: 2024-09-03 02:47+0000\n"
"Last-Translator: Nils Behlen <nils.behlen@netknights.it>\n"
"Language-Team: German <https://hosted.weblate.org/projects/privacyidea/"
"privacyidea-server/de/>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 5.8-dev\n"
"Generated-By: Babel 2.12.1\n"

#: api/auth.py:227
msgid "Authentication failure. Unknown realm: {0!s}."
msgstr "Authentifizierungsfehler. Unbekannter Realm: {0!s}."

#: api/auth.py:231
msgid "Authentication failure. Missing Username"
msgstr "Authentifizierungsfehler. Fehlender Benutzername"

#: api/auth.py:352
msgid "Authentication failure. Wrong credentials"
msgstr "Authentifizierungsfehler. Falsche Login-Daten"

#: api/realm.py:528
msgid "The given node does not exist!"
msgstr "Der angegebene privacyIDEA-Knoten existiert nicht!"

#: api/realm.py:534 api/realm.py:544
msgid "Could not verify data in request!"
msgstr "Die Daten in der Anfrage können nicht verifiziert werden!"

#: api/lib/postpolicy.py:86
msgid ""
"\n"
"<--- Please describe your Problem in detail --->\n"
"\n"
"<--- Please provide as many additional information as possible --->\n"
"\n"
"privacyIDEA Version: {version}\n"
"Subscriber: {subscriber_name}\n"
"Subscriptions: {subscriptions}\n"
msgstr ""
"\n"
"<--- Bitte beschreiben Sie Ihr Problem detailliert --->\n"
"\n"
"<--- Bitte stellen Sie so viele zusätzliche Informationen wie möglich zur "
"Verfügung --->\n"
"\n"
"privacyIDEA Version: {version}\n"
"Kunde: {subscriber_name}\n"
"Subskription: {subscriptions}\n"

#: api/lib/prepolicy.py:2329
msgid "Missing description for {} token."
msgstr "Fehlende Beschreibung für {} Token."

#: api/lib/prepolicy.py:2330
msgid "Description required for {} token."
msgstr "Eine Beschreibung ist erforderlich für {} Token."

#: api/lib/utils.py:345
msgid "Authentication failure. Missing Authorization header."
msgstr "Authentifizierungsfehler. Fehlender Authentifizierungsheader."

#: api/lib/utils.py:351 api/lib/utils.py:384
msgid "Authentication failure. Error during decoding your token: {0!s}"
msgstr "Authentifizierungsfehler. Fehler beim Dekodieren des Tokens: {0!s}"

#: api/lib/utils.py:377 api/lib/utils.py:387
msgid "Authentication failure. Your token has expired: {0!s}"
msgstr "Authentifizierungsfehler. Der Token ist abgelaufen: {0!s}"

#: api/lib/utils.py:391
msgid ""
"Authentication failure. The username {0!s} is not allowed to impersonate via "
"JWT."
msgstr ""
"Fehler bei der Authentifizierung. Der Benutzername {0!s} ist nicht "
"berechtigt mittels JWT zuzugreifen."

#: api/lib/utils.py:395
msgid ""
"Authentication failure. You do not have the necessary role ({0!s}) to access "
"this resource!"
msgstr ""
"Authentifizierungsfehler. Sie haben nicht die nötige Rolle ({0!s}), um auf "
"die Ressource zuzugreifen!"

#: api/lib/utils.py:413
msgid "'{0!s}' is an invalid policy name."
msgstr "'{0!s}' ist ein ungültiger Name für eine Richtlinie."

#: api/lib/utils.py:416
msgid "The name of the policy may only contain the characters a-zA-Z0-9_. -"
msgstr "Der Name der Richtlinie darf nur die Zeichen 'a-zA-Z0-9_. -' enthalten"

#: lib/challengeresponsedecorators.py:149
msgid "Please enter the new PIN again"
msgstr "Wiederholen Sie bitte die neue PIN"

#: lib/challengeresponsedecorators.py:163
msgid "Please enter a new PIN"
msgstr "Vergeben Sie bitte eine neue PIN"

#: lib/challengeresponsedecorators.py:201
msgid "To resync your token, please enter the next OTP value"
msgstr ""
"Um Ihren Token neu zu synchronisieren, geben Sie bitte den nächsten OTP-Wert "
"ein"

#: lib/containerclass.py:446
msgid ""
"General purpose container that can hold any type and any number of token."
msgstr ""
"Allgemeiner Container, der beliebig viele Token aller Typen enthalten kann."

#: lib/decorators.py:41 lib/token.py:2359
msgid "This action is not possible, since the token is locked"
msgstr ""
"Diese Aktion kann nicht durchgeführt werden, weil der Token gesperrt ist"

#: lib/decorators.py:85
msgid "You either need to provide user or serial"
msgstr "Sie müssen entweder eine Seriennummer oder einen Benutzer angeben"

#: lib/decorators.py:111
msgid "You need to specify a serial or a user."
msgstr "Sie müssen eine Seriennummer oder einen Benutzer angeben."

#: lib/decorators.py:113
msgid "Invalid serial number."
msgstr "Ungültige Seriennummer."

#: lib/decorators.py:115
msgid "Invalid user."
msgstr "Ungültiger Benutzer."

#: lib/policy.py:1412
msgid "Invalid client definition!"
msgstr "Ungültige Client-Definition!"

#: lib/policy.py:1606
msgid "Define in which resolver the user should be registered."
msgstr ""
"Legen Sie fest, in welchem Resolver die Benutzer registriert werden sollen."

#: lib/policy.py:1610
msgid "Define in which realm the user should be registered."
msgstr ""
"Legen Sie fest, in welchem Realm die Benutzer registriert werden sollen."

#: lib/policy.py:1614
msgid ""
"The SMTP server configuration, that should be used to send the registration "
"email."
msgstr ""
"Die SMTP-Server-Konfiguration mit der Registrierungs-Emails versendet werden."

#: lib/policy.py:1618
msgid ""
"Only users with this email address are allowed to register. This is a "
"regular expression."
msgstr ""
"Nur Benutzer mit dieser EMail-Adresse können sich registrieren. Dies ist ein "
"Regulärer Ausdruck."

#: lib/policy.py:1623
msgid ""
"The body of the registration email. Use '{regkey}' as tag for the "
"registration key."
msgstr ""
"Der Inhalt der Registrierungs-Email. Benutze '{regkey}' als Tag für den "
"Registrierungsschlüssel."

#: lib/policy.py:1629
msgid "Admin is allowed to enable tokens."
msgstr "Der Administrator kann Token aktivieren."

#: lib/policy.py:1633
msgid "Admin is allowed to disable tokens."
msgstr "Der Adminitrator kann Token deaktivieren."

#: lib/policy.py:1637
msgid "Admin is allowed to set token properties."
msgstr "Der Administrator kann Token-Eigenschaften verändern."

#: lib/policy.py:1642
msgid "The admin is allowed to set the token description."
msgstr "Der Administrator darf die Token-Beschreibung setzen."

#: lib/policy.py:1646
msgid "Admin is allowed to set the OTP PIN of tokens."
msgstr "Der Administrator kann die OTP PIN von Token setzen."

#: lib/policy.py:1652
msgid "Admin is allowed to set a random OTP PIN of tokens."
msgstr ""
"Der Administrator kann die OTP PIN von Token auf einen zufälligen Wert "
"setzen."

#: lib/policy.py:1656
msgid "Admin is allowed to manually set and delete token info."
msgstr "Der Administrator kann Tokeninformationen ändern und löschen."

#: lib/policy.py:1660
msgid "Admin is allowed to set the OTP PIN during enrollment."
msgstr "Der Administrator kann die OTP PIN während des Rollouts setzen."

#: lib/policy.py:1665
msgid "Admin is allowed to resync tokens."
msgstr "Der Administrator kann Token resynchronisieren."

#: lib/policy.py:1669
msgid "Admin is allowed to reset the Failcounter of a token."
msgstr ""
"Der Administrator kann den Fehlerzähler (Failcounter) von Token zurücksetzen."

#: lib/policy.py:1675
msgid "Admin is allowed to revoke a token"
msgstr "Der Administrator kann Token revozieren"

#: lib/policy.py:1679
msgid "Admin is allowed to assign a token to a user."
msgstr "Der Administrator kann Token einem Benutzer zuweisen."

#: lib/policy.py:1685
msgid ""
"Admin is allowed to remove the token from a user, i.e. unassign a token."
msgstr "Der Administrator kann die Zuweisung eines Tokens aufheben."

#: lib/policy.py:1691
msgid "Admin is allowed to import token files."
msgstr "Der Administrator kann eine Token-Seed-Datei importieren."

#: lib/policy.py:1696
msgid "Admin is allowed to remove tokens from the database."
msgstr "Der Administrator kann Token aus der Datenbank löschen."

#: lib/policy.py:1702
msgid "Admin is allowed to view the list of the users."
msgstr "Der Adminsitrator kann die Benutzerliste anzeigen."

#: lib/policy.py:1708
msgid "The Admin is allowed to list the machines."
msgstr "Der Administrator kann Maschinen auflisten."

#: lib/policy.py:1713
msgid "The Admin is allowed to attach and detach tokens to machines."
msgstr ""
"Der Administrator kann Token Maschinen zuweisen und diese Zuweisung wieder "
"aufheben."

#: lib/policy.py:1720
msgid ""
"The Admin is allowed to fetch authentication items of tokens assigned to "
"machines."
msgstr ""
"Der Administrator kann Authentifizierungsinformationen der den Maschinen "
"zugewiesenen Token erfragen."

#: lib/policy.py:1725
msgid "Admin is allowed to manage the realms of a token."
msgstr "Der Administrator kann die Realms eines Tokens bearbeiten."

#: lib/policy.py:1730
msgid "Admin is allowed to list tokens."
msgstr "Der Administrator darf Token auflisten."

#: lib/policy.py:1734
msgid "Admin is allowed to retrieve a serial for a given OTP value."
msgstr "Der Administrator kann die Seriennummer zu einem OTP-Wert bestimmen."

#: lib/policy.py:1739
msgid "Admin is allowed to retrieve random keys from privacyIDEA."
msgstr "Der Adminsitrator kann Zufallszahlen von privacyIDEA anfordern."

#: lib/policy.py:1743
msgid "Admin is allowed to copy the PIN of one token to another token."
msgstr ""
"Der Administrator kann die OTP PIN eines Tokens zu einem anderen kopieren."

#: lib/policy.py:1748
msgid ""
"Admin is allowed to copy the assigned user to another token, i.e. assign a "
"user to another token."
msgstr ""
"Der Administrator kann die Zuweisung eines Benutzer von einem Token zu einem "
"anderen Token übertragen. D.h. dem Benutzer einen anderen Token zuweisen."

#: lib/policy.py:1754
msgid "Admin is allowed to trigger the lost token workflow."
msgstr "Der Administrator kann den Workflow \"Verlorener Token\" durchführen."

#: lib/policy.py:1760
msgid "Admin is allowed to write and modify the system configuration."
msgstr "Der Administrator kann die Systemkonfiguration verändern."

#: lib/policy.py:1765
msgid "Admin is allowed to delete keys in the system configuration."
msgstr ""
"Der Administrator kann Einstellungen in der Systemkonfiguration löschen."

#: lib/policy.py:1771
msgid "Admin is allowed to read basic system configuration."
msgstr "Der Administrator darf die Basiskonfiguration lesen."

#: lib/policy.py:1776
msgid ""
"Admin is allowed to export a documentation of the complete configuration "
"including resolvers and realm."
msgstr ""
"Der Administrator kann eine Dokumentation der kompletten Konfiguration "
"exportieren. Dies beinhaltet auch die Konfiguration von Resolvern und Realms."

#: lib/policy.py:1784
msgid "Admin is allowed to write and modify the policies."
msgstr "Der Administrator kann Richtlinien anlegen und bearbeiten."

#: lib/policy.py:1789
msgid "Admin is allowed to delete policies."
msgstr "Der Administrator kann Richtlinien löschen."

#: lib/policy.py:1794
msgid "Admin is allowed to read policies."
msgstr "Der Administrator darf Richtlinien lesen."

#: lib/policy.py:1798
msgid ""
"Admin is allowed to write and modify the resolver and realm configuration."
msgstr ""
"Der Administrator kann die Konfiguration von Resolvern und Realms anlegen "
"und bearbeiten."

#: lib/policy.py:1805
msgid "Admin is allowed to delete resolvers and realms."
msgstr "Der Administrator kann Resolver und Realms löschen."

#: lib/policy.py:1810
msgid "Admin is allowed to read resolvers."
msgstr "Der Administrator darf Resolver lesen."

#: lib/policy.py:1814
msgid ""
"Admin is allowed to create new CA Connector definitions and modify existing "
"ones."
msgstr ""
"Der Administrator kann Konfigurationen der Zertifizierungsstellen anlegen "
"und bearbeiten."

#: lib/policy.py:1820
msgid "Admin is allowed to delete CA Connector definitions."
msgstr ""
"Der Administrator kann Konfigurationen der Zertifizierungsstellen löschen."

#: lib/policy.py:1825
msgid "Admin is allowed to read CA Connector definitions."
msgstr "Der Administrator kann die Definitionen der CA-Konnektoren lesen."

#: lib/policy.py:1830
msgid "Admin is allowed to write and modify the machine resolvers."
msgstr ""
"Der Administrator kann Maschinenkonfigurationen anlegen und bearbeiten."

#: lib/policy.py:1836
msgid "Admin is allowed to delete machine resolvers."
msgstr "Der Administrator kann Maschinenkonfigurationen löschen."

#: lib/policy.py:1842
msgid "Admin is allowed to read machine resolvers."
msgstr "Der Administrator darf Maschinen-Resolver lesen."

#: lib/policy.py:1849 lib/policy.py:2174
msgid "Set the maximum allowed length of the OTP PIN."
msgstr "Die maximal erlaubte Länge einer OTP PIN."

#: lib/policy.py:1854 lib/policy.py:2179
msgid "Set the minimum required length of the OTP PIN."
msgstr "Die minimal geforderte Länge einer OTP PIN."

#: lib/policy.py:1858 lib/policy.py:2183
msgid ""
"Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
"(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgstr ""
"Geben Sie den geforderten Inhalt der OTP PIN an. (c) für Buchstaben, (n) für "
"Zahlen, (s) für Sonderzeichen. Sie können die Attribute +/- verwenden oder "
"eine dedizierte Liste von Zeichen angeben, z.B. [1234565890]"

#: lib/policy.py:1867
msgid "The length of a random PIN set by the administrator."
msgstr "Die Länge der vom Administrator gesetzten zufälligen PIN."

#: lib/policy.py:1870
msgid "Admin is allowed to view the Audit log."
msgstr "Der Adminsitrator kann das Audit-Log ansehen."

#: lib/policy.py:1874
msgid "The admin will only see audit entries of the last 10d, 3m or 2y."
msgstr ""
"Der Administrator kann nur Audit-Einträge der letzen 10 Tage (10d), 3 Monate "
"(3m) oder 2 Jahre (2y) sehen."

#: lib/policy.py:1879
msgid "The admin will not see the specified columns in the audit."
msgstr ""
"Die angegebenen Spalten werden im Audit Log ausgeblendet und dem "
"Administrator nicht angezeigt."

#: lib/policy.py:1884
msgid "The admin is allowed to download the complete auditlog."
msgstr "Der Administrator kann das Audit-Log herunterladen."

#: lib/policy.py:1889
msgid "Admin is allowed to add users in a userstore/UserIdResolver."
msgstr "Der Adminstrator kann Benutzer hinzufügen."

#: lib/policy.py:1894
msgid "Admin is allowed to update the users data in a userstore."
msgstr "Der Administrator kann Benutzerdaten editieren."

#: lib/policy.py:1899
msgid "Admin is allowed to delete a user object in a userstore."
msgstr "Der Administrator kann Benutzer in der Benutzerquelle löschen."

#: lib/policy.py:1904
msgid "Admin is allowed to set the password of the HSM/Security Module."
msgstr ""
"Der Administrator kann das Passwort des HSM/Sicherheitsmoduls eingeben."

#: lib/policy.py:1908
msgid "Admin is allowed to retrieve the list of active challenges."
msgstr "Der Administrator kann eine Liste der aktiven Challenges anzeigen."

#: lib/policy.py:1914
msgid "Admin is allowed to write new SMTP server definitions."
msgstr "Der Administrator kann SMTP-Server-Konfigurationen bearbeiten."

#: lib/policy.py:1919
msgid "Admin is allowed to read SMTP server definitions."
msgstr "Der Administrator darf SMTP-Server-Definitionen lesen."

#: lib/policy.py:1924
msgid "Admin is allowed to write new RADIUS server definitions."
msgstr "Der Administrator kann RADIUS-Server-Konfigurationen bearbeiten."

#: lib/policy.py:1930
msgid "Admin is allowed to read RADIUS server definitions."
msgstr "Der Administrator darf RADIUS-Server-Definitionen lesen."

#: lib/policy.py:1935
msgid "Admin is allowed to write remote privacyIDEA server definitions."
msgstr "Der Administrator kann Remote privacyIDEA Server definieren."

#: lib/policy.py:1942
msgid "Admin is allowed to read remote privacyIDEA server definitions."
msgstr ""
"Der Administrator darf die Definitionen von Remote privacyIDEA Systemen "
"lesen."

#: lib/policy.py:1949
msgid "Admin is allowed to write periodic task definitions."
msgstr "Der Administrator kann regelmäßige Aufgaben bearbeiten."

#: lib/policy.py:1954
msgid "Admin is allowed to read periodic task definitions."
msgstr ""
"Der Administrator darf Definitionen von wiederkehrenden Aufgaben lesen."

#: lib/policy.py:1959
msgid "Admin is allowed to read statistics data."
msgstr "Der Administrator kann Statistikdaten lesen."

#: lib/policy.py:1962
msgid "Admin is allowed to delete statistics data."
msgstr "Der Administrator kann Statistikdaten löschen."

#: lib/policy.py:1965
msgid "Admin is allowed to write and modify the event handling configuration."
msgstr "Der Administrator kann Event-Handler-Definitionen bearbeiten."

#: lib/policy.py:1971
msgid "Admin is allowed to read event handling configuration."
msgstr "Der Administrator darf die Definition von Event-Handlern lesen."

#: lib/policy.py:1976
msgid "Admin is allowed to write and modify SMS gateway definitions."
msgstr "Der Administrator kann SMS-Gateway-Konfigurationen bearbeiten."

#: lib/policy.py:1982
msgid "Admin is allowed to read SMS gateway definitions."
msgstr "Der Administrator darf Definitionen von SMS-Gateways lesen."

#: lib/policy.py:1987
msgid ""
"Admin is allowed to get the list of authenticated clients and their types."
msgstr ""
"Der Administrator kann die Liste der authentifizierten Client-Applikationen "
"anzeigen."

#: lib/policy.py:1994
msgid "Admin is allowed to add and delete component subscriptions."
msgstr "Der Administrator kann Subskriptionen importieren und löschen."

#: lib/policy.py:2000
msgid "The Admin is allowed to trigger a challenge for e.g. SMS OTP token."
msgstr ""
"Der Administrator kann eine Challenge für bspw. SMS OTP Token auslösen."

#: lib/policy.py:2006
msgid ""
"The Admin is allowed to set certain custom user attributes. If the Admin "
"should be allowed to set any attribute, set this to '*:*'. For more details, "
"check the documentation."
msgstr ""
"Der Administrator darf gewisse benutzerdefinierte Attribute setzen. Wenn der "
"Administrator jedes beliebige Attribut setzen können soll, tragen Sie hier "
"'*:*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#: lib/policy.py:2014
msgid ""
"The Admin is allowed to delete certain custom user attributes. If the Admin "
"should be allowed to delete any attribute, set this to '*'. For more "
"details, check the documentation."
msgstr ""
"Der Administrator darf gewisse benutzerdefinierte Attribute löschen. Wenn "
"der Administrator jedes beliebige benutzerdefinierte Attribut löschen können "
"soll, setzen sie dies auf '*'. Für weitere Details lesen Sie bitte die "
"Dokumentation."

#: lib/policy.py:2022
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the admin."
msgstr ""
"Dies ist eine mit Leerzeichen getrennte Liste an Tokeninfo-Einträge, die dem "
"Administrator nicht angezeigt werden."

#: lib/policy.py:2027
msgid "The Admin is allowed list the available tokengroups."
msgstr "Der Administrator kann die verfügbaren Token-Gruppen anzeigen."

#: lib/policy.py:2032
msgid "The Admin is allowed to add a new tokengroup."
msgstr "Der Administrator kann neue Token-Gruppen hinzufügen."

#: lib/policy.py:2037
msgid "The Admin is allowed delete a tokengroup."
msgstr "Der Administrator kann Token-Gruppen löschen."

#: lib/policy.py:2042
msgid "The Admin is allowed list the available service ID definitions."
msgstr ""
"Der Administrator kann die verfügbaren Dienste-Kennzeichnungen anzeigen."

#: lib/policy.py:2047
msgid "The Admin is allowed to add a new service ID definition."
msgstr "Der Administrator darf neue Dienste-Kennzeichnungen hinzufügen."

#: lib/policy.py:2052
msgid "The Admin is allowed delete a service ID definition."
msgstr "Der Administrator kann Dienste-Kennzeichnungen löschen."

#: lib/policy.py:2057
msgid "The Admin is allowed to manage the tokengroups of a token."
msgstr "Der Administrator kann die Token-Gruppen eines Tokens bearbeiten."

#: lib/policy.py:2061
msgid "Admin is allowed to edit the container info."
msgstr "Administratoren können die Container Info bearbeiten."

#: lib/policy.py:2065
msgid "Admin is allowed to edit the container state."
msgstr "Administratoren können den Container Status bearbeiten."

#: lib/policy.py:2069
msgid "Admin is allowed to edit the container description."
msgstr "Administratoren können die Container Beschreibung bearbeiten."

#: lib/policy.py:2073
msgid "Admin is allowed to create containers."
msgstr "Administratoren können Container erstellen."

#: lib/policy.py:2077
msgid "Admin is allowed to delete containers."
msgstr "Administratoren können Container löschen."

#: lib/policy.py:2081
msgid "Admin is allowed to add tokens to containers."
msgstr "Administratoren können Token zu Containern hinzufügen."

#: lib/policy.py:2085
msgid "Admin is allowed to remove tokens from containers."
msgstr "Administratoren können Tokens aus Containern entfernen."

#: lib/policy.py:2089
msgid "Admin is allowed to assign users to containers."
msgstr "Administratoren können Container einem Benutzer zuweisen."

#: lib/policy.py:2093
msgid "Admin is allowed to unassign users from containers."
msgstr "Administratoren können Benutzerzuweisungen eines Containers aufheben."

#: lib/policy.py:2097
msgid "Admin is allowed to set the realm of containers."
msgstr "Administratoren können die Realms eines Containers bearbeiten."

#: lib/policy.py:2101
msgid "Admin is allowed to list containers."
msgstr "Administratoren können Container auflisten."

#: lib/policy.py:2108
msgid ""
"The user is allowed to assign an existing token that is not yet assigned "
"using the token serial number."
msgstr ""
"Der Benutzer darf sich einen noch nicht zugewiesenen Token anhand der "
"Seriennummer zuweisen."

#: lib/policy.py:2114
msgid "The user is allowed to disable his own tokens."
msgstr "Der Benutzer darf seine eigenen Token deaktivieren."

#: lib/policy.py:2120
msgid "The user is allowed to enable his own tokens."
msgstr "Der Benutzer darf seine eigenen Token aktivieren."

#: lib/policy.py:2126
msgid "The user is allowed to delete his own tokens."
msgstr "Der Benutzer darf seine eigenen Token löschen."

#: lib/policy.py:2132
msgid "The user is allowed to unassign his own tokens."
msgstr "Der Benutzer darf die eigene Zuweisung zu seinen Token aufheben."

#: lib/policy.py:2137
msgid "The user is allowed to resyncronize his tokens."
msgstr "Der Benutzer kann seine eigenen Token resynchronisieren."

#: lib/policy.py:2142
msgid "The user is allowed to revoke a token"
msgstr "Der Benutzer darf seine eigenen Token revozieren"

#: lib/policy.py:2147
msgid "The user is allowed to reset the failcounter of his tokens."
msgstr "Der Benutzer darf den Fehlerzähler seiner eigenen Token zurücksetzen."

#: lib/policy.py:2152
msgid "The user is allowed to set the OTP PIN of his tokens."
msgstr "Der Benutzer darf die OTP PINs seiner Token setzen."

#: lib/policy.py:2157
msgid "The user is allowed to set a random OTP PIN of his tokens."
msgstr ""
"Der Benutzer kann die OTP PIN seiner Token auf einen zufälligen Wert setzen."

#: lib/policy.py:2162
msgid "The length of a random PIN set by the user."
msgstr "Die Länge der vom Benutzer gesetzten zufälligen PIN."

#: lib/policy.py:2165
msgid "The user is allowed to set the token description."
msgstr "Der Benutzer darf die Token-Beschreibung setzen."

#: lib/policy.py:2169
msgid "The user is allowed to set the OTP PIN during enrollment."
msgstr "Der Benutzer kann die OTP PIN während des Rollouts setzen."

#: lib/policy.py:2191
msgid "Allow the user to view his own token history."
msgstr "Der Benutzer kann die Tokenhistorie seiner eigenen Token anzeigen."

#: lib/policy.py:2194
msgid "The user will only see audit entries of the last 10d, 3m or 2y."
msgstr ""
"Der Benutzer kann nur die Audit-Einträge der letzten 10 Tage (10d), 3 Monate "
"(3m) oder 2 Jahre (2y) sehen."

#: lib/policy.py:2198
msgid "The user will not see the specified columns in the audit."
msgstr ""
"Die angegebenen Spalten werden im Audit Log ausgeblendet und dem Benutzer "
"nicht angezeigt."

#: lib/policy.py:2203
msgid "The user is allowed to view his own user information."
msgstr "Der Benutzer kann seine eigenen Benutzerinformationen sehen."

#: lib/policy.py:2207
msgid ""
"The user is allowed to update his own user information, like changing his "
"password."
msgstr "Der Benutzer darf seine eigenen Benutzerinformationen bearbeiten."

#: lib/policy.py:2212
msgid ""
"The user is allowed to do a password reset in an editable UserIdResolver."
msgstr "Der Benutzer darf sein Passwort im Benutzerverzeichnis setzen."

#: lib/policy.py:2218
msgid ""
"The user is allowed to set certain custom user attributes. If the user "
"should be allowed to set any attribute, set this to '*:*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"Der Benutzer darf gewisse benutzerdefinierte Attribute setzen. Wenn der "
"Benutzer jedes beliebige Attribut setzen können soll, tragen Sie hier '*:*' "
"ein. Benutzern Sie '*' mit VORSICHT! Für weitere Details lesen Sie bitte die "
"Dokumentation."

#: lib/policy.py:2226
msgid ""
"The user is allowed to delete certain custom user attributes. If the user "
"should be allowed to delete any attribute, set this to '*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"Der Benutzer darf gewisse benutzerdefinierte Attribute löschen. Wenn der "
"Benutzer jedes beliebige Attribut löschen können soll, tragen Sie hier bitte "
"'*' ein. Verwenden Sie '*' mit VORSICHT! Für weitere Detail lesen Sie bitte "
"die Dokumentation."

#: lib/policy.py:2234
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the user."
msgstr ""
"Dies ist eine mit Leerzeichen getrennte Liste an Tokeninfo-Einträgen, die "
"dem Benutzer nicht angezeigt werden."

#: lib/policy.py:2240
msgid "Users are allowed to edit the state of their own containers."
msgstr "Benutzer können den Status ihrer eigenen Container bearbeiten."

#: lib/policy.py:2244
msgid "Users are allowed to edit the description of their own containers."
msgstr "Benutzer können die Beschreibung ihrer eigenen Container bearbeiten."

#: lib/policy.py:2249
msgid "Users are allowed to create containers."
msgstr "Benutzer können Container erstellen."

#: lib/policy.py:2253
msgid "Users are allowed to delete their own containers."
msgstr "Benutzer können ihre eigenen Container löschen."

#: lib/policy.py:2257
msgid "Users are allowed to add their own tokens to their own containers."
msgstr ""
"Die Benutzer dürfen ihre eigenen Token zu ihren eigenen Containern "
"hinzufügen."

#: lib/policy.py:2262
msgid "Users are allowed to remove their own tokens from their own containers."
msgstr ""
"Benutzer können ihre eigenen Token aus ihren eigenen Containern entfernen."

#: lib/policy.py:2267
msgid "Users are allowed to assign themselves to containers without an owner."
msgstr "Die Benutzer dürfen sich einem Container ohne Besitzer zuweisen."

#: lib/policy.py:2272
msgid "Users are allowed to unassign themselves from containers."
msgstr "Benutzer können die Zuweisung zu ihren Containern aufheben."

#: lib/policy.py:2276
msgid "Users are allowed to list their own containers."
msgstr "Benutzer können ihre eigenen Container auflisten."

#: lib/policy.py:2283
msgid "Limit the number of allowed tokens in a realm."
msgstr "Maximale Anzahl von Token in einem realm."

#: lib/policy.py:2287
msgid ""
"During the rollout process, this policy makes the description required for "
"all selected tokentypes."
msgstr ""
"Diese Richtlinie erzwingt die Angabe einer Beschreibung beim ausrollen für "
"die angegebenen Tokentypen."

#: lib/policy.py:2295
msgid "Limit the number of tokens a user may have assigned."
msgstr "Maximale Anzahl an Token, die ein Benutzer besitzen darf."

#: lib/policy.py:2300
msgid "Limit the number of active tokens a user may have assigned."
msgstr "Die Anzahl der aktiven Tokens pro Benutzer begrenzen."

#: lib/policy.py:2305
msgid ""
"Set a random OTP PIN with this length for a token during the enrollment "
"process."
msgstr ""
"Setze eine zufällige OTP PIN dieser Länge während des Ausrollens eines "
"Tokens."

#: lib/policy.py:2310
msgid "In case of a random OTP PIN use this python module to process the PIN."
msgstr ""
"Wenn eine zufällige OTP PIN gesetzt wird, nutze dieses Python Modul, um die "
"PIN zu verarbeiten."

#: lib/policy.py:2315
msgid ""
"If the administrator sets the OTP PIN during enrollment or later, the user "
"will have to change the PIN during first use."
msgstr ""
"Wenn der Administrator die OTP PIN setzt (während des Ausrollens oder "
"später) muss der Benutzer die OTP PIN zurücksetzen."

#: lib/policy.py:2322
msgid ""
"The user needs to change his PIN on a regular basis. To change the PIN every "
"180 days, enter '180d'."
msgstr ""
"Der Benutzer muss die OTP PIN regelmäßig ändern. Um die PIN all 180 Tage zu "
"ändern, geben Sie '180d' ein."

#: lib/policy.py:2329
msgid ""
"The OTP PIN can be hashed or encrypted. Hashing the PIN is the default "
"behaviour."
msgstr ""
"Die OTP PIN wird standardmäßig gehasht abgespeichert. Wenn sie verschlüsselt "
"abgespeichert werden soll, wählen Sie diese Option."

#: lib/policy.py:2334
msgid ""
"The label for a new enrolled Smartphone token. Possible tags are <code>{user}"
"</code>, <code>{realm}</code>, <code>{serial}</code>, <code>{givenname}</"
"code> and <code>{surname}</code>."
msgstr ""
"Die Bezeichnung für ein neu ausgerolltes Smartphone-Token. Mögliche "
"Platzhalter sind <code>{user}</code>, <code>{realm}</code>, <code>{serial}</"
"code>, <code>{givenname}</code> und <code>{surname}</code>."

#: lib/policy.py:2340
msgid ""
"The issuer label for new enrolled Smartphone token.Possible tags are "
"<code>{user}</code>, <code>{realm}</code>, <code>{serial}</code>, "
"<code>{givenname}</code> and <code>{surname}</code>."
msgstr ""
"Die Bezeichnung des Ausstellers für neu ausgerollte Smartphone-Token. "
"Mögliche Platzhalter sind <code>{user}</code>, <code>{realm}</code>, "
"<code>{serial}</code>, <code>{givenname}</code> und <code>{surname}</code>."

#: lib/policy.py:2347
msgid ""
"This is the URL to the token image for the privacyIDEA Authenticator and "
"some other apps like FreeOTP (supported file formats: PNG, JPG and GIF)."
msgstr ""
"Die URL zum Token-Symbol für den privacyIDEA Authenticator und anderen Apps "
"wie FreeOTP (unterstützte Bildformate: PNG, JPG und GIF)."

#: lib/policy.py:2354
msgid ""
"Users can assign a token just by using the unassigned token to authenticate."
msgstr ""
"Der Benutzer kann sich automatisch einen Token zuweisen, indem er sich mit "
"einem noch nicht zugewiesenen Token anmeldet."

#: lib/policy.py:2360
msgid "The length of the password in case of temporary token (lost token)."
msgstr ""
"Die Länge des Passworts für einen temporären Token (Workflow \"Verlorener "
"Token\")."

#: lib/policy.py:2364
msgid ""
"The contents of the temporary password, described by the characters C, c, n, "
"s, 8."
msgstr ""
"Der Inhalt des temporären Passworts. 'C': Große Buchstaben, 'c': kleine "
"Buchstaben, 'n': Ziffern, 's': Sonderzeichen, '8' Base58 Zeichensatz."

#: lib/policy.py:2369
msgid "The length of the validity for the temporary token (in days)."
msgstr "Die Gültigkeitsdauer des temporären Passworts in Tagen."

#: lib/policy.py:2374
msgid "Set the length of registration codes."
msgstr "Setzt die Länge des Registrierungscodes."

#: lib/policy.py:2378
msgid ""
"Specify the required contents of the registration code. (c)haracters, "
"(n)umeric, (s)pecial. Use modifiers +/- or a list of allowed characters "
"[1234567890]"
msgstr ""
"Definiert den erforderlichen Inhalt des Registrierungscodes. (c) Buchstaben, "
"(n) Nummern und (s) Sonderzeichen. Sie können die Attribute +/- verwenden "
"oder eine dedizierte Liste von Zeichen angegeben, z.B. [1234567890]"

#: lib/policy.py:2387
msgid "Set the length of the password of generated password tokens."
msgstr "Die Länge des Passworts für einen generierten Passwort-Token."

#: lib/policy.py:2391
msgid ""
"Specify the required contents of the password of a password token. "
"(c)haracters, (n)umeric, (s)pecial. Use modifiers +/- or a list of allowed "
"characters [1234567890]"
msgstr ""
"Geben Sie den geforderten Inhalt des Passwortes eines Passwort-Tokens an. "
"(c) Buchstaben, (n) Zahlen und (s) Sonderzeichen. Sie können die Attribute "
"+/- verwenden oder eine dedizierte Liste von Zeichen angeben, z.B. "
"[1234565890]"

#: lib/policy.py:2399
msgid ""
"Specify the email validator that should be used to validate email addresses "
"during enrollment."
msgstr ""
"Geben Sie den Email-Validierer an, der beim Ausrollen verwendet werden soll."

#: lib/policy.py:2405
msgid ""
"Specify the list of token types, that must be verified during enrollment."
msgstr ""
"Eine Liste von Tokentypen, die beim Rollout durch die Eingabe eines OTP-"
"Wertes verifiziert werden sollen."

#: lib/policy.py:2418
msgid ""
"Either use the Token PIN , use the Userstore Password or use no fixed "
"password component."
msgstr ""
"Der erste Wissensfaktor kann entweder die OTP PIN, das Passwort aus der "
"Benutzerquelle oder nichts sein."

#: lib/policy.py:2423
msgid ""
"Specify the list of token types, that must be used with challenge response."
msgstr ""
"Liste von Tokentypen, welche nur noch im Challenge-Response Verfahren "
"verwendet werden können."

#: lib/policy.py:2431
msgid ""
"Use an alternative challenge text for telling the user to enter an OTP "
"value. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr ""
"Ein alternativer Challenge-Text, um den Benutzer aufzufordern, den Code aus "
"der Email einzugeben. Es können tags (siehe Dokumentation) zur Textersetzung "
"verwendet werden."

#: lib/policy.py:2438
msgid ""
"If there are several different challenges, this text precedes the list of "
"the challenge texts."
msgstr ""
"Wenn es mehrere verschiedene Challengetexte gibt, wird dieser Text der Liste "
"der anderen Texte vorangestellt."

#: lib/policy.py:2443
msgid ""
"If there are several different challenges, this text follows the list of the "
"challenge texts."
msgstr ""
"Wenn es mehrere verschiedene Challengetexte gibt, wird dieser Text an die "
"Liste der anderen Texte hinten angefügt."

#: lib/policy.py:2448
msgid ""
"If the PIN of a token is to be changed, this will allow the user to change "
"the PIN during a validate/check request via challenge / response."
msgstr ""
"Wenn die PIN eines Tokens geändert werden soll, kann der Benutzer die PIN-"
"Änderung auch in einer Rückfrage während einer Authentifizierung mittels "
"validate/check durchführen."

#: lib/policy.py:2453
msgid ""
"The autoresync of a token can be done via a challenge response message.You "
"need to activate 'Automatic resync' in the general settings!"
msgstr ""
"Die automatische Resynchronisierung eines Tokens kann über eine Challenge-"
"Response-Nachricht erfolgen. In den allgemeinen Einstellungen muss die "
"'Automatische Resynchronisierung' aktiviert sein!"

#: lib/policy.py:2458
msgid ""
"In case of a successful authentication the following tokentype is enrolled. "
"The maximum number of tokens for a user is checked."
msgstr ""
"Im Falle einer erfolgreichen Authentisierung wird der folgende Tokentyp "
"ausgerollt. Die maximale Anzahl von Token für einen Benutzer wird überprüft."

#: lib/policy.py:2464
msgid "Change the default text that is shown during enrolling a token."
msgstr ""
"Der Text der beim Ausrollen des Tokens mittels Multi-Challenge dem Benutzer "
"angezeigt wird."

#: lib/policy.py:2469
msgid ""
"If set, the user in this realm will be authenticated against the userstore "
"or against the given RADIUS config, if the user has no tokens assigned."
msgstr ""
"Wenn einem Benutzer kein Token zugewiesen ist, werden sein Passwort gegen "
"die hier eingestellte RADIUS-Server-Konfiguration geprüft."

#: lib/policy.py:2476
msgid ""
"This allows to automatically assign a Token within privacyIDEA, if the user "
"was authenticated via passthru against a RADIUS server. The OTP value is "
"used to find the unassigned token in privacyIDEA. Enter the length of the "
"OTP value and where the PIN is set like 8:pin or pin:6."
msgstr ""
"Hier kann einem Benutzer automatisch ein Token zugewiesen werden, wenn er "
"sich erfolgreich gegen einen RADIUS Server authentisiert hat. Der OTP-Wert "
"wird benutzt, um einen nicht zugewiesenen Token in privacyIDEA zu finden. "
"Die PIN des neuen Tokens wird gesetzt. Geben Sie die Länge des OTP-Wertes an "
"und wo sich die PIN befindet. Bspw. 8:pin oder pin:6."

#: lib/policy.py:2483
msgid ""
"If the user has no token, the authentication request for this user will "
"always be true."
msgstr ""
"Wenn einem Benutzer kein Token zugewiesen ist, so wird eine "
"Authentifizierungsanfrage für diesen Benutzer immer positiv beantwortet."

#: lib/policy.py:2488
msgid ""
"If the user user does not exist, the authentication request for this non-"
"existing user will always be true."
msgstr ""
"Wenn der Benutzer nicht existiert, wird die Authentifizierungsanfrage immer "
"positiv beantwortet."

#: lib/policy.py:2494
msgid ""
"Can be used to modify the parameters pass, user and realm in an "
"authentication request. See the documentation for an example."
msgstr ""
"Hiermit können die Parameter pass, user und realm in einer "
"Authentifizierungsanfrage verändert werden. Bitte lesen Sie die "
"Dokumentation für mehr Details."

#: lib/policy.py:2500
msgid ""
"If a user authenticates successfully reset the failcounter of all of his "
"tokens."
msgstr ""
"Wenn sich ein Benutzer erfolgreich authentisiert hat, werden die "
"Fehlerzähler all seiner Token zurückgesetzt."

#: lib/policy.py:2505
msgid ""
"Increase the failcounter for all the tokens, for which a challenge has been "
"triggered."
msgstr ""
"Der Fehlerzähler aller Token, die eine Challenge ausgelöst haben, wird "
"inkrementiert."

#: lib/policy.py:2509
msgid ""
"Cache the password used for authentication and allow authentication with the "
"same credentials for a certain amount of time. Specify timeout like 4h or "
"4h/5m."
msgstr ""
"Das Passwort und den OTP-Wert einer erfolgreichen Anmeldung wird von "
"privacyIDEA gecacht. Somit kann für einen gewissen Zeitraum die Anmeldung "
"mit den gleichen Credentials erfolgen. Die Zeit wird angegeben als 4h or "
"4h/5m."

#: lib/policy.py:2516
msgid ""
"You can set the client modes in the order that you prefer. For example: "
"\"interactive webauthn poll u2f\". Accepted values are: <code>interactive "
"webauthn poll u2f</code>"
msgstr ""
"Sie können die Client-Modi in der von Ihnen bevorzugten Reihenfolge "
"festlegen. Zum Beispiel: \"interactive webauthn poll u2f\". Akzeptierte "
"Werte sind:<code>interactive webauthn poll u2f</code>"

#: lib/policy.py:2522
msgid ""
"When enabled, authentication attempts will be interpreted as either the PIN "
"or the answer to a challenge. PIN concatenated with OTP can not be used "
"anymore! Does only work when authenticating with a username."
msgstr ""
"Alle Token können nur noch im Challenge-Response Modus verwendet werden. "
"Eine Authentisierung mit PIN+OTP ist nicht mehr möglich. Gilt nur für "
"Authentisierungen mit Benutzernamen."

#: lib/policy.py:2530
msgid ""
"Allow the user to authenticate (default). If set to '{0!s}', the "
"authentication of the user will be denied."
msgstr ""
"Der Benutzer darf sich anmelden (Standardeinstellung). Wenn dies auf '{0!s}' "
"gesetzt ist, wird dem Benutzer die Authentifizierung verweigert."

#: lib/policy.py:2537
msgid ""
"Allow the application to choose which token types should be used for "
"authentication. Application may set the parameter 'type' in the request. "
"Works with validate/check, validate/samlcheck and validate/triggerchallenge."
msgstr ""
"Die Applikation, die den Authentifizierungsrequest an privacyIDEA sendet, "
"darf selber bestimmen, mit welchem Tokentyp die Authentifizierung erfolgen "
"soll. Hierzu sendet die Applikation den Parameter 'type' mit. Dies gilt für "
"validate/check, validate/samlcheck und validate/triggerchallenge."

#: lib/policy.py:2544
msgid ""
"You can specify how many successful authentication requests a user is "
"allowed to do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h "
"being second, minute and hour."
msgstr ""
"Sie können angeben, wie viele erfolgreiche Authentifizierungsanfragen ein "
"Benutzer in einer gewissen Zeitspanne durchführen darf. Geben Sie an 1/5s, "
"2/10m oder 10/1h - Dabei sind (s) Sekunden, (m) Minuten und (h) Stunden."

#: lib/policy.py:2552
msgid ""
"You can specify how many failed authentication requests a user is allowed to "
"do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h being second, "
"minute and hour."
msgstr ""
"Sie können angeben, wie viele fehlgeschlagene Authentifizierungsversuche ein "
"Benutzer in einer gewissen Zeit durchführen darf. Geben Sie bpsw. an 1/5s, "
"2/10m, 10/1h - (s) für Sekunden, (m) für Minuten und (h) für Stunden."

#: lib/policy.py:2560
msgid ""
"You can specify in which time frame the user needs to authenticate again "
"with this token. If the user authenticates later, authentication will fail. "
"Specify like 30h, 7d or 1y."
msgstr ""
"Sie können angeben, in welcher Zeit sich ein Benutzer erneut anmelden muss, "
"bzw. wie lang die letzte erfolgreiche Anmeldung zurückliegen darf. Ansonsten "
"wird der Anmeldeversuch fehlschlagen. Geben Sie bspw. an 30h, 7d oder 1y (1 "
"Jahr)."

#: lib/policy.py:2568
msgid "The user will only be authenticated with this very tokentype."
msgstr "Der Benutzer kann sich nur mit diesem Tokentyp authentisieren."

#: lib/policy.py:2575
msgid ""
"The user will only be authenticated if the serial number of the token "
"matches this regexp."
msgstr ""
"Der Benutzer kann sich nur mit einem Token anmelden, dessen Seriennummer auf "
"diesen regulären Ausdruck passt."

#: lib/policy.py:2581
msgid ""
"The user will only be authenticated if the tokeninfo field matches the "
"regexp (key/&lt;regexp&gt;/)."
msgstr ""
"Die Autorisierung des Benutzers ist nur erfolgreich, wenn das Token-Info "
"Feld <code>key</code> auf den regulären Ausdruck passt: (<code>key/<regexp>/"
"</code>)."

#: lib/policy.py:2588
msgid ""
"The Realm of the user is set to this very realm. This is important if the "
"user is not contained in the default realm and can not pass his realm."
msgstr ""
"Der Benutzerrealm wird auf diesen Realm gesetzt. Dies kann genutzt werden, "
"wenn die Benutzer nicht im Default-Realm sind und der Realm von der "
"Applikation nicht übergeben werden kann."

#: lib/policy.py:2595
msgid ""
"In case of successful authentication additional no detail information will "
"be returned."
msgstr ""
"Im Fall einer erfolgreichen Authentifizierung werden keine zusätzlichen "
"Detail-Informationen zurückgeliefert."

#: lib/policy.py:2601
msgid ""
"In case of failed authentication additional no detail information will be "
"returned."
msgstr ""
"Im Fall einer erfolglosen Authentifizierung werden keine zusätzlichen Detail-"
"Informationen zurückgeliefert."

#: lib/policy.py:2607
msgid ""
"In case of successful authentication user data will be added in the detail "
"branch of the authentication response."
msgstr ""
"Im Fall einer erfolgreichen Authentifizierung werden zusätzliche "
"Benutzerdaten zurückgeliefert."

#: lib/policy.py:2614
msgid ""
"In case of successful authentication the user resolver and realm will be "
"added in the detail branch of the authentication response."
msgstr ""
"Im Falle der erfolgreichen Authentifizierung wird der Resolver und der Realm "
"des Benutzers in der API Antwort mit zurückgeliefert."

#: lib/policy.py:2621
msgid ""
"The sending of an API Auth Key is required duringauthentication. This avoids "
"rogue authenticate requests against the /validate/check interface."
msgstr ""
"Die Nutzung eines API Auth Key für die Authentifizierung ist notwendig. Dies "
"verhindert unberechtigte Authentifizierungs-Versuche gegen das /validate/"
"check Interface."

#: lib/policy.py:2631
msgid ""
"If set, administrators will see a dashboard as start screen when logging in "
"to privacyIDEA WebUI."
msgstr ""
"Wenn dies gesetzt ist, bekommen Administratoren ein Dashboard im WebUI "
"angezeigt."

#: lib/policy.py:2636
msgid ""
"If set to \"privacyIDEA\" the users and admins need to authenticate against "
"privacyIDEA when they log in to the Web UI. Defaults to \"userstore\"."
msgstr ""
"Wenn dies auf \"privacyIDEA\" gesetzt wird, müssen sich Administratoren und "
"Benutzer gegen privacyIDEA authentisieren, wenn sie sich im WebUI einloggen "
"wollen. Standard: \"userstore\"."

#: lib/policy.py:2645
msgid ""
"An alternative text to display on the WebUI login dialog instead of \"Please "
"sign in\"."
msgstr "Ein alternativer Text bei der Anmeldung am privacyIDEA WebUI."

#: lib/policy.py:2649
msgid ""
"When searching in the user list, the search will only performed when "
"pressing enter."
msgstr ""
"Die Suche in der Benutzerliste erst nach Drücken der Entertaste ausführen."

#: lib/policy.py:2654
msgid ""
"The action taken when a user is idle beyond the logout_time limit. Defaults "
"to \"lockscreen\"."
msgstr ""
"Diese Aktion wird ausgeführt, wenn der Benutzer zu lange inaktiv ist. "
"Standard: \"lockscreen\"."

#: lib/policy.py:2662
msgid ""
"The REMOTE_USER set by the webserver can be used to login to privacyIDEA or "
"it will be ignored. Defaults to \"disable\"."
msgstr ""
"Der Webserver REMOTE_USER wird für die Anmeldung am WebUI verwendet. "
"Standard: \"disable\"."

#: lib/policy.py:2668
msgid ""
"Set the time in seconds after which the user will be logged out from the "
"WebUI. Default: 120"
msgstr ""
"Die Zeit in Sekunden, nach denen der Bennutzer aus dem WebUI abgemeldet "
"wird. Standard: 120"

#: lib/policy.py:2673
msgid ""
"privacyIDEA issues a JWT when the user or admins logs in to the WebUI. The "
"default validity is 1 hour. You can specify different validity times in "
"seconds."
msgstr ""
"privacyIDEA stellt einen JWT aus, wenn sich Benutzer und Admins im WebUI "
"anmelden. Hier können Sie die Gültigkeit des JWT in Sekuinden einstellen. "
"Der Standard ist 1 Stunde."

#: lib/policy.py:2678
msgid "Set how many tokens should be displayed in the token view on one page."
msgstr ""
"Anzahl der Tokens, die in der Tabelle auf der Tokenübersichtsseite angezeigt "
"werden."

#: lib/policy.py:2683
msgid "Set how many users should be displayed in the user view on one page."
msgstr ""
"Anzahl der Benutzer, die in der Tabelle auf der Tokenübersichtsseite "
"angezeigt werden."

#: lib/policy.py:2688
msgid ""
"Set how many audit entries should be displayed in the audit view on one page."
msgstr ""
"Anzahl der Audit-Enträge, die in der Tabelle auf der Audit-Seite angezeigt "
"werden."

#: lib/policy.py:2693
msgid "Use your own html template for the web UI menu."
msgstr "Eine eigene HTML-Vorlage für das Menü im Web UI verwenden."

#: lib/policy.py:2697
msgid "Use your own html template for the web UI baseline/footer."
msgstr "Eine eigene HTML-Vorlage für die Fußzeile im Web UI verwenden."

#: lib/policy.py:2701
msgid "Link your privacy statement to be displayed in the baseline/footer."
msgstr ""
"Ein Link zur Datenschutzerklärung, der im Footer der Webseite angezeigt wird."

#: lib/policy.py:2705
msgid ""
"Whether the user ID and the resolver should be displayed in the token list."
msgstr "Die Benutzer ID und den Benutzer-Resolver in der Tokenliste anzeigen."

#: lib/policy.py:2710
msgid ""
"The URL of a repository, where the policy templates can be found.  (Default "
"https: //raw.githubusercontent.com/ privacyidea/policy-templates /master/"
"templates/)"
msgstr ""
"Die URL der Policy-Templates. (Default https: //raw.githubusercontent.com/ "
"privacyidea/policy-templates /master/templates/)"

#: lib/policy.py:2717
msgid ""
"The URL of an SSO provider for redirect at logout.(The URL must start with "
"http:// or https://)"
msgstr ""
"Die URL eines SSO-Anbieters für die Weiterleitung beim Abmelden. (Die URL "
"muss mit http:// oder https:// beginnen.)"

#: lib/policy.py:2722
msgid ""
"As long as a user has no token, he will only see a token wizard in the UI."
msgstr "Einem Benutzer ohne Token wird automatisch der Token Wizard angezeigt."

#: lib/policy.py:2727
msgid ""
"The tokenwizard will be displayed in the token menu, even if the user "
"already has a token."
msgstr ""
"Der Token Wizard als Menüpunkt angeboten - auch wenn der Benutzer bereits "
"einen Token hat."

#: lib/policy.py:2732
msgid ""
"This is a whitespace separated list of tokentypes, for which a rollover "
"button is displayed in the token details."
msgstr ""
"Dies ist eine mit Leerzeichen getrennte Liste an Tokentypen, für die das "
"Rollover im WebUI erlaubt ist."

#: lib/policy.py:2739
msgid ""
"The welcome dialog will be displayed if the user has no tokens assigned."
msgstr ""
"Wenn dem Benutzer kein Token zugewiesen ist, wird der Willkommensdialog "
"angezeigt."

#: lib/policy.py:2743
msgid "This is the default token type in the token enrollment dialog."
msgstr "Die Voreinstellung des Tokentyps im Rollout-Dialog."

#: lib/policy.py:2749
msgid ""
"A list of realm names, which are displayed in a drop down menu in the WebUI "
"login screen. Realms are separated by white spaces."
msgstr ""
"Eine durch Leerzeichen getrennte Liste von Realmnamen, die in einer "
"Auswahlliste beim Login in das Webinterface angezeigt werden."

#: lib/policy.py:2755
msgid ""
"If this checked, the administrator will not see the welcome dialog anymore."
msgstr "Dem Administrator wird der Willkommen-Dialog nicht mehr angezeigt."

#: lib/policy.py:2760
msgid ""
"Per default disabled actions result in disabled buttons. When checking this "
"action, buttons of disabled actions are hidden."
msgstr ""
"Buttons von Funktionen, die ein Benutzer nicht ausführen darf, werden "
"ausgeblendet (Das Standardverhalten ist, dass die Buttons deaktiviert "
"werden)."

#: lib/policy.py:2765
msgid ""
"If this is checked, there will be a confirmation prompt when deleting "
"policies, events, mresolver, resolver or periodic tasks!"
msgstr ""
"Wenn diese Aktion aktiviert ist, wird beim Löschen von Richtlinien, "
"Ereignissen, Regelmäßigen Aufgaben oder (Maschinen-)Resolvern ein "
"Bestätigungsdialog angezeigt!"

#: lib/policy.py:2770
msgid ""
"If this is checked, the seed will be displayed as text during enrollment."
msgstr ""
"Wenn dies angehakt ist, wird das Seed während des Rollouts als Text "
"angezeigt."

#: lib/policy.py:2775
msgid ""
"If this is checked, the privacyIDEA Node name will be displayed in the menu "
"bar."
msgstr ""
"Wenn dies angehakt ist, wird der Name des privacyIDEA Knotens in der "
"Menüzeile angezeigt."

#: lib/policy.py:2780
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the Google "
"Play Store."
msgstr ""
"Wenn diese Richtlinie gesetzt ist, dann wird in dem Ausroll-Dialog für HOTP, "
"TOTP und Push Token ein QR-Code angezeigt, der zum privacyIDEA Authenticator "
"im Google Play Store führt."

#: lib/policy.py:2787
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the iOS App "
"Store."
msgstr ""
"Wenn diese Richtlinie gesetzt ist, dann wird in dem Ausroll-Dialog für HOTP, "
"TOTP und Push Token ein QR-Code angezeigt, der zum privacyIDEA Authenticator "
"im IOS App Store führt."

#: lib/policy.py:2794
msgid ""
"This action adds a QR code in the enrollment page for HOTP, TOTP and Push "
"tokens, that lead to this given URL."
msgstr ""
"Wenn diese Richtlinie gesetzt ist, dann wird in dem Ausroll-Dialog für HOTP, "
"TOTP und Push Token ein QR-Code angezeigt, der zu der angegebenen URL führt."

#: lib/policy.py:2838
msgid ""
"The policy only matches if certain conditions on the user info are fulfilled."
msgstr ""
"Die Richtlinie greift, wenn zusätzliche Anforderungen an die "
"Benutzerattribute erfüllt sind."

#: lib/policy.py:2841
msgid ""
"The policy only matches if certain conditions of the token attributes are "
"fulfilled."
msgstr ""
"Die Richtlinie greift, wenn die Bedingung für das Token-Attribut erfüllt ist."

#: lib/policy.py:2844
msgid ""
"The policy only matches if certain conditions on the token info are "
"fulfilled."
msgstr ""
"Die Richtlinie greift, wenn zusätzliche Anforderungen an die Token "
"Infoattribute erfüllt sind."

#: lib/policy.py:2847
msgid ""
"The policy only matches if certain conditions on the HTTP Request header are "
"fulfilled."
msgstr ""
"Die Richtlinie greift nur, wenn bestimmte Anforderungen an die HTTP-Request "
"Header erfüllt sind."

#: lib/policy.py:2850
msgid ""
"The policy only matches if certain conditions on the HTTP Environment are "
"fulfilled."
msgstr ""
"Die Richtlinie greift, wenn zusätzliche Anforderungen an HTTP "
"Umgebungsvariablen erfüllt sind."

#: lib/radiusserver.py:223 lib/radiusserver.py:255
msgid "The RADIUS secret is too long"
msgstr "Das RADIUS Secret ist zu lang"

#: lib/subscriptions.py:43
msgid "My subscription has expired."
msgstr "Meine Subskription ist abgelaufen."

#: lib/token.py:159
msgid "create_tokenclass_object failed:  {0!r}"
msgstr "create_tokenclass_object fehlgeschlagen: {0!r}"

#: lib/token.py:325
msgid "I can only create SQL filters from tokeninfo of length 1."
msgstr "Es können nur SQL-Filter aus einem Tokeninfo Eintrag erstellt werden."

#: lib/token.py:718
msgid "The requested token could not be found."
msgstr "Der gesuchte Token wurde nicht gefunden."

#: lib/token.py:723
msgid "More than one matching token was found."
msgstr "Es wurde mehr als ein passender Token gefunden."

#: lib/token.py:1035
msgid "multiple tokens are matching this OTP value!"
msgstr "Dieser OTP-Wert passt zu mehreren Token!"

#: lib/token.py:1195
msgid "init token failed: unknown token type {0!r}"
msgstr "init_token fehlgeschlagen: unbekannter Token-Typ {0!r}"

#: lib/token.py:1216
msgid "initToken failed: {0!s}"
msgstr "init_token fehlgeschlagen: {0!s}"

#: lib/token.py:1376
msgid "Token already assigned to user {0!r}"
msgstr "Der Token wurde schon dem Benutzer {0!r} zugewiesen"

#: lib/token.py:1390
msgid "Token assign failed for {0!r}/{1!s} : {2!r}"
msgstr "Tokenzuweisung fehlgeschlagen für {0!r}/{1!s} : {2!r}"

#: lib/token.py:1418
msgid "Token unassign failed for {0!r}/{1!r}: {2!r}"
msgstr "Fehler beim Aufheben der Tokenzuweisung für {0!r}/{1!r}: {2!r}"

#: lib/token.py:1494
msgid "Parameter user must not be a string: {0!r}"
msgstr "Parameter \"user\" darf kein String sein: {0!r}"

#: lib/token.py:2047
msgid "You can only define a lost token for an assigned token."
msgstr ""
"Sie können einen verlorenen Token nur für einen zugewiesenen Token "
"definieren."

#: lib/token.py:2073
msgid "temporary replacement for {0!s}"
msgstr "vorübergehender Ersatz für Token {0!s}"

#: lib/token.py:2129
msgid "There is no active and assigned token in this realm"
msgstr "Es gibt keinen aktiven und zugewiesenen Token in diesem Realm"

#: lib/token.py:2141
msgid ""
"There is no active and assigned token in this realm, included types: {0!s}, "
"excluded types: {1!s}"
msgstr ""
"Es gibt keinen aktiven und zugeordneten Token in diesem Realm, enthaltene "
"Typen: {0!s}, ausgeschlossene Typen: {1!s}"

#: lib/token.py:2194
msgid "OTP verification failed."
msgstr "OTP-Überprüfung fehlgeschlagen."

#: lib/token.py:2228
msgid "The user has no tokens assigned"
msgstr "Dem Benutzer sind keine Token zugewiesen"

#: lib/token.py:2443
msgid "matching {0:d} tokens"
msgstr "{0:d} passende Token"

#: lib/token.py:2495
msgid "Challenge matches, but token is not fit for challenge"
msgstr ""
"Challenge stimmt überein aber der Token ist nicht für Challenge-Response "
"geeignet"

#: lib/token.py:2505
msgid "Found matching challenge"
msgstr "Passende Challenge gefunden"

#: lib/token.py:2547
msgid "Response did not match the challenge."
msgstr "Die Antwort passt nicht zur Challenge."

#: lib/token.py:2549
msgid "Response did not match for {0!s} tokens."
msgstr "Die Antwort stimmte für {0!s} Token nicht überein."

#: lib/token.py:2557
msgid "No active challenge response token found"
msgstr "Kein aktiver Challenge-Response Token gefunden"

#: lib/token.py:2573
msgid "wrong otp value"
msgstr "falscher OTP-Wert"

#: lib/token.py:2580
msgid ". previous otp used again"
msgstr "früherer OTP-Wert wieder verwendet"

#: lib/token.py:2594
msgid "wrong otp pin"
msgstr "falsche OTP-Pin"

#: lib/token.py:2602
msgid "No suitable token found for authentication."
msgstr "Kein passender Token für die Authentifizierung gefunden."

#: lib/token.py:2627
msgid "Admin is allowed to initialize {0!s} tokens."
msgstr "Der Administrator kann {0!s} Token ausrollen."

#: lib/token.py:2635
msgid "The user is allowed to enroll a {0!s} token."
msgstr "Der Benutzer darf einen {0!s} Token ausrollen."

#: lib/token.py:2666
msgid "Set the maximum allowed PIN length of the {0!s} token."
msgstr "Setze die maximal erlaubte PIN-Länge für den {0!s} Token."

#: lib/token.py:2673
msgid "Set the minimum required PIN length of the {0!s} token."
msgstr "Sete die minimal notwendite PIN-Länge für den {0!s} Token."

#: lib/token.py:2679
msgid ""
"Specifiy the required PIN contents of the {0!s} token. (c)haracters, "
"(n)umeric, (s)pecial, (o)thers. [+/-]!"
msgstr ""
"Definiere den notwendigen Inhalte der OTP PIN für den {0!s} Token. (c) "
"Buchstaben, (n) Ziffern, (s) Sonderzeichen, (o) Andere [+/-]!"

#: lib/token.py:2724 lib/token.py:2740
msgid "The tokengroup does not exist."
msgstr "Die Token-Gruppe existiert nicht."

#: lib/tokenclass.py:1691
msgid "please enter otp: "
msgstr "Bitte geben Sie einen OTP-Wert ein: "

#: lib/applications/ssh.py:105
msgid "The username on the SSH server."
msgstr "Der Benutzername auf dem SSH-Server."

#: lib/applications/ssh.py:107
msgid ""
"The service ID of the SSH server. Several servers can have the same service "
"ID."
msgstr ""
"Die Dienste-Kennzeichnung des SSH-Servers. Unterschiedliche SSH-Server "
"können die selbe Dienste-Kennzeichnung haben."

#: lib/eventhandler/base.py:169
msgid ""
"The challenge session matches the string or regular expression (like "
"'challenge_declined' or 'enrollment')"
msgstr ""
"Daten aus der Challenge stimmen mit dem string oder der regular expression "
"überein, wie 'challenge_declined' oder 'enrollment'"

#: lib/eventhandler/base.py:176
msgid "The challenge of a token during the authentication process is expired."
msgstr "Die Challenge des Tokens ist während der Authentifizierung abgelaufen."

#: lib/eventhandler/base.py:184
msgid ""
"The rollout_state of the token has a certain value like 'clientwait' or "
"'enrolled'."
msgstr ""
"Das Attribut \"rollout_state\" des Tokens hat einen bestimmten Wert wie "
"'clientwait' oder 'enrolled'."

#: lib/eventhandler/base.py:190
msgid "The realm of the user, for which this event should apply."
msgstr "Der Realm des Benutzers, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:197
msgid "The resolver of the user, for which this event should apply."
msgstr "Der Resolver des Benutzers, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:204
msgid "The realm of the token, for which this event should apply."
msgstr "Der Realm des Tokens, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:212
msgid "The resolver of the token, for which this event should apply."
msgstr "Der Resolver des Tokens, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:220
msgid "The type of the token."
msgstr "Der Tokentyp."

#: lib/eventhandler/base.py:227
msgid "The logged in user is of the following type."
msgstr "Der angemeldete Benutzer ist vom Typ."

#: lib/eventhandler/base.py:234
msgid "The result.value within the response is True or False."
msgstr "Das result.value in der Server-Antwort ist 'True' oder 'False'."

#: lib/eventhandler/base.py:242
msgid "The result.status within the response is True or False."
msgstr ""
"Der Wert von result.status der Antwort ist entweder \"True\" oder \"False\"."

#: lib/eventhandler/base.py:250
msgid "The result.authentication within the response is the given value."
msgstr ""
"Das Attribut result.authentication in der Server-Antwort entspricht dem "
"angegebenen Wert."

#: lib/eventhandler/base.py:258
msgid "Check if the max failcounter of the token is reached."
msgstr "Der maximale Fehlerzähler des Tokens wurde erreicht."

#: lib/eventhandler/base.py:266
msgid "The token has a user assigned."
msgstr "Der Token ist einem Benutzer zugewiesen."

#: lib/eventhandler/base.py:273
msgid ""
"The token has a user assigned, but the user does not exist in the userstore "
"anymore."
msgstr ""
"Dem Token ist ein Benutzer zugewiesen, aber dieser Benutzer existiert nicht "
"mehr in der Benutzerquelle."

#: lib/eventhandler/base.py:281
msgid "Check if the token is within its validity period."
msgstr "Überprüfe, ob der Token innerhalb des Gültigkeitszeitraums liegt."

#: lib/eventhandler/base.py:288
msgid "Action is triggered, if the serial matches this regular expression."
msgstr ""
"Die Aktion wird ausgeführt, wenn die Seriennummer auf den regulären Ausdruck "
"passt."

#: lib/eventhandler/base.py:295
msgid "The token is in a container."
msgstr "Der Token ist in einem Container."

#: lib/eventhandler/base.py:302
msgid "Action is triggered, if the user has this number of tokens assigned."
msgstr ""
"Die Aktion wird ausgeführt, wenn der Benutzer diese Anzahl an Tokens besitzt."

#: lib/eventhandler/base.py:309
msgid ""
"Action is triggered, if the user has this number of containers assigned."
msgstr ""
"Die Aktion wird ausgeführt, wenn der Benutzer diese Anzahl an Containern "
"besitzt."

#: lib/eventhandler/base.py:316
msgid ""
"Action is triggered, if the counter of the token equals this setting. Can "
"also be '>100' or '<99' for no exact match."
msgstr ""
"Die Aktion wird ausgelöst, wenn der OTP Zähler dem angegebenen Wert "
"entspricht. Die Bedingung kann auch größer '>100' oder kleiner '<99' als ein "
"definierter Grenzwert sein."

#: lib/eventhandler/base.py:324
msgid ""
"Action is triggered, if the last authentication of the token is older than "
"7h, 10d or 1y."
msgstr ""
"Die Aktion wird ausgeführt, wenn die letzte Authentisierung mit diesem Token "
"länger als 7 Stunden, 10 Tage oder 1 Jahr (7h, 10d, 1y) zurückliegt."

#: lib/eventhandler/base.py:331
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth' is bigger than 100, less than 99 or exactly 100."
msgstr ""
"Dies kann '>100', '<99' oder '=100' sein, um eine Aktion auszulösen. Das "
"Feld 'count_auth' in Tokeninfo ist dann größer als 100, kleiner als 99 oder "
"exakt 100."

#: lib/eventhandler/base.py:339
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth_success' is bigger than 100, less than 99 or "
"exactly 100."
msgstr ""
"Dies kann '>100', '<99' oder '=100' sein, um eine Aktion auszulösen. Das "
"Feld 'count_auth_success' in Tokeninfo ist dann größer als 100, kleiner als "
"99 oder exakt 100."

#: lib/eventhandler/base.py:348
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"difference between the tokeninfo field 'count_auth' and 'count_auth_success "
"is bigger than 100, less than 99 or exactly 100."
msgstr ""
"Dies kann '>100', '<99' oder '=100' sein, um eine Aktion auszulösen. Das "
"Feld 'count_auth' und 'count_auth_success' in Tokeninfo ist dann größer als "
"100, kleiner als 99 oder exakt 100."

#: lib/eventhandler/base.py:357
msgid ""
"This can be '>9', '<9', or '=10', to trigger the action, if the failcounter "
"of a token matches this value. Note that the failcounter stops increasing, "
"if the max_failcount is reached."
msgstr ""
"Hier können Bedingung wie '>9', '<9' oder '=10' eingetragen werden, um eine "
"Aktion auszulösen, wenn der Failcounter des Tokens einen entsprechenden Wert "
"hat. Bitte beachten Sie, dass der Failcounter nicht mehr erhöht wird, sobald "
"er den Maximalwert erreicht hat."

#: lib/eventhandler/base.py:366
msgid ""
"This condition can check any arbitrary tokeninfo field. You need to enter "
"something like '<fieldname> == <fieldvalue>', '<fieldname> > <fieldvalue>' "
"or '<fieldname> < <fieldvalue>'."
msgstr ""
"Diese Bedingung prüft beliebige Werte in der Tokeninfo. Zulässige Vergleiche "
"sind: '<Feldname> == <Feldinhalt>', '<Feldname> > <Feldinhalt>' oder "
"'<Feldname> < <Feldinhalt>'."

#: lib/eventhandler/base.py:375
msgid ""
"This condition can check the value of an arbitrary event counter and compare "
"it like 'myCounter == 1000', 'myCounter > 1000' or 'myCounter < 1000'."
msgstr ""
"Diese Bedingung überprüft einen beliebigen Eventcounter und vergleicht in "
"bspw. wie 'myCounter == 1000', 'myCounter > 1000' oder 'myCounter < 1000'."

#: lib/eventhandler/base.py:383
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->error->message in the response."
msgstr ""
"Hier können Sie einen regulären Ausdruck eingeben. Die Bedingung greift nur, "
"wenn der reguläre Ausdruck auf das Feld detail->error->message im HTTP "
"Response passt."

#: lib/eventhandler/base.py:391
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->message in the response."
msgstr ""
"Hier können Sie einen regulären Ausdruck eingeben. Die Bedingung greift nur, "
"wenn der reguläre Ausdruck auf das Feld detail->message im HTTP Response "
"passt."

#: lib/eventhandler/base.py:399
msgid "Trigger the action, if the client IP matches."
msgstr "Die Aktion wird ausgeführt, wenn die Client IP passt."

#: lib/eventhandler/base.py:405
msgid ""
"The container is in the specified states, but can additionally be in other "
"states."
msgstr ""
"Der Container hat den angegebenen Status, kann jedoch zusätzlich weitere "
"haben."

#: lib/eventhandler/base.py:412
msgid "The container is only in the specified states."
msgstr "Der Container hat nur die angegebenen Status und keine weiteren."

#: lib/eventhandler/base.py:419
msgid "The container has a user assigned."
msgstr "Der Container ist einem Benutzer zugewiesen."

#: lib/eventhandler/base.py:426
msgid "The container has at least one token assigned."
msgstr "In dem Container ist mindestens ein Token enthalten."

#: lib/eventhandler/base.py:433
msgid "The container is of a certain type."
msgstr "Der Container ist von diesem Typ."

#: lib/eventhandler/containerhandler.py:93
msgid "Container type to create"
msgstr "Typ des Containers, der erstellt werden soll"

#: lib/eventhandler/containerhandler.py:99
#: lib/eventhandler/containerhandler.py:121
msgid "Description of the container"
msgstr "Beschreibung des Containers"

#: lib/eventhandler/containerhandler.py:104
msgid "Assign container to user in request or to token/container owner"
msgstr ""
"Container dem Benutzer aus dem Request oder dem Token-/Containerbesitzer "
"zuweisen."

#: lib/eventhandler/containerhandler.py:109
msgid "Add token from request to container"
msgstr "Token aus dem Request zum Container hinzufügen."

#: lib/eventhandler/containerhandler.py:129
msgid "Set this container info key (deletes all existing keys)."
msgstr ""
"Setzt einen Wert für dieses Schlüsselwort in der Container Info (löscht alle "
"bereits existierenden Schlüsselwörter)."

#: lib/eventhandler/containerhandler.py:133
#: lib/eventhandler/containerhandler.py:143
msgid "Set the value for the key above."
msgstr "Setze den Wert für das oben angegebene Schlüsselwort."

#: lib/eventhandler/containerhandler.py:139
msgid "Add this key to the container info."
msgstr "Fügt dieses Schlüsselwort zu der Container Info hinzu."

#: lib/eventhandler/counterhandler.py:67 lib/eventhandler/counterhandler.py:72
#: lib/eventhandler/counterhandler.py:80
msgid "The identifier/key of the counter."
msgstr "Die ID des Zählers."

#: lib/eventhandler/counterhandler.py:75
msgid "Don't stop counter if it reaches zero."
msgstr "Der Counter darf auch negative Werte erreichen."

#: lib/eventhandler/customuserattributeshandler.py:61
msgid "The user for whom the custom attribute should be set."
msgstr "Der Benutzer, für den das Attribut gesetzt werden soll."

#: lib/eventhandler/customuserattributeshandler.py:68
msgid "The key of the custom user attribute that should be set."
msgstr "Der Schlüssel des Attributes, das gesetzt werden soll."

#: lib/eventhandler/customuserattributeshandler.py:71
msgid "The value of the custom user attribute."
msgstr "Wert des benutzerdefinierten Benutzerattributs."

#: lib/eventhandler/customuserattributeshandler.py:77
msgid "The user from which the custom attribute should be deleted."
msgstr "Der Benutzer, dessen Attribut gelöscht werden soll."

#: lib/eventhandler/customuserattributeshandler.py:84
msgid "The key of the custom user attribute that should be deleted."
msgstr "Der Schlüssel des Attributes, das gelöscht werden soll."

#: lib/eventhandler/federationhandler.py:74
msgid "The remote/child privacyIDEA Server."
msgstr "Der entfernte privacyIDEA Server."

#: lib/eventhandler/federationhandler.py:79
msgid "Change the realm name to a realm on the child privacyIDEA system."
msgstr ""
"Der Realmname wird auf diesen Realmnamen auf dem entfernenten privacyIDEA "
"Server geändert."

#: lib/eventhandler/federationhandler.py:85
msgid "Change the resolver name to a resolver on the child privacyIDEA system."
msgstr ""
"Der Resolvername wird auf diesen Resolvernamen auf dem entfernten "
"privacyIDEA Server geändert."

#: lib/eventhandler/federationhandler.py:91
msgid ""
"Forward the client IP to the child privacyIDEA server. Otherwise this server "
"will be the client."
msgstr ""
"Die Client-IP wird an den entfernten privacyIDEA Server durchgereicht. "
"Ansonsten ist der lokale privacyIDEA Server der Client für den entfernten "
"Server."

#: lib/eventhandler/federationhandler.py:98
msgid ""
"Forward the authorization header. This allows to also forward request like "
"token- and system-requests."
msgstr ""
"Den HTML-Authorisierungsheader weiterleiten. So können bspw. auch Token- und "
"System-Requests weitergeleitet werden."

#: lib/eventhandler/logginghandler.py:85
msgid "The name of the logging facility"
msgstr "Der Name des Logging-Bereichs"

#: lib/eventhandler/logginghandler.py:91
msgid "The string to write to the log"
msgstr "Die Zeichenkette, die ins Log geschrieben werden soll"

#: lib/eventhandler/logginghandler.py:97
msgid "The logging level for this logging notification"
msgstr "Der Loglevel der Log-Benachrichtigung"

#: lib/eventhandler/requestmangler.py:98
msgid "The parameter that should be deleted."
msgstr "Der Parameter der gelöscht werden soll."

#: lib/eventhandler/requestmangler.py:104
msgid "The parameter that should be added or modified."
msgstr "Der Parameter der hinzugefügt oder verändert werden soll."

#: lib/eventhandler/requestmangler.py:109
msgid ""
"The new value of the parameter. Can contain tags like {0}, {1} for the "
"matched sub strings."
msgstr ""
"Der neue Wert des Parameters. Er kann Tags wie '{0}' oder '{1}' enthalten "
"entsprechend der passenden Teil-Zeichenfolge."

#: lib/eventhandler/requestmangler.py:114
msgid "The parameter, that should match some values."
msgstr "Der Parameter der mit einem Wert übereinstimmen soll."

#: lib/eventhandler/requestmangler.py:118
msgid ""
"The value of the match_parameter. It can contain a regular expression and "
"'()' to transfer values to the new parameter."
msgstr ""
"Der Wert von 'match_parameter'. Er kann einen regulären Ausdruck und '()' "
"enthalten um Werte auf den neuen Parameter zu übertragen."

#: lib/eventhandler/responsemangler.py:79
msgid ""
"The JSON pointer (key) that should be deleted. Please specify in the format "
"'/detail/message'."
msgstr ""
"Der JSON-Verweis (Schlüssel) welcher gelöscht werden soll. Bitte im Format '/"
"details/message' angeben."

#: lib/eventhandler/responsemangler.py:86
msgid ""
"The JSON pointer (key) that should be set. Please specify in the format '/"
"detail/message'."
msgstr ""
"Der JSON-Verweis (Schlüssel) welcher gesetzt werden soll. Bitte im Format '/"
"details/message' angeben."

#: lib/eventhandler/responsemangler.py:92
msgid "The type of the value."
msgstr "Der Typ des Wertes."

#: lib/eventhandler/responsemangler.py:98
msgid "The value of the JSON key that should be set."
msgstr "Wert des JSON Schlüssels, welcher gesetzt werden soll."

#: lib/eventhandler/scripthandler.py:94
#: lib/smsprovider/ScriptSMSProvider.py:121
msgid ""
"Wait for script to complete or run script in background. This will either "
"return the HTTP request early or could also block the request."
msgstr ""
"Auf das Ende des Skripts warten oder das Skript im Hintergrund ausführen. "
"Somit wird die HTTP-Antwort entweder direkt zurückgegeben oder das Skript "
"kann einen HTTP-Aufruf blockieren."

#: lib/eventhandler/scripthandler.py:102
msgid "On script error raise exception in HTTP request."
msgstr "Wenn das Skript einen Fehler hat, soll ein HTTP-Fehler erzeugt werden."

#: lib/eventhandler/scripthandler.py:106
msgid ""
"Finish current transaction before running the script. This is useful if "
"changes to the database should be made available to the script or the "
"running request."
msgstr ""
"Die aktuelle Datenbank-Transaktion wird beendet, bevor das Skript aufgerufen "
"wird. Dies kann notwendig sein, wenn Änderungen in der Datenbank dem Skript "
"oder dem Request verfügbar gemacht werden sollen."

#: lib/eventhandler/scripthandler.py:113
msgid "Add '--serial <serial number>' as script parameter."
msgstr "Nutze '--serial <serial number>' als Skript-Parameter."

#: lib/eventhandler/scripthandler.py:118
msgid "Add '--user <username>' as script parameter."
msgstr "Nutze '--user <username>' als Skript-Parameter."

#: lib/eventhandler/scripthandler.py:123
msgid "Add '--realm <realm>' as script parameter."
msgstr "Nutze '--realm <realm>' als Skript-Parameter."

#: lib/eventhandler/scripthandler.py:128
msgid ""
"Add the username of the logged in user as script parameter like '--"
"logged_in_user <username>'."
msgstr ""
"Nutze den Benutzernamen des angemeldeten Benutzers als Skript-Parameter '--"
"logged_in_user <username>'."

#: lib/eventhandler/scripthandler.py:134
msgid ""
"Add the role (either admin or user) of the logged in user as script "
"parameter like '--logged_in_role <role>'."
msgstr ""
"Nutze die Rolle des angemeldeten Benutzers als Skript-Parameter '--"
"logged_in_role <role>'."

#: lib/eventhandler/tokenhandler.py:144
msgid "set a new realm of the token"
msgstr "Setze einen neuen Token-Realm"

#: lib/eventhandler/tokenhandler.py:150
msgid ""
"The new realm will be the only realm of the token. I.e. all other realms "
"will be removed from this token. If disabled, the realm will be added to the "
"token."
msgstr ""
"Der neue Realm ist der einzige Realm des Tokens. D.h. alle anderen evtl. "
"zugeordneten Realms dieses Tokens werden gelöscht. Ist diese Option "
"deaktiviert, wird der Realm zu den vorhandenen Realms des Tokens hinzugefügt."

#: lib/eventhandler/tokenhandler.py:167
msgid "set the PIN of the token to a random PIN of this length."
msgstr "Setze die PIN des Tokens auf einen zufälligen Wert dieser Länge."

#: lib/eventhandler/tokenhandler.py:177
msgid "Token type to create"
msgstr "Tokentyp der angelegt werden soll"

#: lib/eventhandler/tokenhandler.py:183
msgid "Assign token to user in request or to tokenowner."
msgstr "Token dem Benutzer aus dem Request oder dem Tokenbesitzer zuweisen."

#: lib/eventhandler/tokenhandler.py:190
msgid "Set the realm of the newly created token."
msgstr "Realm des neu angelegten Tokens."

#: lib/eventhandler/tokenhandler.py:199
msgid "Dynamically read the mobile number from the user store."
msgstr "Die Mobil-Nummer wird dynamisch aus dem Benutzerverzeichnis gelesen."

#: lib/eventhandler/tokenhandler.py:207
msgid "Dynamically read the email address from the user store."
msgstr "Die Email-Adresse wird dynamisch aus dem Benutzerverzeichnis gelesen."

#: lib/eventhandler/tokenhandler.py:215
msgid "Use a specific SMTP server configuration for this token."
msgstr "Benutze eine spezifische SMTP Server Konfiguration für diesen Token."

#: lib/eventhandler/tokenhandler.py:223
msgid "Use a specific SMS gateway configuration for this token."
msgstr "Benutze eine spezifische SMS Gateway Konfiguration für diesen Token."

#: lib/eventhandler/tokenhandler.py:229
msgid "A dictionary of additional init parameters."
msgstr "Zusätzliche Parameter zum Ausrollen des Tokens."

#: lib/eventhandler/tokenhandler.py:236
msgid ""
"Set the MOTP PIN of the MOTP token during enrollment. This is a required "
"value for enrolling MOTP tokens."
msgstr ""
"Setze die MOTP PIN während des Rollout-Prozesses. MOTP Token benötigen eine "
"MOTP PIN."

#: lib/eventhandler/tokenhandler.py:243
msgid ""
"Add the token to the container if there is one identifiable in the request."
msgstr ""
"Fügt den Token zu dem Container aus dem Request hinzu, sofern einer "
"vorhanden ist."

#: lib/eventhandler/tokenhandler.py:252
msgid "The new description of the token."
msgstr "Die neue Beschreibung des Tokens."

#: lib/eventhandler/tokenhandler.py:261
msgid ""
"The token will be valid starting at the given date. Can be a fixed date or "
"an offset like +10m, +24h, +7d."
msgstr ""
"Der Token ist ab dem angegebenen Datum gültig. Dies kann ein fixes Datum "
"oder eine Differenz wie +10m, +24h, +7d (10 Minuten, 24 Stunden, 7 Tage) "
"sein."

#: lib/eventhandler/tokenhandler.py:269
msgid ""
"The token will be valid until the given date. Can be a fixed date or an "
"offset like +10m, +24h, +7d."
msgstr ""
"Der Token wird bis zu dem angegebenen Datum gültig sein. Dies kann ein fixes "
"Datum oder eine Differenz wie +10m, +24h, +7d sein (10 Minuten, 24 Stunden, "
"7 Tage)."

#: lib/eventhandler/tokenhandler.py:283
msgid "Set the new count window of the token."
msgstr "Das neue Zähler-Fenster des Tokens setzen."

#: lib/eventhandler/tokenhandler.py:293
msgid "Set the failcounter of the token."
msgstr "Setze den Fehlerzähler des Tokens."

#: lib/eventhandler/tokenhandler.py:303
msgid ""
"Increase or decrease the fail counter of the token. Values of +n, -n with n "
"being an integer are accepted."
msgstr ""
"Der Fehlerzähler wird inkrementiert oder dekrementiert. Werte +n und -n, "
"wobei n eine Zahl ist, werden akzeptiert."

#: lib/eventhandler/tokenhandler.py:313
msgid "Set the maximum failcounter of the token."
msgstr "Setze den maximalen Fehlerzähler des Tokens."

#: lib/eventhandler/tokenhandler.py:322
msgid "Set this tokeninfo key."
msgstr "Setze diesen Schlüssel in der Tokeninfo-Tabelle."

#: lib/eventhandler/tokenhandler.py:327
msgid "Set the above key to this value."
msgstr "Setze den oben genannten Schlüssel auf diesen Wert."

#: lib/eventhandler/tokenhandler.py:337
msgid ""
"Interpret the tokeninfo as 'int' and increase the tokeninfo value by the "
"given offset."
msgstr ""
"Interpretiere die angegebene Tokeninfo als Zahl und erhöhe sie um einen Wert."

#: lib/eventhandler/tokenhandler.py:343
msgid ""
"The increment the tokeninfo key should be increased. Can be positive or "
"negative, s.th. like +1 or -7."
msgstr ""
"Der Wert um welche die Tokeninfo erhöht werden soll. Kann ein positive oder "
"negative Zahl sein, bspw. +1 oder -7."

#: lib/eventhandler/tokenhandler.py:353
msgid "Delete this tokeninfo key."
msgstr "Diesen Tokeninfo-Eintrag löschen."

#: lib/eventhandler/tokenhandler.py:362
msgid "Add a tokengroup to the token."
msgstr "Füge dem Token eine Token-Gruppe hinzu."

#: lib/eventhandler/tokenhandler.py:372
msgid "Remove a tokengroup from the token."
msgstr "Entferne eine Token-Gruppe vom Token."

#: lib/eventhandler/tokenhandler.py:382
msgid "The ID of the machine you want to attach the token to"
msgstr ""
"Die Kennzeichnung der Maschine an die dieser Token angehängt werden soll"

#: lib/eventhandler/tokenhandler.py:389
msgid "Set the service_id for an SSH application."
msgstr "Legen Sie die Dienste-Kennzeichnung für eine SSH-Anwendung fest."

#: lib/eventhandler/tokenhandler.py:397
msgid ""
"Set a token application like 'offline' or 'SSH'. Note: Not all tokens work "
"well with all applications!"
msgstr ""
"Legen Sie eine Token-Anwendung wie \"offline\" oder \"SSH\" fest. Hinweis: "
"Nicht alle Token funktionieren mit allen Anwendungen gleichermaßen!"

#: lib/eventhandler/tokenhandler.py:408
msgid "The number of offline OTP values available"
msgstr "Die Anzahl der verfügbaren Offline-OTP-Werte"

#: lib/eventhandler/tokenhandler.py:416
msgid "The number of rounds for password hashing"
msgstr "Die Anzahl der Runden für das Passwort Hashing"

#: lib/eventhandler/usernotification.py:123
msgid "Send notification email via this email server."
msgstr "Benachrichtigungs-EMail über diesen Email-Server versenden."

#: lib/eventhandler/usernotification.py:127
msgid "Either send email as plain text or HTML."
msgstr "Sende Email als Text oder HTML."

#: lib/eventhandler/usernotification.py:131
msgid "Send QR-Code image as an attachment (cid URL: token_image)"
msgstr "Der QR-Code wird als Bild-Anhang versendet (cid URL: token_image)"

#: lib/eventhandler/usernotification.py:136
msgid "The subject of the mail that is sent."
msgstr "Die Betreffzeile der Email."

#: lib/eventhandler/usernotification.py:140
msgid "The Reply-To header in the sent email."
msgstr "Das Antworten-An Feld in der gesendeten EMail."

#: lib/eventhandler/usernotification.py:162
#: lib/eventhandler/usernotification.py:194
msgid "Any email address, to which the notification should be sent."
msgstr ""
"Eine EMail-Adresse, an welche die Benachrichtigung gesendet werden soll."

#: lib/eventhandler/usernotification.py:169
msgid "The body of the mail that is sent."
msgstr "Der Textkörper der EMail."

#: lib/eventhandler/usernotification.py:173
#: lib/eventhandler/usernotification.py:211
msgid "Send notification to this user."
msgstr "Benachrichtigung an diesen Benutzer senden."

#: lib/eventhandler/usernotification.py:203
msgid "Send the user notification via a predefined SMS gateway."
msgstr "Benutzerbenachrichtigung über dieses SMS-Gateway schicken."

#: lib/eventhandler/usernotification.py:208
msgid "The text of the SMS."
msgstr "Der Text der SMS."

#: lib/eventhandler/usernotification.py:218
msgid ""
"This is the template content of the new file. Can contain the tags as "
"specified in the documentation."
msgstr ""
"Dies ist die Vorlage für die neue Datei. Sie kann die in der Dokumentation "
"spezifizierten Tags enthalten."

#: lib/eventhandler/usernotification.py:224
msgid ""
"The filename of the notification. Existing files are overwritten. The name "
"can contain tags as specified in the documentation and can also contain the "
"tag {random}."
msgstr ""
"Der Name der Benachrichtigungs-Datei. Vorhandene Dateien werden "
"überschrieben. Der Name kann die in der Dokumentation spezifizierten Tags "
"enthalten, und auch den Tag '{random}'."

#: lib/eventhandler/webhookeventhandler.py:84
msgid "The URL the WebHook is posted to"
msgstr "Die URL, an die der WebHook gesendet wird"

#: lib/eventhandler/webhookeventhandler.py:89
msgid "The encoding that is sent to the WebHook, for example json"
msgstr "Das Format, welches an den WebHook gesendet wird, beispielsweise json"

#: lib/eventhandler/webhookeventhandler.py:97
msgid "You can replace placeholder like {logged_in_user}"
msgstr "Sie können Platzhalter wie {logged_in_user} benutzen"

#: lib/eventhandler/webhookeventhandler.py:102
msgid "The data posted in the WebHook"
msgstr "Die an den WebHook gesendeten Daten"

#: lib/machines/ldap.py:336
#, python-format
msgid "Your LDAP config seems to be OK, %i machine objects found."
msgstr ""
"Die LDAP-Konfiguration scheint in Ordnung zu sein. Es wurden %i Maschinen-"
"Objekte gefunden."

#: lib/resolvers/LDAPIdResolver.py:1130
msgid ""
"Your LDAP config found {0!s} user objects, but only {1!s} with the specified "
"uidtype"
msgstr ""
"Für die LDAP-Konfiguration wurden {0!s} Benutzerobjekte gefunden, aber "
"lediglich {1!s} mit dem angegebenen UID Typ"

#: lib/resolvers/LDAPIdResolver.py:1133
msgid "Your LDAP config seems to be OK, {0!s} user objects found."
msgstr ""
"Die LDAP-Konfiguration scheint in Ordnung zu sein. Es wurden {0!s} "
"Benutzerobjekte gefunden."

#: lib/smsprovider/FirebaseProvider.py:199
msgid ""
"The filename of the JSON config file, that allows privacyIDEA to talk to the "
"Firebase REST API."
msgstr ""
"Der Name (mit Pfad) der JSON Config Datei. Diese ermöglicht privacyIDEA mit "
"der Firebase REST API zu kommunizieren."

#: lib/smsprovider/FirebaseProvider.py:204
msgid "Proxy setting for HTTPS connections to googleapis.com."
msgstr "Proxy-Einstellungen für die HTTPS-Verbindung zu googleapis.com."

#: lib/smsprovider/HttpSMSProvider.py:242
msgid "The base URL of the HTTP Gateway"
msgstr "Die Basis URL des HTTP Gateways"

#: lib/smsprovider/HttpSMSProvider.py:245
msgid "Should the HTTP Gateway be connected via an HTTP GET or POST request."
msgstr "Das Gateway wird mittels GET oder POST-Request angesprochen."

#: lib/smsprovider/HttpSMSProvider.py:250
msgid ""
"Specify a substring, that indicates, that the SMS was delivered successfully."
msgstr ""
"Ein Substring in der Antwort, der angibt, ob die SMS erfolgreich zugestellt "
"wurde."

#: lib/smsprovider/HttpSMSProvider.py:254
msgid ""
"Specify a substring, that indicates, that the SMS failed to be delivered."
msgstr ""
"Ein Substring in der Antwort, der angibt, ob die SMS nicht zugestellt werden "
"konnte."

#: lib/smsprovider/HttpSMSProvider.py:258
msgid "Username in case of basic authentication."
msgstr "Benutzername (Basic Authentication)."

#: lib/smsprovider/HttpSMSProvider.py:262
msgid "Password in case of basic authentication."
msgstr "Passwort (Basic Authentication)."

#: lib/smsprovider/HttpSMSProvider.py:267
msgid "Should the SSL certificate be verified."
msgstr "Das SSL-Zertifikat wird überprüft."

#: lib/smsprovider/HttpSMSProvider.py:273
msgid "Should the data in a POST Request be sent as JSON."
msgstr "Sollen die Daten in einer POST-Anfrage als JSON gesendet werden."

#: lib/smsprovider/HttpSMSProvider.py:280
msgid ""
"An optional proxy string. DEPRECATED. Do not use this anymore. Rather use "
"HTTP_PROXY for http connections and HTTPS_PROXY for https connection. The "
"PROXY option will be removed in future."
msgstr ""
"Eine optional PROXY Konfiguration. (VERALTET). Bitte benutzen Sie diese "
"Einstellung nicht mehr, sie wird in der Zukunft entfernt werden. Benutzen "
"Sie bitte HTTP_PROXY für HTTP-Verbindungen und HTTPS_PROXY für HTTPS-"
"Verbindungen."

#: lib/smsprovider/HttpSMSProvider.py:285
msgid "Proxy setting for HTTP connections."
msgstr "Proxy-Einstellung für HTTP-Verbindungen."

#: lib/smsprovider/HttpSMSProvider.py:286
msgid "Proxy setting for HTTPS connections."
msgstr "Proxy-Einstellung für HTTPS-Verbindungen."

#: lib/smsprovider/HttpSMSProvider.py:287
msgid "The timeout in seconds."
msgstr "Timeout in Sekunden."

#: lib/smsprovider/SMSProvider.py:74
msgid ""
"Regular expression to modify the phone number to make it compatible with the "
"provider. For example to remove pluses and slashes enter something like '/[\\"
"+/]//'."
msgstr ""
"Ein regulärer Ausdruck, der die Telefonnummer verändert. Dies ist nützlich, "
"wenn Provider manche Zeichen in der Telefonnummer nicht erlauben. Geben Sie "
"z.B. '/[\\+/]//' ein, um Plus-Zeichen und Schrägstriche zu entfernen."

#: lib/smsprovider/ScriptSMSProvider.py:113
msgid ""
"The script in script directory PI_SCRIPT_SMSPROVIDER_DIRECTORY to call. "
"Expects phone as the parameter and the message from stdin."
msgstr ""
"Das Skript, das aus dem Skripte-Verzeichnis PI_SCRIPT_SMSPROVIDER_DIRECTORY "
"aufgerufen werden soll. Dieses Skript erhält die Telefonnummer als Parameter "
"und die Nachricht über Stdin."

#: lib/smsprovider/SmppSMSProvider.py:125
msgid "SMSC Host IP"
msgstr "SMSC IP Adresse"

#: lib/smsprovider/SmppSMSProvider.py:128
msgid "SMSC Port"
msgstr "SMSC Port"

#: lib/smsprovider/SmppSMSProvider.py:130
msgid "SMSC Service ID"
msgstr "Service ID, mit dem sich privacyIDEA beim SMSC meldet"

#: lib/smsprovider/SmppSMSProvider.py:132
msgid "Password for authentication on SMSC"
msgstr "Das Passwort, mit dem sich privacyIDEA am SMSC authentisiert"

#: lib/smsprovider/SmppSMSProvider.py:134
msgid "SOURCE_ADDR_TON Special Flag"
msgstr "Code des Nummerntyps des Senders. Wird vom SMSC Operator mitgeteilt"

#: lib/smsprovider/SmppSMSProvider.py:136
msgid "S_ADDR_NPI Special Flag"
msgstr "Code des Nummernplans des Senders. Wird vom SMSC Operator mitgeteilt"

#: lib/smsprovider/SmppSMSProvider.py:138
msgid "Source address (SMS sender)"
msgstr "Absender-Telefonnummer"

#: lib/smsprovider/SmppSMSProvider.py:139
msgid "DESTINATION_ADDR_TON Special Flag"
msgstr "Code des Nummertyps des Empfängers. Wird vom SMSC Operator mitgeteilt"

#: lib/smsprovider/SmppSMSProvider.py:140
msgid "D_ADDR_NPI Special Flag"
msgstr ""
"Code des Nummernplans des Empfängers. Wird vom SMSC Operator mitgeteilt"

#: lib/task/eventcounter.py:41
msgid "The name of the event counter to read."
msgstr "Der Name des Eventzählers, der gelesen wird."

#: lib/task/eventcounter.py:46
msgid "The name of the stats key to write to the MonitoringStats table."
msgstr ""
"Der Name des Statistikschlüssels, der in die Monitoring-Tabelle geschrieben "
"wird."

#: lib/task/eventcounter.py:52
msgid ""
"Whether to reset the event_counter, if it is read and written to the "
"MonitoringStats table."
msgstr ""
"Eventzähler zurücksetzen, wenn der Wert gelesen und in die Monitoring-"
"Tabelle geschrieben wird."

#: lib/task/simplestats.py:46
msgid "Total number of tokens"
msgstr "Anzahl aller Token"

#: lib/task/simplestats.py:49
msgid "Total number of hardware tokens"
msgstr "Anzahl aller Hardware-Token"

#: lib/task/simplestats.py:52
msgid "Total number of software tokens"
msgstr "Anzahl aller Software-Token"

#: lib/task/simplestats.py:55
msgid "Number of hardware tokens not assigned to a user"
msgstr "Anzahl der Hardware-Token, die keinem Benutzer zugewiesen sind"

#: lib/task/simplestats.py:58
msgid "Number of tokens assigned to users"
msgstr "Anzahl der Benutzern zugewiesenen Token"

#: lib/task/simplestats.py:61
msgid "Number of users with tokens assigned"
msgstr "Anzahl der Benutzer mit zugewiesenen Token"

#: lib/tokens/applicationspecificpasswordtoken.py:74
msgid ""
"Application Specific Password: A token with a fixed password. Can be used "
"for certain applications or services."
msgstr ""
"Anwendungsspezifisches Passwort: Ein Token mit einem festen Passwort. Kann "
"für bestimmte Anwendungen oder Dienste verwendet werden."

#: lib/tokens/applicationspecificpasswordtoken.py:85
msgid ""
"The user may only have this maximum number of application specific password "
"tokens assigned."
msgstr ""
"Dem Benutzer darf nur diese maximale Anzahl von anwendungsspezifischen "
"Passwort-Tokens zugewiesen werden."

#: lib/tokens/applicationspecificpasswordtoken.py:91
msgid ""
"The user may only have this maximum number of active application specific "
"password tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven anwendungsspezifischen "
"Password-Token zugewiesen haben."

#: lib/tokens/certificatetoken.py:280
msgid "Certificate: Enroll an x509 Certificate Token."
msgstr "Certificate: Ein x509 Zertifikats-Token ausrollen."

#: lib/tokens/certificatetoken.py:291
msgid "The user may only have this maximum number of certificates assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Zertifikaten zugewiesen haben."

#: lib/tokens/certificatetoken.py:296
msgid ""
"The user may only have this maximum number of active certificates assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Zertifikaten "
"zugewiesen haben."

#: lib/tokens/certificatetoken.py:301
msgid ""
"Enrolling a certificate token can require an attestation certificate. "
"(Default: ignore)"
msgstr ""
"Das Ausrollen eines Zertifikats erfordert ein Attestation Zertifikat. "
"(Standard: \"ignore\")"

#: lib/tokens/certificatetoken.py:310
msgid "The CA connector that should be used during certificate enrollment."
msgstr ""
"Der CA-Konnektor welcher für die Zertifikatserstellung genutzt werden soll."

#: lib/tokens/certificatetoken.py:316
msgid "The template that should be used to issue a certificate."
msgstr ""
"Die Zertifikatsvorlage die für das Ausstellen von Zertifikaten genutzt "
"werden soll."

#: lib/tokens/certificatetoken.py:321
msgid ""
"This takes a space separated list of elements to be added to the subject. "
"Can be 'email' and 'realm'."
msgstr ""
"Eine durch Leerzeichen getrennte Liste von Elementen, die dem Subjekt des "
"Zertifikats hinzugefügt werden. Mögliche Elemente sind 'email' und 'realm'."

#: lib/tokens/certificatetoken.py:329 lib/tokens/certificatetoken.py:336
msgid "The directory containing attestation certificate chains."
msgstr ""
"Das Verzeichnis, in dem die Zertifikatsketten der Attestation Zertifikate "
"liegen."

#: lib/tokens/daplugtoken.py:122
msgid "event based OTP token using the HOTP algorithm"
msgstr "Ereignisbasiertes Einmalpasswort auf Basis des HOTP Algorithmus"

#: lib/tokens/daplugtoken.py:128
msgid "The user may only have this maximum number of daplug tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an DAPlug Token zugewiesen haben."

#: lib/tokens/daplugtoken.py:133
msgid ""
"The user may only have this maximum number of active daplug tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven DAPlug Token "
"zugewiesen haben."

#: lib/tokens/daypasswordtoken.py:34
msgid "Specify the time step of the DayPassword token. For example: \"24h\""
msgstr ""
"Geben Sie den Zeitschritt für das DayPassword-Token an (zum Beispiel \"24h\")"

#: lib/tokens/daypasswordtoken.py:82
msgid ""
"DayPassword: A time-based token with a variable timestep and the possibility "
"to use the OTP more than once."
msgstr ""
"DayPassword: Ein zeit-basierter Token mit einem variablen Zeitschritt und "
"der Möglichkeit, den OTP-Wert mehr als einmal zu verwenden."

#: lib/tokens/daypasswordtoken.py:119 lib/tokens/hotptoken.py:173
#: lib/tokens/totptoken.py:159
msgid "Enforce setting an app pin for the privacyIDEA Authenticator App"
msgstr ""
"Erzwingt das Setzen einer Token-PIN in der privacyIDEA Authenticator App"

#: lib/tokens/daypasswordtoken.py:124
msgid ""
"The user may only have this maximum number of daypassword tokens assigned."
msgstr ""
"Dem Benutzer darf nur diese maximale Anzahl von DayPasswort-Tokens "
"zugewiesen werden."

#: lib/tokens/daypasswordtoken.py:130
msgid ""
"The user may only have this maximum number of active daypassword tokens "
"assigned."
msgstr ""
"Dem Benutzer darf nur diese maximale Anzahl von aktiven DayPassword-Tokens "
"zugewiesen werden."

#: lib/tokens/emailtoken.py:155
msgid "EMail Token"
msgstr "EMail Token"

#: lib/tokens/emailtoken.py:157
msgid "EMail: Send a One Time Password to the users email address."
msgstr ""
"E-Mail: Ein Einmalpasswort an die E-Mail-Adresse des Benutzers versenden."

#: lib/tokens/emailtoken.py:165
msgid ""
"The text that will be sent via EMail for an EMail-token. Several tags like "
"{otp} and {serial} can be used as parameters. You may also specify a "
"filename as email template starting with \"file:\"."
msgstr ""
"Der Text der beim EMail-Token via EMail versendet wird. Sie können die "
"Schlagworte {otp} und {serial} als Parameter verwenden. Alternativ können "
"Sie eine EMail-Vorlage als Datei verwenden indem Sie den Dateinamen mit "
"\"file:\" angeben."

#: lib/tokens/emailtoken.py:172
msgid ""
"The subject of the EMail for an EMail token. Use tags like {otp} and "
"{serial} as parameters."
msgstr ""
"Die Betreff-Zeile der EMail eines EMail-Tokens. Es können die Schlagworte "
"{otp} und {serial} verwendet werden."

#: lib/tokens/emailtoken.py:177
msgid ""
"If set, a new EMail OTP will be sent after successful authentication with "
"one EMail OTP."
msgstr ""
"Ein neues Einmalpasswort wird per Email versendet, direkt nachdem sich der "
"Benutzer mit dem Einmalpasswort aus der letzten Email angemeldet hat."

#: lib/tokens/emailtoken.py:182
msgid ""
"Use an alternative challenge text for telling the user to enter the code "
"from the e-mail. You can also use tags for automated replacement. Check out "
"the documentation for more details."
msgstr ""
"Ein alternativer Challenge-Text, um den Benutzer aufzufordern, den Code aus "
"der Email einzugeben. Es können tags zur Textersetzung verwendet werden, "
"siehe Dokumentation."

#: lib/tokens/emailtoken.py:191
msgid "The user may only have this maximum number of email tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Email Token zugewiesen haben."

#: lib/tokens/emailtoken.py:196
msgid ""
"The user may only have this maximum number of active email tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Email Token zugewiesen "
"haben."

#: lib/tokens/emailtoken.py:278
msgid "Enter the OTP from the Email"
msgstr "Bitte geben Sie das Einmalpasswort aus der Email ein"

#: lib/tokens/emailtoken.py:317
msgid "The PIN was correct, but the EMail could not be sent!"
msgstr "Die PIN ist korrekt aber die EMail konnte nicht gesendet werden!"

#: lib/tokens/emailtoken.py:552
msgid "Please enter your new email address!"
msgstr "Bitte geben Sie Ihre neue Email-Adresse ein!"

#: lib/tokens/emailtoken.py:592
msgid "The email address is not valid!"
msgstr "Die Email-Adresse ist nicht gültig!"

#: lib/tokens/foureyestoken.py:130
msgid "4Eyes Token: Use tokens of two or more users to authenticate"
msgstr ""
"Vier-Augen-Token: Zwei oder mehr Personen müssen zusammenkommen, damit sich "
"ein Account anmelden kann"

#: lib/tokens/foureyestoken.py:141
msgid "The user may only have this maximum number of 4eyes tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an 4-Augen-Token zugewiesen haben."

#: lib/tokens/foureyestoken.py:146
msgid ""
"The user may only have this maximum number of active 4eyes tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven 4-Augen-Token "
"zugewiesen haben."

#: lib/tokens/hotptoken.py:82
msgid "Please enter a valid OTP value of the new token."
msgstr "Bitte geben Sie einen gültigen OTP-Wert des neuen Tokens ein."

#: lib/tokens/hotptoken.py:97
msgid "Specify the hashing function to be used. Can be SHA1, SHA256 or SHA512."
msgstr ""
"Der zu verwendende Hash-Algorithmus. Möglich sind SHA-1, SHA-256 oder "
"SHA-512."

#: lib/tokens/hotptoken.py:99
msgid "Specify the OTP length to be used. Can be 6 or 8 digits."
msgstr "Die Länge des OTPs. Möglich sind entweder 6 oder 8 Zeichen."

#: lib/tokens/hotptoken.py:100
msgid "Force the key to be generated on the server."
msgstr "Den Key auf dem Server generieren."

#: lib/tokens/hotptoken.py:101
msgid "Specify whether users are allowed or forced to use two-step enrollment."
msgstr "Benutzer dürfen oder müssen den Zwei-Schritt-Rollout verwenden."

#: lib/tokens/hotptoken.py:103
msgid ""
"Specify whether admins are allowed or forced to use two-step enrollment."
msgstr "Administratoren dürfen oder müssen den Zwei-Schritt-Rollout verwenden."

#: lib/tokens/hotptoken.py:140
msgid "HOTP: Event based One Time Passwords."
msgstr "HOTP: Ereignisbasiertes Einmalpasswort."

#: lib/tokens/hotptoken.py:148
msgid "The user may only have this maximum number of HOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an HOTP Token zugewiesen haben."

#: lib/tokens/hotptoken.py:153
msgid ""
"The user may only have this maximum number of active HOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven HOTP Token zugewiesen "
"haben."

#: lib/tokens/hotptoken.py:158 lib/tokens/totptoken.py:148
msgid "The size of the OTP seed part contributed by the client (in bytes)"
msgstr "Die Größe des Smartphone-Anteils (in Byte)"

#: lib/tokens/hotptoken.py:163 lib/tokens/totptoken.py:151
msgid "The size of the OTP seed part contributed by the server (in bytes)"
msgstr "Die Große des Server-Anteils (in Byte)"

#: lib/tokens/hotptoken.py:168 lib/tokens/totptoken.py:154
msgid ""
"The difficulty factor used for the OTP seed generation (should be at least "
"10000)"
msgstr ""
"Die Schweregrad zur Generierung des OTP Seeds. (Sollte wenigstens 10000 sein)"

#: lib/tokens/hotptoken.py:279
msgid "URL for google Authenticator"
msgstr "URL für Google Authenticator und vergleichbare Apps"

#: lib/tokens/hotptoken.py:292
msgid "URL for OATH token"
msgstr "URL für OATH Token"

#: lib/tokens/hotptoken.py:842
msgid "Please scan the QR code and enter the OTP value!"
msgstr "Bitte scannen Sie den QR-Code und geben den OTP-Wert ein!"

#: lib/tokens/indexedsecrettoken.py:49
msgid "Please enter the positions {0!s} from your secret."
msgstr "Bitte geben Sie die Positionen {0!s} Ihres Geheimnisses ein."

#: lib/tokens/indexedsecrettoken.py:98
msgid "Indexed Secret Token"
msgstr "Indexed Secret Token"

#: lib/tokens/indexedsecrettoken.py:100
msgid ""
"IndexedSecret: Request certain positions of a shared secret from the user."
msgstr ""
"IndexedSecret: Fordert zufällige Positionen von einer geheimen Zeichenkette "
"vom Benutzer."

#: lib/tokens/indexedsecrettoken.py:107
msgid ""
"Use an alternative challenge text for telling the user which positions of "
"the secret he should enter. You can also use tags for automated replacement. "
"Check out the documentation for more details."
msgstr ""
"Benutzen Sie einen alternativen Text, um den Benutzer zur Eingabe der "
"zufälligen Positionen aufzufordern. Es können tags zur Textersetzung "
"verwendet werden, siehe Dokumentation."

#: lib/tokens/indexedsecrettoken.py:115
msgid "Number of necessary positions to be answered by the user."
msgstr "Die Anzahl der notwendigen Positionen, die der Benutzer eingeben muss."

#: lib/tokens/indexedsecrettoken.py:122
msgid "Preset the enrollment with the value of the given attribute."
msgstr ""
"Der Wert der folgenden Benutzerattributes als Voreinstellung verwenden."

#: lib/tokens/indexedsecrettoken.py:129 lib/tokens/indexedsecrettoken.py:136
msgid "The attribute whose value should be force set during enrollment."
msgstr ""
"Das Attribute, dessen Wert zwingend, automatisch beim Ausrollen gesetzt wird."

#: lib/tokens/indexedsecrettoken.py:143
msgid ""
"The user may only have this maximum number of indexed secret tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an IndexedSecret Token zugewiesen "
"haben."

#: lib/tokens/indexedsecrettoken.py:148
msgid ""
"The user may only have this maximum number of active indexed secret tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven IndexedSecret Token "
"zugewiesen haben."

#: lib/tokens/motptoken.py:84
msgid "mOTP: Classical mobile One Time Passwords."
msgstr "mOTP: mobiles Einmal-Passwort."

#: lib/tokens/motptoken.py:102
msgid "The user may only have this maximum number of mOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an mOTP Token zugewiesen haben."

#: lib/tokens/motptoken.py:107
msgid ""
"The user may only have this maximum number of active mOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven mOTP Token zugewiesen "
"haben."

#: lib/tokens/motptoken.py:149
msgid "URL for mOTP token"
msgstr "URL für mOTP Token"

#: lib/tokens/ocratoken.py:89
msgid "OCRA: Enroll an OCRA token."
msgstr "OCRA: Einen OCRA-Token ausrollen."

#: lib/tokens/ocratoken.py:99
msgid "The user may only have this maximum number of OCRA tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an OCRA Token zugewiesen haben."

#: lib/tokens/ocratoken.py:104
msgid ""
"The user may only have this maximum number of active OCRA tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven OCRA Token zugewiesen "
"haben."

#: lib/tokens/papertoken.py:96
msgid "PPR: One Time Passwords printed on a sheet of paper."
msgstr "PPR: Einmal-Passwörter auf einem Blatt Papier ausgedruckt."

#: lib/tokens/papertoken.py:107 lib/tokens/tantoken.py:106
msgid "The number of OTP values, which are printed on the paper."
msgstr "Anzahl der gedruckten OTP-Werte."

#: lib/tokens/papertoken.py:112
msgid "The user may only have this maximum number of paper tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Paper Token zugewiesen haben."

#: lib/tokens/papertoken.py:117
msgid ""
"The user may only have this maximum number of active paper tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Paper Token zugewiesen "
"haben."

#: lib/tokens/passwordtoken.py:113
msgid ""
"A token with a fixed password. Can be combined  with the OTP PIN. Is used "
"for the lost token scenario."
msgstr ""
"Ein Token mit einem festen Passwort. Dieses kann mit der OTP PIN verwendet "
"werden. Wir im Workflow \"Verlorener Token\" verwendet."

#: lib/tokens/passwordtoken.py:125
msgid "The user may only have this maximum number of password tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Password Token zugewiesen "
"haben."

#: lib/tokens/passwordtoken.py:130
msgid ""
"The user may only have this maximum number of active password tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Password Token "
"zugewiesen haben."

#: lib/tokens/pushtoken.py:72
msgid "Please confirm the authentication on your mobile device!"
msgstr "Bitte bestätigen Sie die Anmeldung auf Ihrem Mobilgerät!"

#: lib/tokens/pushtoken.py:73
msgid ""
"Use the polling feature of your privacyIDEA Authenticator App to check for a "
"new Login request."
msgstr ""
"Verwenden Sie die Polling-Funktion Ihrer privacyIDEA Authenticator App, um "
"nach einer neuen Anmeldeanfrage zu suchen."

#: lib/tokens/pushtoken.py:75
msgid "Do you want to confirm the login?"
msgstr "Wollen Sie die Anmeldung bestätigen?"

#: lib/tokens/pushtoken.py:368
msgid "PUSH Token"
msgstr "PUSH Token"

#: lib/tokens/pushtoken.py:370
msgid "PUSH: Send a push notification to a smartphone."
msgstr "PUSH: Sendet eine Push Nachricht an ein Smartphone."

#: lib/tokens/pushtoken.py:379
msgid "The configuration of your Firebase application."
msgstr "Die Konfiguration der Firebase Anwendung."

#: lib/tokens/pushtoken.py:387
msgid ""
"The URL the Push App should contact in the second enrollment step. Usually "
"it is the endpoint /ttype/push of the privacyIDEA server."
msgstr ""
"Die URL für den zweiten Ausrollschritt. Diese URL ruft das Smartphone auf, "
"nachdem der Benutzer den QR-Code gescannt hat. Üblicherweise ist das der "
"Endpunkt /ttype/push des privacyIDEA Servers."

#: lib/tokens/pushtoken.py:393
msgid ""
"The second enrollment step must be completed within this time (in minutes)."
msgstr ""
"Der zweite Rollout-Schritt muss innerhalb dieser Zeit abgeschlossen sein (in "
"Minuten)."

#: lib/tokens/pushtoken.py:397
msgid "The smartphone needs to verify SSL during the enrollment. (default 1)"
msgstr ""
"Das Smartphone überprüft die SSL-Verbindung während des Rollouts. (Standard: "
"1)"

#: lib/tokens/pushtoken.py:403
msgid "The user may only have this maximum number of Push tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Push Token zugewiesen haben."

#: lib/tokens/pushtoken.py:408
msgid ""
"The user may only have this maximum number of active Push tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Push Token zugewiesen "
"haben."

#: lib/tokens/pushtoken.py:414
msgid "Require to unlock the Smartphone before Push requests can be accepted"
msgstr ""
"Das Smartphone muss entsperrt werden, bevor Push-Anfragen akzeptiert werden "
"können"

#: lib/tokens/pushtoken.py:420
msgid ""
"The question the user sees on his mobile phone. Several tags like {serial} "
"and {client_ip} can be used as parameters."
msgstr ""
"Die Frage, die der Benutzer auf seinem Mobiltelefon sieht. Mehrere "
"Platzhalter wie {serial} und {client_ip} können als Parameter genutzt werden."

#: lib/tokens/pushtoken.py:427
msgid "The title of the notification, the user sees on his mobile phone."
msgstr ""
"Die Überschrift, die der Benutzer auf seinem Mobilgerät angezeigt bekommt."

#: lib/tokens/pushtoken.py:432
msgid "The smartphone needs to verify SSL during authentication. (default 1)"
msgstr ""
"Das Smartphone überprüft die SSL-Verbindung während des Anmeldevorgangs. "
"(Standard: 1)"

#: lib/tokens/pushtoken.py:438
msgid "Require the user to confirm the login with a presence check."
msgstr ""
"Der Nutzer muss beim Bestätigen der Authentisierung einen Präsenz-Check "
"machen."

#: lib/tokens/pushtoken.py:443
msgid ""
"The options that can be presented to the user to confirm the login. "
"<code>ALPHABETIC</code>: A-Z, <code>NUMERIC</code>: 01-99, <code>CUSTOM</"
"code>: user defined. "
msgstr ""
"Die Art der Optionen, welche dem Nutzer zum Präsenz-Check angezeigt werden. "
"<code>ALPHABETIC</code>: A-Z, <code>NUMERIC</code>: 01-99, "
"<code>CUSTOM</code>: user defined. "

#: lib/tokens/pushtoken.py:452
msgid ""
"Custom options that can be presented to the user to confirm the login. The "
"string must contain at least 2 options and should be unique. The options are "
"separated by <code>:</code>. e.g.: <code>01:02:03:1A:1B:1C</code>. to "
"<code>CUSTOM</code>."
msgstr ""
"Angepasste Optionen welche dem Nutzer beim Präsenz-Check angezeigt werden. "
"Es müssen mindestens zwei einzigartige Optionen sein. Die Optionen werden "
"separiert durch <code>:</code>, bspw. <code>01:02:03:1A:1B:1C</code>."

#: lib/tokens/pushtoken.py:462
msgid "The number of options the user is presented with to confirm the login. "
msgstr ""
"Die Anzahl der Optionen, welche dem Nutzer beim Präsenz-Check angezeigt "
"werden. "

#: lib/tokens/pushtoken.py:469
msgid ""
"Wait for number of seconds for the user to confirm the challenge in the "
"first request."
msgstr ""
"Der Benutzer hat die Anzahl an Sekunden Zeit, um die Challenge in der ersten "
"Anfrage zu beantworten."

#: lib/tokens/pushtoken.py:475
msgid "Configure whether to allow push tokens to poll for challenges"
msgstr ""
"Push Token können den privacyIDEA Server nach "
"Authentifizierungsanforderungen abfragen"

#: lib/tokens/pushtoken.py:610
msgid "URL for privacyIDEA Push Token"
msgstr "URL des privacyIDEA Push Tokens"

#: lib/tokens/pushtoken.py:1201
msgid "Please scan the QR code!"
msgstr "Bitte scannen Sie den QR-Code!"

#: lib/tokens/questionnairetoken.py:96
msgid "Questionnaire: Enroll Questions for the user."
msgstr "Fragenkatalog: Einen Fragenkatalog-Token ausrollen."

#: lib/tokens/questionnairetoken.py:107
msgid "The user has to answer this number of questions during authentication."
msgstr ""
"Der Benutzer muss während der Authentifizierung dies Anzahl an Fragen "
"beantworten."

#: lib/tokens/questionnairetoken.py:115
msgid ""
"The user may only have this maximum number of questionaire tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Fragenkatalog Token zugewiesen "
"haben."

#: lib/tokens/questionnairetoken.py:120
msgid ""
"The user may only have this maximum number of active questionaire tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Fragenkatalog Token "
"zugewiesen haben."

#: lib/tokens/questionnairetoken.py:164
#, python-format
msgid "You need to provide at least %s answers."
msgstr "Sie müssen wenigstens %s Antworten angeben."

#: lib/tokens/radiustoken.py:106
msgid "RADIUS: Forward authentication request to a RADIUS server."
msgstr ""
"RADIUS: Die Authentifizierungsanfrage an einen RADIUS-Server weiterleiten."

#: lib/tokens/radiustoken.py:115
msgid "The user may only have this maximum number of RADIUS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an RADIUS Token zugewiesen haben."

#: lib/tokens/radiustoken.py:120
msgid ""
"The user may only have this maximum number of active RADIUS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven RADIUS Token "
"zugewiesen haben."

#: lib/tokens/registrationtoken.py:127
msgid ""
"Registration: A token that creates a registration code that can be used as a "
"second factor once."
msgstr ""
"Registrierung: Ein Token, der einen Registrierungs-Code erzeugt, den der "
"Benutzer einmal verwenden kann."

#: lib/tokens/registrationtoken.py:139
msgid ""
"The user may only have this maximum number of registration tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Registrierungs-Token "
"zugewiesen haben."

#: lib/tokens/registrationtoken.py:144
msgid ""
"The user may only have this maximum number of active registration tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Registrierungs-Token "
"zugewiesen haben."

#: lib/tokens/remotetoken.py:112
msgid "Remote Token: Forward authentication request to another server."
msgstr ""
"Remote Token: Die Authentifizierungsanfrage an einen anderen privacyIDEA "
"Server weiterleiten."

#: lib/tokens/remotetoken.py:121 lib/tokens/totptoken.py:164
msgid "The user may only have this maximum number of remote tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Remote Token zugewiesen haben."

#: lib/tokens/remotetoken.py:126 lib/tokens/totptoken.py:169
msgid ""
"The user may only have this maximum number of active remote tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Remote Token "
"zugewiesen haben."

#: lib/tokens/smstoken.py:198
msgid "SMS Token"
msgstr "SMS Token"

#: lib/tokens/smstoken.py:200
msgid "SMS: Send a One Time Password to the users mobile phone."
msgstr ""
"SMS: Ein Einmalpasswort per SMS an das Mobiltelefon des Benutzers senden."

#: lib/tokens/smstoken.py:209
msgid ""
"The text that will be send via SMS for an SMS token. Use tags like {otp} and "
"{serial} as parameters."
msgstr ""
"Der Text der als SMS für ein SMS-Token versendet wird. Es können die "
"Schlagwörter {otp} und {serial} verwendet werden."

#: lib/tokens/smstoken.py:214
msgid ""
"If set, a new SMS OTP will be sent after successful authentication with one "
"SMS OTP."
msgstr ""
"Ein neues Einmalpasswort wird direkt gesendet, nachdem sich der Benutzer "
"erfolgreich mit dem bisherigen Einmalpasswort aus der letzten SMS "
"authentisiert hat."

#: lib/tokens/smstoken.py:219
msgid ""
"Use an alternative challenge text for telling the user to enter the code "
"from the SMS. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr ""
"Ein alternativer Challenge-Text, um den Benutzer aufzufordern, den Code aus "
"der SMS einzugeben. Es können tags zur Textersetzung verwendet werden, siehe "
"Dokumentation."

#: lib/tokens/smstoken.py:229
msgid "Choose the gateways the administrator is allowed to set."
msgstr "Die Gateways, die der Administrator verwenden darf."

#: lib/tokens/smstoken.py:237
msgid "Choose the gateways the user is allowed to set."
msgstr "Die Gateways, die der Benutzer verwenden darf."

#: lib/tokens/smstoken.py:244
msgid "The user may only have this maximum number of SMS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an SMS Token zugewiesen haben."

#: lib/tokens/smstoken.py:249
msgid ""
"The user may only have this maximum number of active SMS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven SMS Token zugewiesen "
"haben."

#: lib/tokens/smstoken.py:326
msgid "Enter the OTP from the SMS:"
msgstr "Bitte geben Sie das Einmalpasswort aus der SMS ein:"

#: lib/tokens/smstoken.py:357
msgid "The PIN was correct, but the SMS could not be sent!"
msgstr "Die PIN ist korrekt aber die SMS konnte nicht gesendet werden!"

#: lib/tokens/smstoken.py:606
msgid "Please enter your new phone number!"
msgstr "Bitte geben Sie Ihre neue Telefonnummer ein!"

#: lib/tokens/spasstoken.py:86
msgid "SPass: Simple Pass token. Static passwords."
msgstr ""
"SPass: Simple Pass Token. Der zweite Faktor entfällt. Authentisierung nur "
"mit OTP PIN."

#: lib/tokens/spasstoken.py:98
msgid "The user may only have this maximum number of SPASS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an SPASS Token zugewiesen haben."

#: lib/tokens/spasstoken.py:103
msgid ""
"The user may only have this maximum number of active SPASS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven SPASS Token zugewiesen "
"haben."

#: lib/tokens/sshkeytoken.py:82
msgid "SSH Public Key: The public SSH key."
msgstr "SSH Public Key: Der öffentliche SSH-Schlüssel."

#: lib/tokens/sshkeytoken.py:91
msgid "The user may only have this maximum number of SSH keys assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an SSH Schlüsseln zugewiesen "
"haben."

#: lib/tokens/sshkeytoken.py:96
msgid "The user may only have this maximum number of active SSH keys assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven SSH Schlüsseln "
"zugewiesen haben."

#: lib/tokens/tantoken.py:96
msgid "TAN: TANs printed on a sheet of paper."
msgstr "TAN: Transaktionsnummern auf einem Blatt Papier ausgedruckt."

#: lib/tokens/tantoken.py:111
msgid "The user may only have this maximum number of TAN tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an TAN Token zugewiesen haben."

#: lib/tokens/tantoken.py:116
msgid ""
"The user may only have this maximum number of active TAN tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven TAN Token zugewiesen "
"haben."

#: lib/tokens/tiqrtoken.py:156
msgid "TiQR: Enroll a TiQR token."
msgstr "TiQR: Einen TiQR-Token ausrollen."

#: lib/tokens/tiqrtoken.py:166
msgid "The user may only have this maximum number of TiQR tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an TiQR Token zugewiesen haben."

#: lib/tokens/tiqrtoken.py:171
msgid ""
"The user may only have this maximum number of active TiQR tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven TiQR Token zugewiesen "
"haben."

#: lib/tokens/tiqrtoken.py:236
msgid "URL for TiQR enrollment"
msgstr "URL zum Ausrollen des TiQR Token"

#: lib/tokens/tiqrtoken.py:394
msgid "Please scan the QR Code"
msgstr "Bitte scannen Sie den QR-Code"

#: lib/tokens/totptoken.py:60
msgid "Specify the time step of the time-based OTP token."
msgstr "Geben Sie den Zeitschritt des zeitbasierten OTP-Tokens an."

#: lib/tokens/totptoken.py:107
msgid "TOTP: Time based One Time Passwords."
msgstr "TOTP: Zeitbasiertes Einmalpasswort."

#: lib/tokens/u2ftoken.py:248
msgid "U2F: Enroll a U2F token."
msgstr "U2F: Einen U2F-Token ausrollen."

#: lib/tokens/u2ftoken.py:258
msgid "This is a list of FQDN hostnames trusting the registered U2F tokens."
msgstr ""
"Die Liste der FQDNs, bei denen der registrierte U2F-Token verwendet werden "
"kann."

#: lib/tokens/u2ftoken.py:262
msgid ""
"Use an alternative challenge text for telling the user to confirm with his "
"U2F device. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr ""
"Ein alternativer Challenge-Text, um den Benutzer aufzufordern, die Anmeldung "
"mit seinem U2F-Token zu bestätigen. Es können tags zur Textersetzung "
"verwendet werden, siehe Dokumentation."

#: lib/tokens/u2ftoken.py:271
msgid "Only specified U2F tokens are authorized."
msgstr "Nur die angegebenen U2F Geräten sind für die Anmeldung autorisiert."

#: lib/tokens/u2ftoken.py:279
msgid "Only specified U2F tokens are allowed to be registered."
msgstr "Nur die angegebenen U2F Geräte dürfen registriert werden."

#: lib/tokens/u2ftoken.py:284
msgid "Do not verify the U2F attestation certificate."
msgstr "Das U2F Attestation Zertifikat NICHT überprüfen."

#: lib/tokens/u2ftoken.py:289
msgid "The user may only have this maximum number of U2F tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an U2F Token zugewiesen haben."

#: lib/tokens/u2ftoken.py:294
msgid ""
"The user may only have this maximum number of active U2F tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven U2F Token zugewiesen "
"haben."

#: lib/tokens/u2ftoken.py:379
msgid "You need to define the appId in the token config!"
msgstr "Sie müssen in der Token-Konfiguration die AppId definieren!"

#: lib/tokens/u2ftoken.py:443
msgid "Please confirm with your U2F token ({0!s})"
msgstr "Bitte bestätigen Sie mit Ihrem U2F token ({0!s})"

#: lib/tokens/vascotoken.py:99
msgid "VASCO Token: Authentication using VASCO tokens"
msgstr "VASCO Token: Authentisierung mit VASCO Token"

#: lib/tokens/vascotoken.py:108
msgid "The user may only have this maximum number of Vasco tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Vasco Token zugewiesen haben."

#: lib/tokens/vascotoken.py:113
msgid ""
"The user may only have this maximum number of active Vasco tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Vasco Token zugewiesen "
"haben."

#: lib/tokens/webauthntoken.py:458
msgid "Generic WebAuthn Token"
msgstr "Generischer WebAuthn Token"

#: lib/tokens/webauthntoken.py:468
msgid "Please confirm with your WebAuthn token ({0!s})"
msgstr "Bitte bestätigen Sie mit Ihrem WebAuthn Token ({0!s})"

#: lib/tokens/webauthntoken.py:469
msgid "Please confirm with your WebAuthn token"
msgstr "Bitte bestätigen Sie mit Ihrem WebAuthn Token"

#: lib/tokens/webauthntoken.py:596
msgid "WebAuthn: Enroll a Web Authentication token."
msgstr "WebAuthn: Einen Web-Authentication Token ausrollen."

#: lib/tokens/webauthntoken.py:606
msgid ""
"A list of transports to prefer to communicate with WebAuthn tokens. Default: "
"usb ble nfc internal (All standard transports)"
msgstr ""
"Eine Liste von Transport-Definitionen die bevorzugt für die Kommunikation zu "
"WebAuthn-Token verwendet werden soll. Standard: usb ble nfc internal (Alle "
"verfügbaren Transport-Definitionen)"

#: lib/tokens/webauthntoken.py:611
msgid ""
"The time in seconds the user has to confirm authorization on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"Die Zeit in Sekunden in welcher der Benutzer die Autorisierung mit seinem "
"WebAuthn Token bestätigen muss. Sie sollten die ChallengeValidityTime "
"entsprechend anpassen. Standard: 60"

#: lib/tokens/webauthntoken.py:617
msgid ""
"Whether the user's identity should be verified when authenticating with a "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"Die Identität des Benutzers soll bei der Authentifizierung mit bestimmt "
"werden. Standard: \"preferred\" (überprüfe den Benutzer, wenn der Token es "
"erlaubt)"

#: lib/tokens/webauthntoken.py:627
msgid ""
"Use an alternative challenge text for telling the user to confirm the login "
"with his WebAuthn token. You can also use tags for automated replacement. "
"Check out the documentation for more details."
msgstr ""
"Ein alternativer Text, der den Benutzer auffordert die Authentifizierung mit "
"seinem WebAuthn Token zu bestätigen. Es können tags zur Textersetzung "
"verwendet werden, siehe Dokumentation."

#: lib/tokens/webauthntoken.py:636
msgid ""
"A list of WebAuthn authenticators acceptable for authorization, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"Eine Liste an WebAuthn Authenticators, die für die Autorisierung akzeptiert "
"werden. In einer mit Leerzeichen getrennten Liste von AAGUIDs. Standardmäßig "
"werden alle akzeptiert."

#: lib/tokens/webauthntoken.py:642
msgid "Only the specified WebAuthn-tokens are authorized."
msgstr "Lediglich die angegebenen WebAuthn Token sind autorisiert."

#: lib/tokens/webauthntoken.py:649
msgid "One webauthn token can not be registered to a user more than once."
msgstr ""
"Ein Webauthn-Token kann nicht mehr als einmal für einen Benutzer registriert "
"werden."

#: lib/tokens/webauthntoken.py:654
msgid "A human-readable name for the organization rolling out WebAuthn tokens."
msgstr "Der Name der Organisation, welche die WebAuthn-Token ausstellt."

#: lib/tokens/webauthntoken.py:659
msgid ""
"A domain name that is a subset of the respective FQDNs for all the "
"webservices the users should be able to sign in to using WebAuthn tokens."
msgstr ""
"Der Domänenname, der alle FQDNs der Webdienste enthält, an denen sich der "
"Benutzer mit einem WebAuthn Token anmelden können soll."

#: lib/tokens/webauthntoken.py:665
msgid ""
"The time in seconds the user has to confirm enrollment on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"Die Zeit in Sekunden, die der Benutzer hat, um den Rollout seines WebAuthn "
"Tokens zu bestätigen. Sie sollten die ChallengeValidityTime entsprechend "
"anpassen. Standard: 60"

#: lib/tokens/webauthntoken.py:672
msgid ""
"Whether to limit roll out of WebAuthn tokens to either only platform "
"authenticators, or only cross-platform authenticators. Default: either"
msgstr ""
"Den Rollout von WebAuthn Token auf entweder \"platform\" authenticators oder "
"\"cross-platform\" beschränken. Standard: \"either\""

#: lib/tokens/webauthntoken.py:683
msgid ""
"A list of WebAuthn authenticators acceptable for enrollment, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"Eine Liste an WebAuthn Authenticators, die beim Rollout aktzeptiert werden. "
"Als eine Leerzeichen getrennte Liste von AAGUIDs. Standardmäßig werden all "
"aktzeptiert."

#: lib/tokens/webauthntoken.py:689
msgid ""
"Whether the user's identity should be verified when rolling out a new "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"Die Identität des Benutzers soll bei der Registrierung des WebAuthn Tokens "
"geprüft werden. Standard: \"preferred\" (Überprüfe den Benutzer, wenn der "
"Token dies unterstützt)"

#: lib/tokens/webauthntoken.py:703
msgid ""
"Which algorithm are available to use for creating public key credentials for "
"WebAuthn tokens. (Default: [{0!s}], Order: [{1!s}])"
msgstr ""
"Der Algorithmus, mit dem Schlüsselpaare für WebAuthn Token erzeugt werden "
"sollen. Standard: [{0!s}], Reihenfolge: [{1!s}]"

#: lib/tokens/webauthntoken.py:710
msgid ""
"Whether to request attestation data when enrolling a new WebAuthn token. "
"Note: for u2f_req to work with WebAuthn, this cannot be set to none. "
"Default: direct (ask for non-anonymized attestation data)"
msgstr ""
"Bei der Registrierung eines neuen WebAuthn Tokens sollen die Attestation "
"Daten angefordert werden. Damit u2f_req mit WebAuthn funktioniert, muss "
"dieser Wert auf \"none\" gesetzt werden. Standard: \"direct\" (Es werden "
"nicht-anonymisierte Attestation Daten angefordert)"

#: lib/tokens/webauthntoken.py:722
msgid ""
"Whether and how strictly to check authenticator attestation data. Note: If "
"the attestation form is none, the attestation level needs to also be none. "
"Default: untrusted (attestation is required, but can be unknown or self-"
"signed)"
msgstr ""
"Ob und wie genau Attestation Daten überprüft werden soll. Wenn die "
"\"attestation form\" auf \"none\" gesetzt ist, muss der \"attestation "
"level\" ebenfalls auf \"none\" gesetzt sein. Standard: "
"\"untrusted\" (Attestation wird angefordert, can aber auch unbekannt oder "
"selbstsigniert sein)"

#: lib/tokens/webauthntoken.py:734
msgid "Only the specified WebAuthn-tokens are allowed to be registered."
msgstr "Lediglich die angegebenen WebAuthn Token dürfen registriert werden."

#: lib/tokens/webauthntoken.py:739
msgid "The user may only have this number of WebAuthn tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an WebAuthn Token zugewiesen "
"haben."

#: lib/tokens/webauthntoken.py:744
msgid "The user may only have this number of active WebAuthn tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven WebAuthn Token "
"zugewiesen haben."

#: lib/tokens/webauthntoken.py:749
msgid ""
"Use an alternative challenge text for telling the user to confirm the "
"enrollment with his WebAuthn device. You can also use tags for automated "
"replacement. Check out the documentation for more details."
msgstr ""
"Ein alternativer Text, der den Benutzer auffordert die Registrierung seines "
"WebAuthn Token zu bestätigen. Es können tags zur Textersetzung verwendet "
"werden, siehe Dokumentation."

#: lib/tokens/yubicotoken.py:101
msgid "Yubikey Cloud mode: Forward authentication request to YubiCloud."
msgstr ""
"Yubikey Cloud Modus: Die Authentifizierungsanfrage wird an die YubiCloud "
"weitergeleitet."

#: lib/tokens/yubicotoken.py:110
msgid "The user may only have this maximum number of Yubico tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Yubico Token zugewiesen haben."

#: lib/tokens/yubicotoken.py:115
msgid ""
"The user may only have this maximum number of active Yubico tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Yubico Token "
"zugewiesen haben."

#: lib/tokens/yubikeytoken.py:160
msgid "Yubikey AES mode: One Time Passwords with Yubikey."
msgstr "Yubikey AES Mode: Einmalpasswort mit dem Yubikey."

#: lib/tokens/yubikeytoken.py:169
msgid "The user may only have this maximum number of Yubikey tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Yubikey Token zugewiesen haben."

#: lib/tokens/yubikeytoken.py:174
msgid ""
"The user may only have this maximum number of active Yubikey tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Yubikey Token "
"zugewiesen haben."

#: lib/tokens/yubikeytoken.py:180
msgid ""
"The Yubikey access code can be read by an enrollment client to initialize "
"Yubikeys."
msgstr ""
"Der Yubikey Access Code kann vom Rollout-Client gelesen werden, um Yubikeys "
"auszurollen."

#: lib/utils/compare.py:189
msgid "true if the value of the left attribute contains the right value"
msgstr "Wahr, wenn der Wert des linken Attributes den rechten Wert beinhaltet"

#: lib/utils/compare.py:190
msgid "false if the value of the left attribute contains the right value"
msgstr ""
"Falsch, wenn der Wert des linken Attributes den rechten Wert beinhaltet"

#: lib/utils/compare.py:192
msgid "true if the value of the left attribute equals the right value"
msgstr "Wahr, wenn der Wert des linken Attributes gleich dem rechten Wert ist"

#: lib/utils/compare.py:193
msgid "false if the value of the left attribute equals the right value"
msgstr ""
"Falsch, wenn der Wert des linken Attributes gleich dem rechten Wert ist"

#: lib/utils/compare.py:195
msgid ""
"true if the value of the left attribute completely matches the given regular "
"expression pattern on the right"
msgstr ""
"Wahr, wenn der Wert des linken Attributes komplett dem auf der rechten Seite "
"angegebenen regulären Ausdruck entspricht"

#: lib/utils/compare.py:196
msgid ""
"false if the value of the left attribute completely matches the given "
"regular expression pattern on the right"
msgstr ""
"Falsch, wenn der Wert des linken Attributes komplett dem auf der rechten "
"Seite angegebenen regulären Ausdruck entspricht"

#: lib/utils/compare.py:198
msgid ""
"true if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr ""
"Wahr, wenn der Wert des linken Attributes in der Komma-separierten Liste auf "
"der rechten Seite enthalten ist"

#: lib/utils/compare.py:199
msgid ""
"false if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr ""
"Falsch, wenn der Wert des linken Attributes in der Komma-separierten Liste "
"auf der rechten Seite enthalten ist"

#: lib/utils/compare.py:201
msgid ""
"true if the integer value of the left attribute is smaller than the right "
"integer value"
msgstr ""
"Wahr, wenn der Zahlenwert des linken Attributes kleiner ist als der "
"Zahlenwert auf der rechten Seite"

#: lib/utils/compare.py:202
msgid ""
"true if the integer value of the left attribute is bigger than the right "
"integer value"
msgstr ""
"Wahr, wenn der Zahlenwert des linken Attributes größer ist als der "
"Zahlenwert auf der rechten Seite"

#~ msgid ""
#~ "Use an alternate challenge text for telling the user to enter an OTP "
#~ "value."
#~ msgstr ""
#~ "Ein alternative Challenge-Text, um den Benutzer aufzufordern, einen OTP-"
#~ "Wert einzugeben."

#~ msgid ""
#~ "Use an alternate challenge text for telling the user to enter the code "
#~ "from the SMS."
#~ msgstr ""
#~ "Ein alternativer Challenge-Text, um den Benutzer aufzufordern, der Code "
#~ "aus der SMS einzugeben."

#~ msgid ""
#~ "Use an alternate challenge text for telling the user to confirm with his "
#~ "WebAuthn device."
#~ msgstr ""
#~ "Geben Sie einen alternativen Text an, der die Benutzer dazu auffordert, "
#~ "die Anmeldung mit einem WebAuthn Gerät zu bestätigen."

#~ msgid "The question the user sees on his mobile phone."
#~ msgstr ""
#~ "Die Frage, die der Benutzer auf seinem Mobilgerät angezeigt bekommt."

#~ msgid ""
#~ "Set label for a new enrolled Google Authenticator. Possible tags are &lt;"
#~ "u&gt; (user), &lt;r&gt; (realm), &lt;s&gt; (serial)."
#~ msgstr ""
#~ "Setzt die Beschriftung für einen neu ausgerollten Google Authenticator "
#~ "oder vergleichbare App. Mögliche Platzhalter sind &lt;u&gt; (Benutzer), "
#~ "&lt;r&gt; (Realm) und &lt;s&gt; (Seriennummer)."

#~ msgid "This is the issuer label for new enrolled Google Authenticators."
#~ msgstr ""
#~ "Die Bezeichnung des Ausstellers für neu ausgerollte Google Authenticator "
#~ "oder vergleichbare Apps."

#~ msgid ""
#~ "Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
#~ "(s)pecial, (o)thers. [+/-]!"
#~ msgstr ""
#~ "Der erforderliche Inhalt einer OTP PIN. 'c' für Buchstaben, 'n' für "
#~ "Ziffern, 's' für Sonderzeichen, 'o' für andere. '+' und '-' nutzbar!"

#~ msgid ""
#~ "If set to \"privacyIDEA\" the users and admins need to authenticate "
#~ "against privacyIDEA when they log in to the Web UI. Defaults to "
#~ "\"userstore\""
#~ msgstr ""
#~ "Benutzer müssen sich entweder gegen privacyIDEA oder gegen die "
#~ "Benutzerquelle (Vorgabe) authentisieren."

#~ msgid ""
#~ "This condition can check any arbitrary tokeninfo field. You need to enter "
#~ "something like '<fieldname> == <fieldvalue>', '<fieldname> > "
#~ "<fieldvalue>' or '<fieldname> < <fieldvalue>'"
#~ msgstr ""
#~ "Diese Bedingung kann jedes beliebige Tokeninfo Feld überprüfen. Hier "
#~ "können Sie Ausdrücke wie '<Feldname> == <Feldwert>', '<Feldname> > "
#~ "<Feldwert>' oder '<Feldname> < <Feldwert>' eingeben."

#~ msgid ""
#~ "An optional proxy string. DEPRECATED. Do not usethis anymore. Rather use "
#~ "HTTP_PROXY for http connections andHTTPS_PROXY for https connection. The "
#~ "PROXY option will beremoved in future."
#~ msgstr ""
#~ "Optional Proxy. VERALTET. Diese Option wird in Zukunft (Version > 2.21) "
#~ "nicht mehr unterstützt werden."

#~ msgid ""
#~ "A list of transports to prefer to communicate with WebAuthn tokens. "
#~ "Default: usb ble nfc internal lightning (All standard transports)"
#~ msgstr ""
#~ "Eine Liste der Transport-Protokolle die bevorzugt bei der Kommunikation "
#~ "mit WebAuthn Token verwendet wird. Standard: usb ble nfc internal "
#~ "lightning"

#~ msgid ""
#~ "The Admin is allowed to set certain additional user attributes. If the "
#~ "Admin should be allowed to set any attribute, set this to '*:*'. For more "
#~ "details, check the documenation."
#~ msgstr ""
#~ "Der Administrator kann zusätzliche Attribute zu Benutzern setzen. Wenn "
#~ "der Administrator beliebige Attribute setzen können soll, dann geben Sie "
#~ "hier '*:*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid ""
#~ "The Admin is allowed to deleted certain additional user attributes. If "
#~ "the Admin should be allowed to delete any attribute, set this to '*'. For "
#~ "more details, check the documentation."
#~ msgstr ""
#~ "Der Administrator kann zusätzliche Attribute zu Benutzern löschen. Wenn "
#~ "der Administrator beliebige Attribute löschen können soll, dann geben Sie "
#~ "hier '*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid ""
#~ "The user is allowed to set certain additional user attributes. If the "
#~ "user should be allowed to set any attribute, set this to '*:*'. For more "
#~ "details, check the documenation."
#~ msgstr ""
#~ "Der Benutzer kann zusätzliche Attribute zu seinem eigenen Benutzeraccount "
#~ "setzen. Wenn er beliebige Attribute setzen können soll, dann geben Sie "
#~ "hier '*:*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid ""
#~ "The user is allowed to deleted certain additional user attributes. If the "
#~ "user should be allowed to delete any attribute, set this to '*'. For more "
#~ "details, check the documentation."
#~ msgstr ""
#~ "Der Benutzer kann zusätzliche Attribute zu seinem eigenen Benutzeraccount "
#~ "löschen. Wenn er beliebige Attribute löschen können soll, dann geben Sie "
#~ "hier '*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid "This is the URL to the token image for smartphone apps like FreeOTP."
#~ msgstr ""
#~ "URL zu einem Bild, das zum Token in einer App wie FreeOTP angezeigt wird."

#~ msgid ""
#~ "The project ID, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die Firebase Projekt ID. Diese finden Sie in Ihrer Firebase Konsole."

#~ msgid ""
#~ "The project number, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die Firebase Projektnummer. Diese finden Sie in Ihrer Firebase Konsole."

#~ msgid ""
#~ "The App ID, that the Android client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die App ID für den Android Client. Sie finden diese in der Firebase "
#~ "Konsole."

#~ msgid ""
#~ "The API Key, that the Android client should use. Get it from your "
#~ "Firebase console."
#~ msgstr ""
#~ "Der API Schlüssel für den Android Client. Sie finden diesen in der "
#~ "Firebase Konsole."

#~ msgid ""
#~ "The App ID, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die App ID für den iOS Client. Sie finden diese in der Firebase Konsole."

#~ msgid ""
#~ "The API Key, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Der API Schlüssel für den iOS Client. Sie finden diesen in der Firebase "
#~ "Konsole."

#~ msgid "token create failed {0!r}"
#~ msgstr "Token-Erstellung fehlgeschlagen: {0!r}"
