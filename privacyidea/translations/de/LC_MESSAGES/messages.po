# German translations for PROJECT.
# Copyright (C) 2017 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
# Paul Lettich <paul.lettich@netknights.it>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2023-08-15 17:33+0200\n"
"PO-Revision-Date: 2023-08-16 12:44+0000\n"
"Last-Translator: Paul Lettich <paul.lettich@netknights.it>\n"
"Language-Team: German <https://hosted.weblate.org/projects/privacyidea/"
"privacyidea-server/de/>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 5.0-dev\n"
"Generated-By: Babel 2.12.1\n"

#: api/auth.py:225
msgid "Authentication failure. Unknown realm: {0!s}."
msgstr "Authentifizierungsfehler. Unbekannter Realm: {0!s}."

#: api/auth.py:229
msgid "Authentication failure. Missing Username"
msgstr "Authentifizierungsfehler. Fehlender Benutzername"

#: api/auth.py:350
msgid "Authentication failure. Wrong credentials"
msgstr "Authentifizierungsfehler. Falsche Login-Daten"

#: api/lib/prepolicy.py:2237
msgid "Missing description for {} token."
msgstr "Fehlende Beschreibung für {} Token."

#: api/lib/prepolicy.py:2238
msgid "Description required for {} token."
msgstr "Eine Beschreibung ist erforderlich für {} Token."

#: api/lib/utils.py:345
msgid "Authentication failure. Missing Authorization header."
msgstr "Authentifizierungsfehler. Fehlender Authentifizierungsheader."

#: api/lib/utils.py:351 api/lib/utils.py:384
msgid "Authentication failure. Error during decoding your token: {0!s}"
msgstr "Authentifizierungsfehler. Fehler beim Dekodieren des Tokens: {0!s}"

#: api/lib/utils.py:377 api/lib/utils.py:387
msgid "Authentication failure. Your token has expired: {0!s}"
msgstr "Authentifizierungsfehler. Der Token ist abgelaufen: {0!s}"

#: api/lib/utils.py:391
msgid ""
"Authentication failure. The username {0!s} is not allowed to impersonate via "
"JWT."
msgstr ""
"Fehler bei der Authentifizierung. Der Benutzername {0!s} ist nicht "
"berechtigt mittels JWT zuzugreifen."

#: api/lib/utils.py:395
msgid ""
"Authentication failure. You do not have the necessary role ({0!s}) to access "
"this resource!"
msgstr ""
"Authentifizierungsfehler. Sie haben nicht die nötige Rolle ({0!s}), um auf "
"die Ressource zuzugreifen!"

#: api/lib/utils.py:413
msgid "'{0!s}' is an invalid policy name."
msgstr "'{0!s}' ist ein ungültiger Name für eine Richtlinie."

#: api/lib/utils.py:416
msgid "The name of the policy may only contain the characters a-zA-Z0-9_. -"
msgstr "Der Name der Richtlinie darf nur die Zeichen 'a-zA-Z0-9_. -' enthalten"

#: lib/challengeresponsedecorators.py:151
msgid "Please enter the new PIN again"
msgstr "Wiederholen Sie bitte die neue PIN"

#: lib/challengeresponsedecorators.py:165
msgid "Please enter a new PIN"
msgstr "Vergeben Sie bitte eine neue PIN"

#: lib/challengeresponsedecorators.py:203
msgid "To resync your token, please enter the next OTP value"
msgstr ""
"Um Ihren Token neu zu synchronisieren, geben Sie bitte den nächsten OTP-Wert "
"ein"

#: lib/decorators.py:43 lib/token.py:2193
msgid "This action is not possible, since the token is locked"
msgstr ""
"Diese Aktion kann nicht durchgeführt werden, weil der Token gesperrt ist"

#: lib/decorators.py:94
msgid "You need to specify a serial or a user."
msgstr "Sie müssen eine Seriennummer oder einen Benutzer angeben."

#: lib/decorators.py:96
msgid "Invalid serial number."
msgstr "Ungültige Seriennummer."

#: lib/decorators.py:98
msgid "Invalid user."
msgstr "Ungültiger Benutzer."

#: lib/error.py:194
msgid "You either need to provide user or serial"
msgstr "Sie müssen entweder eine Seriennummer oder einen Benutzer angeben"

#: lib/policy.py:1367
msgid "Invalid client definition!"
msgstr "Ungültige Client-Definition!"

#: lib/policy.py:1548
msgid "Define in which resolver the user should be registered."
msgstr ""
"Legen Sie fest, in welchem Resolver die Benutzer registriert werden sollen."

#: lib/policy.py:1552
msgid "Define in which realm the user should be registered."
msgstr ""
"Legen Sie fest, in welchem Realm die Benutzer registriert werden sollen."

#: lib/policy.py:1556
msgid ""
"The SMTP server configuration, that should be used to send the registration "
"email."
msgstr ""
"Die SMTP-Server-Konfiguration mit der Registrierungs-Emails versendet werden."

#: lib/policy.py:1560
msgid ""
"Only users with this email address are allowed to register. This is a "
"regular expression."
msgstr ""
"Nur Benutzer mit dieser EMail-Adresse können sich registrieren. Dies ist ein "
"Regulärer Ausdruck."

#: lib/policy.py:1565
msgid ""
"The body of the registration email. Use '{regkey}' as tag for the "
"registration key."
msgstr ""
"Der Inhalt der Registrierungs-Email. Benutze '{regkey}' als Tag für den "
"Registrierungsschlüssel."

#: lib/policy.py:1571
msgid "Admin is allowed to enable tokens."
msgstr "Der Administrator kann Token aktivieren."

#: lib/policy.py:1575
msgid "Admin is allowed to disable tokens."
msgstr "Der Adminitrator kann Token deaktivieren."

#: lib/policy.py:1579
msgid "Admin is allowed to set token properties."
msgstr "Der Administrator kann Token-Eigenschaften verändern."

#: lib/policy.py:1584
msgid "The admin is allowed to set the token description."
msgstr "Der Administrator darf die Token-Beschreibung setzen."

#: lib/policy.py:1588
msgid "Admin is allowed to set the OTP PIN of tokens."
msgstr "Der Administrator kann die OTP PIN von Token setzen."

#: lib/policy.py:1594
msgid "Admin is allowed to set a random OTP PIN of tokens."
msgstr ""
"Der Administrator kann die OTP PIN von Token auf einen zufälligen Wert "
"setzen."

#: lib/policy.py:1598
msgid "Admin is allowed to manually set and delete token info."
msgstr "Der Administrator kann Tokeninformationen ändern und löschen."

#: lib/policy.py:1602
msgid "Admin is allowed to set the OTP PIN during enrollment."
msgstr "Der Administrator kann die OTP PIN während des Rollouts setzen."

#: lib/policy.py:1607
msgid "Admin is allowed to resync tokens."
msgstr "Der Administrator kann Token resynchronisieren."

#: lib/policy.py:1611
msgid "Admin is allowed to reset the Failcounter of a token."
msgstr ""
"Der Administrator kann den Fehlerzähler (Failcounter) von Token zurücksetzen."

#: lib/policy.py:1617
msgid "Admin is allowed to revoke a token"
msgstr "Der Administrator kann Token revozieren"

#: lib/policy.py:1621
msgid "Admin is allowed to assign a token to a user."
msgstr "Der Administrator kann Token einem Benutzer zuweisen."

#: lib/policy.py:1627
msgid ""
"Admin is allowed to remove the token from a user, i.e. unassign a token."
msgstr "Der Administrator kann die Zuweisung eines Tokens aufheben."

#: lib/policy.py:1633
msgid "Admin is allowed to import token files."
msgstr "Der Administrator kann eine Token-Seed-Datei importieren."

#: lib/policy.py:1638
msgid "Admin is allowed to remove tokens from the database."
msgstr "Der Administrator kann Token aus der Datenbank löschen."

#: lib/policy.py:1644
msgid "Admin is allowed to view the list of the users."
msgstr "Der Adminsitrator kann die Benutzerliste anzeigen."

#: lib/policy.py:1650
msgid "The Admin is allowed to list the machines."
msgstr "Der Administrator kann Maschinen auflisten."

#: lib/policy.py:1655
msgid "The Admin is allowed to attach and detach tokens to machines."
msgstr ""
"Der Administrator kann Token Maschinen zuweisen und diese Zuweisung wieder "
"aufheben."

#: lib/policy.py:1662
msgid ""
"The Admin is allowed to fetch authentication items of tokens assigned to "
"machines."
msgstr ""
"Der Administrator kann Authentifizierungsinformationen der den Maschinen "
"zugewiesenen Token erfragen."

#: lib/policy.py:1667
msgid "Admin is allowed to manage the realms of a token."
msgstr "Der Administrator kann die Realms eines Tokens bearbeiten."

#: lib/policy.py:1672
msgid "Admin is allowed to list tokens."
msgstr "Der Administrator darf Token auflisten."

#: lib/policy.py:1676
msgid "Admin is allowed to retrieve a serial for a given OTP value."
msgstr "Der Administrator kann die Seriennummer zu einem OTP-Wert bestimmen."

#: lib/policy.py:1681
msgid "Admin is allowed to retrieve random keys from privacyIDEA."
msgstr "Der Adminsitrator kann Zufallszahlen von privacyIDEA anfordern."

#: lib/policy.py:1685
msgid "Admin is allowed to copy the PIN of one token to another token."
msgstr ""
"Der Administrator kann die OTP PIN eines Tokens zu einem anderen kopieren."

#: lib/policy.py:1690
msgid ""
"Admin is allowed to copy the assigned user to another token, i.e. assign a "
"user to another token."
msgstr ""
"Der Administrator kann die Zuweisung eines Benutzer von einem Token zu einem "
"anderen Token übertragen. D.h. dem Benutzer einen anderen Token zuweisen."

#: lib/policy.py:1696
msgid "Admin is allowed to trigger the lost token workflow."
msgstr "Der Administrator kann den Workflow \"Verlorener Token\" durchführen."

#: lib/policy.py:1702
msgid "Admin is allowed to write and modify the system configuration."
msgstr "Der Administrator kann die Systemkonfiguration verändern."

#: lib/policy.py:1707
msgid "Admin is allowed to delete keys in the system configuration."
msgstr ""
"Der Administrator kann Einstellungen in der Systemkonfiguration löschen."

#: lib/policy.py:1713
msgid "Admin is allowed to read basic system configuration."
msgstr "Der Administrator darf die Basiskonfiguration lesen."

#: lib/policy.py:1718
msgid ""
"Admin is allowed to export a documentation of the complete configuration "
"including resolvers and realm."
msgstr ""
"Der Administrator kann eine Dokumentation der kompletten Konfiguration "
"exportieren. Dies beinhaltet auch die Konfiguration von Resolvern und Realms."

#: lib/policy.py:1726
msgid "Admin is allowed to write and modify the policies."
msgstr "Der Administrator kann Richtlinien anlegen und bearbeiten."

#: lib/policy.py:1731
msgid "Admin is allowed to delete policies."
msgstr "Der Administrator kann Richtlinien löschen."

#: lib/policy.py:1736
msgid "Admin is allowed to read policies."
msgstr "Der Administrator darf Richtlinien lesen."

#: lib/policy.py:1740
msgid ""
"Admin is allowed to write and modify the resolver and realm configuration."
msgstr ""
"Der Administrator kann die Konfiguration von Resolvern und Realms anlegen "
"und bearbeiten."

#: lib/policy.py:1747
msgid "Admin is allowed to delete resolvers and realms."
msgstr "Der Administrator kann Resolver und Realms löschen."

#: lib/policy.py:1752
msgid "Admin is allowed to read resolvers."
msgstr "Der Administrator darf Resolver lesen."

#: lib/policy.py:1756
msgid ""
"Admin is allowed to create new CA Connector definitions and modify existing "
"ones."
msgstr ""
"Der Administrator kann Konfigurationen der Zertifizierungsstellen anlegen "
"und bearbeiten."

#: lib/policy.py:1762
msgid "Admin is allowed to delete CA Connector definitions."
msgstr ""
"Der Administrator kann Konfigurationen der Zertifizierungsstellen löschen."

#: lib/policy.py:1767
msgid "Admin is allowed to read CA Connector definitions."
msgstr "Der Administrator kann die Definitionen der CA-Konnektoren lesen."

#: lib/policy.py:1772
msgid "Admin is allowed to write and modify the machine resolvers."
msgstr ""
"Der Administrator kann Maschinenkonfigurationen anlegen und bearbeiten."

#: lib/policy.py:1778
msgid "Admin is allowed to delete machine resolvers."
msgstr "Der Administrator kann Maschinenkonfigurationen löschen."

#: lib/policy.py:1784
msgid "Admin is allowed to read machine resolvers."
msgstr "Der Administrator darf Maschinen-Resolver lesen."

#: lib/policy.py:1791 lib/policy.py:2072
msgid "Set the maximum allowed length of the OTP PIN."
msgstr "Die maximal erlaubte Länge einer OTP PIN."

#: lib/policy.py:1796 lib/policy.py:2077
msgid "Set the minimum required length of the OTP PIN."
msgstr "Die minimal geforderte Länge einer OTP PIN."

#: lib/policy.py:1800 lib/policy.py:2081
msgid ""
"Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
"(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgstr ""
"Geben Sie den geforderten Inhalt der OTP PIN an. (c) für Buchstaben, (n) für "
"Zahlen, (s) für Sonderzeichen. Sie können die Attribute +/- verwenden oder "
"eine dedizierte Liste von Zeichen angeben, z.B. [1234565890]"

#: lib/policy.py:1809
msgid "The length of a random PIN set by the administrator."
msgstr "Die Länge der vom Administrator gesetzten zufälligen PIN."

#: lib/policy.py:1812
msgid "Admin is allowed to view the Audit log."
msgstr "Der Adminsitrator kann das Audit-Log ansehen."

#: lib/policy.py:1816
msgid "The admin will only see audit entries of the last 10d, 3m or 2y."
msgstr ""
"Der Administrator kann nur Audit-Einträge der letzen 10 Tage (10d), 3 Monate "
"(3m) oder 2 Jahre (2y) sehen."

#: lib/policy.py:1821
msgid "The admin will not see the specified columns in the audit."
msgstr ""
"Die angegebenen Spalten werden im Audit Log ausgeblendet und dem "
"Administrator nicht angezeigt."

#: lib/policy.py:1826
msgid "The admin is allowed to download the complete auditlog."
msgstr "Der Administrator kann das Audit-Log herunterladen."

#: lib/policy.py:1831
msgid "Admin is allowed to add users in a userstore/UserIdResolver."
msgstr "Der Adminstrator kann Benutzer hinzufügen."

#: lib/policy.py:1836
msgid "Admin is allowed to update the users data in a userstore."
msgstr "Der Administrator kann Benutzerdaten editieren."

#: lib/policy.py:1841
msgid "Admin is allowed to delete a user object in a userstore."
msgstr "Der Administrator kann Benutzer in der Benutzerquelle löschen."

#: lib/policy.py:1846
msgid "Admin is allowed to set the password of the HSM/Security Module."
msgstr ""
"Der Administrator kann das Passwort des HSM/Sicherheitsmoduls eingeben."

#: lib/policy.py:1850
msgid "Admin is allowed to retrieve the list of active challenges."
msgstr "Der Administrator kann eine Liste der aktiven Challenges anzeigen."

#: lib/policy.py:1856
msgid "Admin is allowed to write new SMTP server definitions."
msgstr "Der Administrator kann SMTP-Server-Konfigurationen bearbeiten."

#: lib/policy.py:1861
msgid "Admin is allowed to read SMTP server definitions."
msgstr "Der Administrator darf SMTP-Server-Definitionen lesen."

#: lib/policy.py:1866
msgid "Admin is allowed to write new RADIUS server definitions."
msgstr "Der Administrator kann RADIUS-Server-Konfigurationen bearbeiten."

#: lib/policy.py:1872
msgid "Admin is allowed to read RADIUS server definitions."
msgstr "Der Administrator darf RADIUS-Server-Definitionen lesen."

#: lib/policy.py:1877
msgid "Admin is allowed to write remote privacyIDEA server definitions."
msgstr "Der Administrator kann Remote privacyIDEA Server definieren."

#: lib/policy.py:1884
msgid "Admin is allowed to read remote privacyIDEA server definitions."
msgstr ""
"Der Administrator darf die Definitionen von Remote privacyIDEA Systemen "
"lesen."

#: lib/policy.py:1891
msgid "Admin is allowed to write periodic task definitions."
msgstr "Der Administrator kann regelmäßige Aufgaben bearbeiten."

#: lib/policy.py:1896
msgid "Admin is allowed to read periodic task definitions."
msgstr ""
"Der Administrator darf Definitionen von wiederkehrenden Aufgaben lesen."

#: lib/policy.py:1901
msgid "Admin is allowed to read statistics data."
msgstr "Der Administrator kann Statistikdaten lesen."

#: lib/policy.py:1904
msgid "Admin is allowed to delete statistics data."
msgstr "Der Administrator kann Statistikdaten löschen."

#: lib/policy.py:1907
msgid "Admin is allowed to write and modify the event handling configuration."
msgstr "Der Administrator kann Event-Handler-Definitionen bearbeiten."

#: lib/policy.py:1913
msgid "Admin is allowed to read event handling configuration."
msgstr "Der Administrator darf die Definition von Event-Handlern lesen."

#: lib/policy.py:1918
msgid "Admin is allowed to write and modify SMS gateway definitions."
msgstr "Der Administrator kann SMS-Gateway-Konfigurationen bearbeiten."

#: lib/policy.py:1924
msgid "Admin is allowed to read SMS gateway definitions."
msgstr "Der Administrator darf Definitionen von SMS-Gateways lesen."

#: lib/policy.py:1929
msgid ""
"Admin is allowed to get the list of authenticated clients and their types."
msgstr ""
"Der Administrator kann die Liste der authentifizierten Client-Applikationen "
"anzeigen."

#: lib/policy.py:1936
msgid "Admin is allowed to add and delete component subscriptions."
msgstr "Der Administrator kann Subskriptionen importieren und löschen."

#: lib/policy.py:1942
msgid "The Admin is allowed to trigger a challenge for e.g. SMS OTP token."
msgstr ""
"Der Administrator kann eine Challenge für bspw. SMS OTP Token auslösen."

#: lib/policy.py:1948
msgid ""
"The Admin is allowed to set certain custom user attributes. If the Admin "
"should be allowed to set any attribute, set this to '*:*'. For more details, "
"check the documentation."
msgstr ""
"Der Administrator darf gewisse benutzerdefinierte Attribute setzen. Wenn der "
"Administrator jedes beliebige Attribut setzen können soll, tragen Sie hier "
"'*:*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#: lib/policy.py:1956
msgid ""
"The Admin is allowed to delete certain custom user attributes. If the Admin "
"should be allowed to delete any attribute, set this to '*'. For more "
"details, check the documentation."
msgstr ""
"Der Administrator darf gewisse benutzerdefinierte Attribute löschen. Wenn "
"der Administrator jedes beliebige benutzerdefinierte Attribut löschen können "
"soll, setzen sie dies auf '*'. Für weitere Details lesen Sie bitte die "
"Dokumentation."

#: lib/policy.py:1964
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the admin."
msgstr ""
"Dies ist eine mit Leerzeichen getrennte Liste an Tokeninfo-Einträge, die dem "
"Administrator nicht angezeigt werden."

#: lib/policy.py:1969
msgid "The Admin is allowed list the available tokengroups."
msgstr "Der Administrator kann die verfügbaren Token-Gruppen anzeigen."

#: lib/policy.py:1974
msgid "The Admin is allowed to add a new tokengroup."
msgstr "Der Administrator kann neue Token-Gruppen hinzufügen."

#: lib/policy.py:1979
msgid "The Admin is allowed delete a tokengroup."
msgstr "Der Administrator kann Token-Gruppen löschen."

#: lib/policy.py:1984
msgid "The Admin is allowed list the available service ID definitions."
msgstr ""
"Der Administrator kann die verfügbaren Dienste-Kennzeichnungen anzeigen."

#: lib/policy.py:1989
msgid "The Admin is allowed to add a new service ID definition."
msgstr "Der Administrator darf neue Dienste-Kennzeichnungen hinzufügen."

#: lib/policy.py:1994
msgid "The Admin is allowed delete a service ID definition."
msgstr "Der Administrator kann Dienste-Kennzeichnungen löschen."

#: lib/policy.py:1999
msgid "The Admin is allowed to manage the tokengroups of a token."
msgstr "Der Administrator kann die Token-Gruppen eines Tokens bearbeiten."

#: lib/policy.py:2006
msgid ""
"The user is allowed to assign an existing token that is not yet assigned "
"using the token serial number."
msgstr ""
"Der Benutzer darf sich einen noch nicht zugewiesenen Token anhand der "
"Seriennummer zuweisen."

#: lib/policy.py:2012
msgid "The user is allowed to disable his own tokens."
msgstr "Der Benutzer darf seine eigenen Token deaktivieren."

#: lib/policy.py:2018
msgid "The user is allowed to enable his own tokens."
msgstr "Der Benutzer darf seine eigenen Token aktivieren."

#: lib/policy.py:2024
msgid "The user is allowed to delete his own tokens."
msgstr "Der Benutzer darf seine eigenen Token löschen."

#: lib/policy.py:2030
msgid "The user is allowed to unassign his own tokens."
msgstr "Der Benutzer darf die eigene Zuweisung zu seinen Token aufheben."

#: lib/policy.py:2035
msgid "The user is allowed to resyncronize his tokens."
msgstr "Der Benutzer kann seine eigenen Token resynchronisieren."

#: lib/policy.py:2040
msgid "The user is allowed to revoke a token"
msgstr "Der Benutzer darf seine eigenen Token revozieren"

#: lib/policy.py:2045
msgid "The user is allowed to reset the failcounter of his tokens."
msgstr "Der Benutzer darf den Fehlerzähler seiner eigenen Token zurücksetzen."

#: lib/policy.py:2050
msgid "The user is allowed to set the OTP PIN of his tokens."
msgstr "Der Benutzer darf die OTP PINs seiner Token setzen."

#: lib/policy.py:2055
msgid "The user is allowed to set a random OTP PIN of his tokens."
msgstr ""
"Der Benutzer kann die OTP PIN seiner Token auf einen zufälligen Wert setzen."

#: lib/policy.py:2060
msgid "The length of a random PIN set by the user."
msgstr "Die Länge der vom Benutzer gesetzten zufälligen PIN."

#: lib/policy.py:2063
msgid "The user is allowed to set the token description."
msgstr "Der Benutzer darf die Token-Beschreibung setzen."

#: lib/policy.py:2067
msgid "The user is allowed to set the OTP PIN during enrollment."
msgstr "Der Benutzer kann die OTP PIN während des Rollouts setzen."

#: lib/policy.py:2090
msgid "Allow the user to view his own token history."
msgstr "Der Benutzer kann die Tokenhistorie seiner eigenen Token anzeigen."

#: lib/policy.py:2093
msgid "The user will only see audit entries of the last 10d, 3m or 2y."
msgstr ""
"Der Benutzer kann nur die Audit-Einträge der letzten 10 Tage (10d), 3 Monate "
"(3m) oder 2 Jahre (2y) sehen."

#: lib/policy.py:2097
msgid "The user will not see the specified columns in the audit."
msgstr ""
"Die angegebenen Spalten werden im Audit Log ausgeblendet und dem Benutzer "
"nicht angezeigt."

#: lib/policy.py:2102
msgid "The user is allowed to view his own user information."
msgstr "Der Benutzer kann seine eigenen Benutzerinformationen sehen."

#: lib/policy.py:2106
msgid ""
"The user is allowed to update his own user information, like changing his "
"password."
msgstr "Der Benutzer darf seine eigenen Benutzerinformationen bearbeiten."

#: lib/policy.py:2111
msgid ""
"The user is allowed to do a password reset in an editable UserIdResolver."
msgstr "Der Benutzer darf sein Passwort im Benutzerverzeichnis setzen."

#: lib/policy.py:2117
msgid ""
"The user is allowed to set certain custom user attributes. If the user "
"should be allowed to set any attribute, set this to '*:*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"Der Benutzer darf gewisse benutzerdefinierte Attribute setzen. Wenn der "
"Benutzer jedes beliebige Attribut setzen können soll, tragen Sie hier '*:*' "
"ein. Benutzern Sie '*' mit VORSICHT! Für weitere Details lesen Sie bitte die "
"Dokumentation."

#: lib/policy.py:2125
msgid ""
"The user is allowed to delete certain custom user attributes. If the user "
"should be allowed to delete any attribute, set this to '*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"Der Benutzer darf gewisse benutzerdefinierte Attribute löschen. Wenn der "
"Benutzer jedes beliebige Attribut löschen können soll, tragen Sie hier bitte "
"'*' ein. Verwenden Sie '*' mit VORSICHT! Für weitere Detail lesen Sie bitte "
"die Dokumentation."

#: lib/policy.py:2133
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the user."
msgstr ""
"Dies ist eine mit Leerzeichen getrennte Liste an Tokeninfo-Einträgen, die "
"dem Benutzer nicht angezeigt werden."

#: lib/policy.py:2141
msgid "Limit the number of allowed tokens in a realm."
msgstr "Maximale Anzahl von Token in einem realm."

#: lib/policy.py:2145
msgid ""
"During the rollout process, this policy makes the description required for "
"all selected tokentypes."
msgstr ""
"Diese Richtlinie erzwingt die Angabe einer Beschreibung beim ausrollen für "
"die angegebenen Tokentypen."

#: lib/policy.py:2153
msgid "Limit the number of tokens a user may have assigned."
msgstr "Maximale Anzahl an Token, die ein Benutzer besitzen darf."

#: lib/policy.py:2158
msgid "Limit the number of active tokens a user may have assigned."
msgstr "Die Anzahl der aktiven Tokens pro Benutzer begrenzen."

#: lib/policy.py:2163
msgid ""
"Set a random OTP PIN with this length for a token during the enrollment "
"process."
msgstr ""
"Setze eine zufällige OTP PIN dieser Länge während des Ausrollens eines "
"Tokens."

#: lib/policy.py:2168
msgid "In case of a random OTP PIN use this python module to process the PIN."
msgstr ""
"Wenn eine zufällige OTP PIN gesetzt wird, nutze dieses Python Modul, um die "
"PIN zu verarbeiten."

#: lib/policy.py:2173
msgid ""
"If the administrator sets the OTP PIN during enrollment or later, the user "
"will have to change the PIN during first use."
msgstr ""
"Wenn der Administrator die OTP PIN setzt (während des Ausrollens oder "
"später) muss der Benutzer die OTP PIN zurücksetzen."

#: lib/policy.py:2180
msgid ""
"The user needs to change his PIN on a regular basis. To change the PIN every "
"180 days, enter '180d'."
msgstr ""
"Der Benutzer muss die OTP PIN regelmäßig ändern. Um die PIN all 180 Tage zu "
"ändern, geben Sie '180d' ein."

#: lib/policy.py:2187
msgid ""
"The OTP PIN can be hashed or encrypted. Hashing the PIN is the default "
"behaviour."
msgstr ""
"Die OTP PIN wird standardmäßig gehasht abgespeichert. Wenn sie verschlüsselt "
"abgespeichert werden soll, wählen Sie diese Option."

#: lib/policy.py:2192
msgid ""
"The label for a new enrolled Smartphone token. Possible tags are <code>{user}"
"</code>, <code>{realm}</code>, <code>{serial}</code>, <code>{givenname}</"
"code> and <code>{surname}</code>."
msgstr ""
"Die Bezeichnung für ein neu ausgerolltes Smartphone-Token. Mögliche "
"Platzhalter sind <code>{user}</code>, <code>{realm}</code>, <code>{serial}</"
"code>, <code>{givenname}</code> und <code>{surname}</code>."

#: lib/policy.py:2198
msgid ""
"The issuer label for new enrolled Smartphone token.Possible tags are "
"<code>{user}</code>, <code>{realm}</code>, <code>{serial}</code>, "
"<code>{givenname}</code> and <code>{surname}</code>."
msgstr ""
"Die Bezeichnung des Ausstellers für neu ausgerollte Smartphone-Token. "
"Mögliche Platzhalter sind <code>{user}</code>, <code>{realm}</code>, "
"<code>{serial}</code>, <code>{givenname}</code> und <code>{surname}</code>."

#: lib/policy.py:2205
msgid ""
"This is the URL to the token image for the privacyIDEA Authenticator and "
"some other apps like FreeOTP (supported file formats: PNG, JPG and GIF)."
msgstr ""
"Die URL zum Token-Symbol für den privacyIDEA Authenticator und anderen Apps "
"wie FreeOTP (unterstützte Bildformate: PNG, JPG und GIF)."

#: lib/policy.py:2212
msgid ""
"Users can assign a token just by using the unassigned token to authenticate."
msgstr ""
"Der Benutzer kann sich automatisch einen Token zuweisen, indem er sich mit "
"einem noch nicht zugewiesenen Token anmeldet."

#: lib/policy.py:2218
msgid "The length of the password in case of temporary token (lost token)."
msgstr ""
"Die Länge des Passworts für einen temporären Token (Workflow \"Verlorener "
"Token\")."

#: lib/policy.py:2222
msgid ""
"The contents of the temporary password, described by the characters C, c, n, "
"s, 8."
msgstr ""
"Der Inhalt des temporären Passworts. 'C': Große Buchstaben, 'c': kleine "
"Buchstaben, 'n': Ziffern, 's': Sonderzeichen, '8' Base58 Zeichensatz."

#: lib/policy.py:2227
msgid "The length of the validity for the temporary token (in days)."
msgstr "Die Gültigkeitsdauer des temporären Passworts in Tagen."

#: lib/policy.py:2232
msgid "Set the length of registration codes."
msgstr "Setzt die Länge des Registrierungscodes."

#: lib/policy.py:2236
msgid ""
"Specify the required contents of the registration code. (c)haracters, "
"(n)umeric, (s)pecial. Use modifiers +/- or a list of allowed characters "
"[1234567890]"
msgstr ""
"Definiert den erforderlichen Inhalt des Registrierungscodes. (c) Buchstaben, "
"(n) Nummern und (s) Sonderzeichen. Sie können die Attribute +/- verwenden "
"oder eine dedizierte Liste von Zeichen angegeben, z.B. [1234567890]"

#: lib/policy.py:2245
msgid "Set the length of the password of generated password tokens."
msgstr "Die Länge des Passworts für einen generierten Passwort-Token."

#: lib/policy.py:2249
msgid ""
"Specify the required contents of the password of a password token. "
"(c)haracters, (n)umeric, (s)pecial. Use modifiers +/- or a list of allowed "
"characters [1234567890]"
msgstr ""
"Geben Sie den geforderten Inhalt des Passwortes eines Passwort-Tokens an. "
"(c) Buchstaben, (n) Zahlen und (s) Sonderzeichen. Sie können die Attribute "
"+/- verwenden oder eine dedizierte Liste von Zeichen angeben, z.B. "
"[1234565890]"

#: lib/policy.py:2257
msgid ""
"Specify a white space separated list of token types, that should be verified "
"during enrollment."
msgstr ""
"Eine Leerzeichen-getrennte Liste an Tokentypen, die beim Rollout durch die "
"Eingabe eines OTP-Wertes verifiziert werden sollen."

#: lib/policy.py:2266
msgid ""
"Either use the Token PIN , use the Userstore Password or use no fixed "
"password component."
msgstr ""
"Der erste Wissensfaktor kann entweder die OTP PIN, das Passwort aus der "
"Benutzerquelle oder nichts sein."

#: lib/policy.py:2271
msgid ""
"This is a whitespace separated list of tokentypes, that can be used with "
"challenge response."
msgstr ""
"Liste von Tokentypen, die für das Challenge-Response Verfahren verwendet "
"werden können (durch Leerzeichen getrennt)."

#: lib/policy.py:2278
msgid ""
"Use an alternate challenge text for telling the user to enter an OTP value."
msgstr ""
"Ein alternative Challenge-Text, um den Benutzer aufzufordern, einen OTP-Wert "
"einzugeben."

#: lib/policy.py:2283
msgid ""
"If there are several different challenges, this text precedes the list of "
"the challenge texts."
msgstr ""
"Wenn es mehrere verschiedene Challengetexte gibt, wird dieser Text der Liste "
"der anderen Texte vorangestellt."

#: lib/policy.py:2288
msgid ""
"If there are several different challenges, this text follows the list of the "
"challenge texts."
msgstr ""
"Wenn es mehrere verschiedene Challengetexte gibt, wird dieser Text an die "
"Liste der anderen Texte hinten angefügt."

#: lib/policy.py:2293
msgid ""
"If the PIN of a token is to be changed, this will allow the user to change "
"the PIN during a validate/check request via challenge / response."
msgstr ""
"Wenn die PIN eines Tokens geändert werden soll, kann der Benutzer die PIN-"
"Änderung auch in einer Rückfrage während einer Authentifizierung mittels "
"validate/check durchführen."

#: lib/policy.py:2298
msgid ""
"The autoresync of a token can be done via a challenge response message.You "
"need to activate 'Automatic resync' in the general settings!"
msgstr ""
"Die automatische Resynchronisierung eines Tokens kann über eine Challenge-"
"Response-Nachricht erfolgen. In den allgemeinen Einstellungen muss die "
"'Automatische Resynchronisierung' aktiviert sein!"

#: lib/policy.py:2303
msgid ""
"In case of a successful authentication the following tokentype is enrolled. "
"The maximum number of tokens for a user is checked."
msgstr ""
"Im Falle einer erfolgreichen Authentisierung wird der folgende Tokentyp "
"ausgerollt. Die maximale Anzahl von Token für einen Benutzer wird überprüft."

#: lib/policy.py:2310
msgid ""
"If set, the user in this realm will be authenticated against the userstore "
"or against the given RADIUS config, if the user has no tokens assigned."
msgstr ""
"Wenn einem Benutzer kein Token zugewiesen ist, werden sein Passwort gegen "
"die hier eingestellte RADIUS-Server-Konfiguration geprüft."

#: lib/policy.py:2317
msgid ""
"This allows to automatically assign a Token within privacyIDEA, if the user "
"was authenticated via passthru against a RADIUS server. The OTP value is "
"used to find the unassigned token in privacyIDEA. Enter the length of the "
"OTP value and where the PIN is set like 8:pin or pin:6."
msgstr ""
"Hier kann einem Benutzer automatisch ein Token zugewiesen werden, wenn er "
"sich erfolgreich gegen einen RADIUS Server authentisiert hat. Der OTP-Wert "
"wird benutzt, um einen nicht zugewiesenen Token in privacyIDEA zu finden. "
"Die PIN des neuen Tokens wird gesetzt. Geben Sie die Länge des OTP-Wertes an "
"und wo sich die PIN befindet. Bspw. 8:pin oder pin:6."

#: lib/policy.py:2324
msgid ""
"If the user has no token, the authentication request for this user will "
"always be true."
msgstr ""
"Wenn einem Benutzer kein Token zugewiesen ist, so wird eine "
"Authentifizierungsanfrage für diesen Benutzer immer positiv beantwortet."

#: lib/policy.py:2329
msgid ""
"If the user user does not exist, the authentication request for this non-"
"existing user will always be true."
msgstr ""
"Wenn der Benutzer nicht existiert, wird die Authentifizierungsanfrage immer "
"positiv beantwortet."

#: lib/policy.py:2335
msgid ""
"Can be used to modify the parameters pass, user and realm in an "
"authentication request. See the documentation for an example."
msgstr ""
"Hiermit können die Parameter pass, user und realm in einer "
"Authentifizierungsanfrage verändert werden. Bitte lesen Sie die "
"Dokumentation für mehr Details."

#: lib/policy.py:2341
msgid ""
"If a user authenticates successfully reset the failcounter of all of his "
"tokens."
msgstr ""
"Wenn sich ein Benutzer erfolgreich authentisiert hat, werden die "
"Fehlerzähler all seiner Token zurückgesetzt."

#: lib/policy.py:2346
msgid ""
"Increase the failcounter for all the tokens, for which a challenge has been "
"triggered."
msgstr ""
"Der Fehlerzähler aller Token, die eine Challenge ausgelöst haben, wird "
"inkrementiert."

#: lib/policy.py:2350
msgid ""
"Cache the password used for authentication and allow authentication with the "
"same credentials for a certain amount of time. Specify timeout like 4h or "
"4h/5m."
msgstr ""
"Das Passwort und den OTP-Wert einer erfolgreichen Anmeldung wird von "
"privacyIDEA gecacht. Somit kann für einen gewissen Zeitraum die Anmeldung "
"mit den gleichen Credentials erfolgen. Die Zeit wird angegeben als 4h or "
"4h/5m."

#: lib/policy.py:2357
msgid ""
"You can set the client modes in the order that you prefer. For example: "
"\"interactive webauthn poll u2f\". Accepted values are: <code>interactive "
"webauthn poll u2f</code>"
msgstr ""
"Sie können die Client-Modi in der von Ihnen bevorzugten Reihenfolge "
"festlegen. Zum Beispiel: \"interactive webauthn poll u2f\". Akzeptierte "
"Werte sind:<code>interactive webauthn poll u2f</code>"

#: lib/policy.py:2365
msgid ""
"Allow the user to authenticate (default). If set to '{0!s}', the "
"authentication of the user will be denied."
msgstr ""
"Der Benutzer darf sich anmelden (Standardeinstellung). Wenn dies auf '{0!s}' "
"gesetzt ist, wird dem Benutzer die Authentifizierung verweigert."

#: lib/policy.py:2372
msgid ""
"Allow the application to choose which token types should be used for "
"authentication. Application may set the parameter 'type' in the request. "
"Works with validate/check, validate/samlcheck and validate/triggerchallenge."
msgstr ""
"Die Applikation, die den Authentifizierungsrequest an privacyIDEA sendet, "
"darf selber bestimmen, mit welchem Tokentyp die Authentifizierung erfolgen "
"soll. Hierzu sendet die Applikation den Parameter 'type' mit. Dies gilt für "
"validate/check, validate/samlcheck und validate/triggerchallenge."

#: lib/policy.py:2379
msgid ""
"You can specify how many successful authentication requests a user is "
"allowed to do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h "
"being second, minute and hour."
msgstr ""
"Sie können angeben, wie viele erfolgreiche Authentifizierungsanfragen ein "
"Benutzer in einer gewissen Zeitspanne durchführen darf. Geben Sie an 1/5s, "
"2/10m oder 10/1h - Dabei sind (s) Sekunden, (m) Minuten und (h) Stunden."

#: lib/policy.py:2387
msgid ""
"You can specify how many failed authentication requests a user is allowed to "
"do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h being second, "
"minute and hour."
msgstr ""
"Sie können angeben, wie viele fehlgeschlagene Authentifizierungsversuche ein "
"Benutzer in einer gewissen Zeit durchführen darf. Geben Sie bpsw. an 1/5s, "
"2/10m, 10/1h - (s) für Sekunden, (m) für Minuten und (h) für Stunden."

#: lib/policy.py:2395
msgid ""
"You can specify in which time frame the user needs to authenticate again "
"with this token. If the user authenticates later, authentication will fail. "
"Specify like 30h, 7d or 1y."
msgstr ""
"Sie können angeben, in welcher Zeit sich ein Benutzer erneut anmelden muss, "
"bzw. wie lang die letzte erfolgreiche Anmeldung zurückliegen darf. Ansonsten "
"wird der Anmeldeversuch fehlschlagen. Geben Sie bspw. an 30h, 7d oder 1y (1 "
"Jahr)."

#: lib/policy.py:2403
msgid "The user will only be authenticated with this very tokentype."
msgstr "Der Benutzer kann sich nur mit diesem Tokentyp authentisieren."

#: lib/policy.py:2410
msgid ""
"The user will only be authenticated if the serial number of the token "
"matches this regexp."
msgstr ""
"Der Benutzer kann sich nur mit einem Token anmelden, dessen Seriennummer auf "
"diesen regulären Ausdruck passt."

#: lib/policy.py:2416
msgid ""
"The user will only be authenticated if the tokeninfo field matches the "
"regexp (key/&lt;regexp&gt;/)."
msgstr ""
"Die Autorisierung des Benutzers ist nur erfolgreich, wenn das Token-Info "
"Feld <code>key</code> auf den regulären Ausdruck passt: (<code>key/"
"<regexp>/</code>)."

#: lib/policy.py:2423
msgid ""
"The Realm of the user is set to this very realm. This is important if the "
"user is not contained in the default realm and can not pass his realm."
msgstr ""
"Der Benutzerrealm wird auf diesen Realm gesetzt. Dies kann genutzt werden, "
"wenn die Benutzer nicht im Default-Realm sind und der Realm von der "
"Applikation nicht übergeben werden kann."

#: lib/policy.py:2430
msgid ""
"In case of successful authentication additional no detail information will "
"be returned."
msgstr ""
"Im Fall einer erfolgreichen Authentifizierung werden keine zusätzlichen "
"Detail-Informationen zurückgeliefert."

#: lib/policy.py:2436
msgid ""
"In case of failed authentication additional no detail information will be "
"returned."
msgstr ""
"Im Fall einer erfolglosen Authentifizierung werden keine zusätzlichen Detail-"
"Informationen zurückgeliefert."

#: lib/policy.py:2442
msgid ""
"In case of successful authentication user data will be added in the detail "
"branch of the authentication response."
msgstr ""
"Im Fall einer erfolgreichen Authentifizierung werden zusätzliche "
"Benutzerdaten zurückgeliefert."

#: lib/policy.py:2449
msgid ""
"In case of successful authentication the user resolver and realm will be "
"added in the detail branch of the authentication response."
msgstr ""
"Im Falle der erfolgreichen Authentifizierung wird der Resolver und der Realm "
"des Benutzers in der API Antwort mit zurückgeliefert."

#: lib/policy.py:2456
msgid ""
"The sending of an API Auth Key is required duringauthentication. This avoids "
"rogue authenticate requests against the /validate/check interface."
msgstr ""
"Die Nutzung eines API Auth Key für die Authentifizierung ist notwendig. Dies "
"verhindert unberechtigte Authentifizierungs-Versuche gegen das /validate/"
"check Interface."

#: lib/policy.py:2466
msgid ""
"If set, administrators will see a dashboard as start screen when logging in "
"to privacyIDEA WebUI."
msgstr ""
"Wenn dies gesetzt ist, bekommen Administratoren ein Dashboard im WebUI "
"angezeigt."

#: lib/policy.py:2471
msgid ""
"If set to \"privacyIDEA\" the users and admins need to authenticate against "
"privacyIDEA when they log in to the Web UI. Defaults to \"userstore\"."
msgstr ""
"Wenn dies auf \"privacyIDEA\" gesetzt wird, müssen sich Administratoren und "
"Benutzer gegen privacyIDEA authentisieren, wenn sie sich im WebUI einloggen "
"wollen. Standard: \"userstore\"."

#: lib/policy.py:2480
msgid ""
"An alternative text to display on the WebUI login dialog instead of \"Please "
"sign in\"."
msgstr "Ein alternativer Text bei der Anmeldung am privacyIDEA WebUI."

#: lib/policy.py:2484
msgid ""
"When searching in the user list, the search will only performed when "
"pressing enter."
msgstr ""
"Die Suche in der Benutzerliste erst nach Drücken der Entertaste ausführen."

#: lib/policy.py:2489
msgid ""
"The action taken when a user is idle beyond the logout_time limit. Defaults "
"to \"lockscreen\"."
msgstr ""
"Diese Aktion wird ausgeführt, wenn der Benutzer zu lange inaktiv ist. "
"Standard: \"lockscreen\"."

#: lib/policy.py:2497
msgid ""
"The REMOTE_USER set by the webserver can be used to login to privacyIDEA or "
"it will be ignored. Defaults to \"disable\"."
msgstr ""
"Der Webserver REMOTE_USER wird für die Anmeldung am WebUI verwendet. "
"Standard: \"disable\"."

#: lib/policy.py:2503
msgid ""
"Set the time in seconds after which the user will be logged out from the "
"WebUI. Default: 120"
msgstr ""
"Die Zeit in Sekunden, nach denen der Bennutzer aus dem WebUI abgemeldet "
"wird. Standard: 120"

#: lib/policy.py:2508
msgid "Set how many tokens should be displayed in the token view on one page."
msgstr ""
"Anzahl der Tokens, die in der Tabelle auf der Tokenübersichtsseite angezeigt "
"werden."

#: lib/policy.py:2513
msgid "Set how many users should be displayed in the user view on one page."
msgstr ""
"Anzahl der Benutzer, die in der Tabelle auf der Tokenübersichtsseite "
"angezeigt werden."

#: lib/policy.py:2518
msgid ""
"Set how many audit entries should be displayed in the audit view on one page."
msgstr ""
"Anzahl der Audit-Enträge, die in der Tabelle auf der Audit-Seite angezeigt "
"werden."

#: lib/policy.py:2523
msgid "Use your own html template for the web UI menu."
msgstr "Eine eigene HTML-Vorlage für das Menü im Web UI verwenden."

#: lib/policy.py:2527
msgid "Use your own html template for the web UI baseline/footer."
msgstr "Eine eigene HTML-Vorlage für die Fußzeile im Web UI verwenden."

#: lib/policy.py:2531
msgid "Link your privacy statement to be displayed in the baseline/footer."
msgstr ""
"Ein Link zur Datenschutzerklärung, der im Footer der Webseite angezeigt wird."

#: lib/policy.py:2535
msgid ""
"Whether the user ID and the resolver should be displayed in the token list."
msgstr "Die Benutzer ID und den Benutzer-Resolver in der Tokenliste anzeigen."

#: lib/policy.py:2540
msgid ""
"The URL of a repository, where the policy templates can be found.  (Default "
"https: //raw.githubusercontent.com/ privacyidea/policy-templates /master/"
"templates/)"
msgstr ""
"Die URL der Policy-Templates. (Default https: //raw.githubusercontent.com/ "
"privacyidea/policy-templates /master/templates/)"

#: lib/policy.py:2547
msgid ""
"The URL of an SSO provider for redirect at logout.(The URL must start with "
"http:// or https://)"
msgstr ""
"Die URL eines SSO-Anbieters für die Weiterleitung beim Abmelden. (Die URL "
"muss mit http:// oder https:// beginnen.)"

#: lib/policy.py:2552
msgid ""
"As long as a user has no token, he will only see a token wizard in the UI."
msgstr "Einem Benutzer ohne Token wird automatisch der Token Wizard angezeigt."

#: lib/policy.py:2557
msgid ""
"The tokenwizard will be displayed in the token menu, even if the user "
"already has a token."
msgstr ""
"Der Token Wizard als Menüpunkt angeboten - auch wenn der Benutzer bereits "
"einen Token hat."

#: lib/policy.py:2562
msgid ""
"This is a whitespace separated list of tokentypes, for which a rollover "
"button is displayed in the token details."
msgstr ""
"Dies ist eine mit Leerzeichen getrennte Liste an Tokentypen, für die das "
"Rollover im WebUI erlaubt ist."

#: lib/policy.py:2569
msgid ""
"The welcome dialog will be displayed if the user has no tokens assigned."
msgstr ""
"Wenn dem Benutzer kein Token zugewiesen ist, wird der Willkommensdialog "
"angezeigt."

#: lib/policy.py:2573
msgid "This is the default token type in the token enrollment dialog."
msgstr "Die Voreinstellung des Tokentyps im Rollout-Dialog."

#: lib/policy.py:2579
msgid ""
"A list of realm names, which are displayed in a drop down menu in the WebUI "
"login screen. Realms are separated by white spaces."
msgstr ""
"Eine durch Leerzeichen getrennte Liste von Realmnamen, die in einer "
"Auswahlliste beim Login in das Webinterface angezeigt werden."

#: lib/policy.py:2585
msgid ""
"If this checked, the administrator will not see the welcome dialog anymore."
msgstr "Dem Administrator wird der Willkommen-Dialog nicht mehr angezeigt."

#: lib/policy.py:2590
msgid ""
"Per default disabled actions result in disabled buttons. When checking this "
"action, buttons of disabled actions are hidden."
msgstr ""
"Buttons von Funktionen, die ein Benutzer nicht ausführen darf, werden "
"ausgeblendet (Das Standardverhalten ist, dass die Buttons deaktiviert "
"werden)."

#: lib/policy.py:2595
msgid ""
"If this is checked, there will be a confirmation prompt when deleting "
"policies, events, mresolver, resolver or periodic tasks!"
msgstr ""
"Wenn diese Aktion aktiviert ist, wird beim Löschen von Richtlinien, "
"Ereignissen, Regelmäßigen Aufgaben oder (Maschinen-)Resolvern ein "
"Bestätigungsdialog angezeigt!"

#: lib/policy.py:2600
msgid ""
"If this is checked, the seed will be displayed as text during enrollment."
msgstr ""
"Wenn dies angehakt ist, wird das Seed während des Rollouts als Text "
"angezeigt."

#: lib/policy.py:2605
msgid ""
"If this is checked, the privacyIDEA Node name will be displayed in the menu "
"bar."
msgstr ""
"Wenn dies angehakt ist, wird der Name des privacyIDEA Knotens in der "
"Menüzeile angezeigt."

#: lib/policy.py:2610
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the Google "
"Play Store."
msgstr ""
"Wenn diese Richtlinie gesetzt ist, dann wird in dem Ausroll-Dialog für HOTP, "
"TOTP und Push Token ein QR-Code angezeigt, der zum privacyIDEA Authenticator "
"im Google Play Store führt."

#: lib/policy.py:2617
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the iOS App "
"Store."
msgstr ""
"Wenn diese Richtlinie gesetzt ist, dann wird in dem Ausroll-Dialog für HOTP, "
"TOTP und Push Token ein QR-Code angezeigt, der zum privacyIDEA Authenticator "
"im IOS App Store führt."

#: lib/policy.py:2624
msgid ""
"This action adds a QR code in the enrollment page for HOTP, TOTP and Push "
"tokens, that lead to this given URL."
msgstr ""
"Wenn diese Richtlinie gesetzt ist, dann wird in dem Ausroll-Dialog für HOTP, "
"TOTP und Push Token ein QR-Code angezeigt, der zu der angegebenen URL führt."

#: lib/policy.py:2669
msgid ""
"The policy only matches if certain conditions on the user info are fulfilled."
msgstr ""
"Die Richtlinie greift, wenn zusätzliche Anforderungen an die "
"Benutzerattribute erfüllt sind."

#: lib/policy.py:2672
msgid ""
"The policy only matches if certain conditions of the token attributes are "
"fulfilled."
msgstr ""
"Die Richtlinie greift, wenn die Bedingung für das Token-Attribut erfüllt ist."

#: lib/policy.py:2675
msgid ""
"The policy only matches if certain conditions on the token info are "
"fulfilled."
msgstr ""
"Die Richtlinie greift, wenn zusätzliche Anforderungen an die Token "
"Infoattribute erfüllt sind."

#: lib/policy.py:2678
msgid ""
"The policy only matches if certain conditions on the HTTP Request header are "
"fulfilled."
msgstr ""
"Die Richtlinie greift nur, wenn bestimmte Anforderungen an die HTTP-Request "
"Header erfüllt sind."

#: lib/policy.py:2681
msgid ""
"The policy only matches if certain conditions on the HTTP Environment are "
"fulfilled."
msgstr ""
"Die Richtlinie greift, wenn zusätzliche Anforderungen an HTTP "
"Umgebungsvariablen erfüllt sind."

#: lib/radiusserver.py:225 lib/radiusserver.py:257
msgid "The RADIUS secret is too long"
msgstr "Das RADIUS Secret ist zu lang"

#: lib/token.py:152
msgid "create_tokenclass_object failed:  {0!r}"
msgstr "create_tokenclass_object fehlgeschlagen: {0!r}"

#: lib/token.py:308
msgid "I can only create SQL filters from tokeninfo of length 1."
msgstr "Es können nur SQL-Filter aus einem Tokeninfo Eintrag erstellt werden."

#: lib/token.py:565
msgid "The requested token could not be found."
msgstr "Der gesuchte Token wurde nicht gefunden."

#: lib/token.py:567
msgid "More than one matching token were found."
msgstr "Es wurde mehr als ein passender Token gefunden."

#: lib/token.py:881
msgid "multiple tokens are matching this OTP value!"
msgstr "Dieser OTP-Wert passt zu mehreren Token!"

#: lib/token.py:1041
msgid "init token failed: unknown token type {0!r}"
msgstr "init_token fehlgeschlagen: unbekannter Token-Typ {0!r}"

#: lib/token.py:1062
msgid "initToken failed: {0!s}"
msgstr "init_token fehlgeschlagen: {0!s}"

#: lib/token.py:1222
msgid "Token already assigned to user {0!r}"
msgstr "Der Token wurde schon dem Benutzer {0!r} zugewiesen"

#: lib/token.py:1236
msgid "Token assign failed for {0!r}/{1!s} : {2!r}"
msgstr "Tokenzuweisung fehlgeschlagen für {0!r}/{1!s} : {2!r}"

#: lib/token.py:1264
msgid "Token unassign failed for {0!r}/{1!r}: {2!r}"
msgstr "Fehler beim Aufheben der Tokenzuweisung für {0!r}/{1!r}: {2!r}"

#: lib/token.py:1340
msgid "Parameter user must not be a string: {0!r}"
msgstr "Parameter \"user\" darf kein String sein: {0!r}"

#: lib/token.py:1879
msgid "You can only define a lost token for an assigned token."
msgstr ""
"Sie können einen verlorenen Token nur für einen zugewiesenen Token "
"definieren."

#: lib/token.py:1905
msgid "temporary replacement for {0!s}"
msgstr "vorübergehender Ersatz für Token {0!s}"

#: lib/token.py:1961
msgid "There is no active and assigned token in this realm"
msgstr "Es gibt keinen aktiven und zugewiesenen Token in diesem Realm"

#: lib/token.py:1973
msgid ""
"There is no active and assigned token in this realm, included types: {0!s}, "
"excluded types: {1!s}"
msgstr ""
"Es gibt keinen aktiven und zugeordneten Token in diesem Realm, enthaltene "
"Typen: {0!s}, ausgeschlossene Typen: {1!s}"

#: lib/token.py:2027
msgid "OTP verification failed."
msgstr "OTP-Überprüfung fehlgeschlagen."

#: lib/token.py:2060
msgid "The user has no tokens assigned"
msgstr "Dem Benutzer sind keine Token zugewiesen"

#: lib/token.py:2275
msgid "matching {0:d} tokens"
msgstr "{0:d} passende Token"

#: lib/token.py:2327
msgid "Challenge matches, but token is not fit for challenge"
msgstr ""
"Challenge stimmt überein aber der Token ist nicht für Challenge-Response "
"geeignet"

#: lib/token.py:2337
msgid "Found matching challenge"
msgstr "Passende Challenge gefunden"

#: lib/token.py:2379
msgid "Response did not match the challenge."
msgstr "Die Antwort passt nicht zur Challenge."

#: lib/token.py:2381
msgid "Response did not match for {0!s} tokens."
msgstr "Die Antwort stimmte für {0!s} Token nicht überein."

#: lib/token.py:2389
msgid "No active challenge response token found"
msgstr "Kein aktiver Challenge-Response Token gefunden"

#: lib/token.py:2405
msgid "wrong otp value"
msgstr "falscher OTP-Wert"

#: lib/token.py:2412
msgid ". previous otp used again"
msgstr "früherer OTP-Wert wieder verwendet"

#: lib/token.py:2426
msgid "wrong otp pin"
msgstr "falsche OTP-Pin"

#: lib/token.py:2434
msgid "No suitable token found for authentication."
msgstr "Kein passender Token für die Authentifizierung gefunden."

#: lib/token.py:2459
msgid "Admin is allowed to initialize {0!s} tokens."
msgstr "Der Administrator kann {0!s} Token ausrollen."

#: lib/token.py:2467
msgid "The user is allowed to enroll a {0!s} token."
msgstr "Der Benutzer darf einen {0!s} Token ausrollen."

#: lib/token.py:2498
msgid "Set the maximum allowed PIN length of the {0!s} token."
msgstr "Setze die maximal erlaubte PIN-Länge für den {0!s} Token."

#: lib/token.py:2505
msgid "Set the minimum required PIN length of the {0!s} token."
msgstr "Sete die minimal notwendite PIN-Länge für den {0!s} Token."

#: lib/token.py:2511
msgid ""
"Specifiy the required PIN contents of the {0!s} token. (c)haracters, "
"(n)umeric, (s)pecial, (o)thers. [+/-]!"
msgstr ""
"Definiere den notwendigen Inhalte der OTP PIN für den {0!s} Token. (c) "
"Buchstaben, (n) Ziffern, (s) Sonderzeichen, (o) Andere [+/-]!"

#: lib/token.py:2556 lib/token.py:2572
msgid "The tokengroup does not exist."
msgstr "Die Token-Gruppe existiert nicht."

#: lib/tokenclass.py:1674
msgid "please enter otp: "
msgstr "Bitte geben Sie einen OTP-Wert ein: "

#: lib/applications/ssh.py:104
msgid "The username on the SSH server."
msgstr "Der Benutzername auf dem SSH-Server."

#: lib/applications/ssh.py:106
msgid ""
"The service ID of the SSH server. Several servers can have the same service "
"ID."
msgstr ""
"Die Dienste-Kennzeichnung des SSH-Servers. Unterschiedliche SSH-Server "
"können die selbe Dienste-Kennzeichnung haben."

#: lib/eventhandler/base.py:146
msgid ""
"The rollout_state of the token has a certain value like 'clientwait' or "
"'enrolled'."
msgstr ""
"Das attribute \"rollout_state\" des Tokens hat einen bestimmten Wert wie "
"'clientwait' oder 'enrolled'."

#: lib/eventhandler/base.py:151
msgid "The realm of the user, for which this event should apply."
msgstr "Der Realm des Benutzers, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:157
msgid "The resolver of the user, for which this event should apply."
msgstr "Der Resolver des Benutzers, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:163
msgid "The realm of the token, for which this event should apply."
msgstr "Der Realm des Tokens, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:170
msgid "The resolver of the token, for which this event should apply."
msgstr "Der Resolver des Tokens, für den diese Ereignis-Definition greift."

#: lib/eventhandler/base.py:177
msgid "The type of the token."
msgstr "Der Tokentyp."

#: lib/eventhandler/base.py:183
msgid "The logged in user is of the following type."
msgstr "Der angemeldete Benutzer ist vom Typ."

#: lib/eventhandler/base.py:189
msgid "The result.value within the response is True or False."
msgstr "Das result.value in der Server-Antwort ist 'True' oder 'False'."

#: lib/eventhandler/base.py:196
msgid "The result.status within the response is True or False."
msgstr ""
"Der Wert von result.status der Antwort ist entweder \"True\" oder \"False\"."

#: lib/eventhandler/base.py:203
msgid "Check if the max failcounter of the token is reached."
msgstr "Der maximale Fehlerzähler des Tokens wurde erreicht."

#: lib/eventhandler/base.py:210
msgid "The token has a user assigned."
msgstr "Der Token ist einem Benutzer zugewiesen."

#: lib/eventhandler/base.py:216
msgid ""
"The token has a user assigned, but the user does not exist in the userstore "
"anymore."
msgstr ""
"Dem Token ist ein Benutzer zugewiesen, aber dieser Benutzer existiert nicht "
"mehr in der Benutzerquelle."

#: lib/eventhandler/base.py:223
msgid "Check if the token is within its validity period."
msgstr "Überprüfe, ob der Token innerhalb des Gültigkeitszeitraums liegt."

#: lib/eventhandler/base.py:229
msgid "Action is triggered, if the serial matches this regular expression."
msgstr ""
"Die Aktion wird ausgeführt, wenn die Seriennummer auf den regulären Ausdruck "
"passt."

#: lib/eventhandler/base.py:235
msgid "Action is triggered, if the user has this number of tokens assigned."
msgstr ""
"Die Aktion wird ausgeführt, wenn der Benutzer diese Anzahl an Tokens besitzt."

#: lib/eventhandler/base.py:241
msgid ""
"Action is triggered, if the counter of the token equals this setting. Can "
"also be '>100' or '<99' for no exact match."
msgstr ""
"Die Aktion wird ausgelöst, wenn der OTP Zähler dem angegebenen Wert "
"entspricht. Die Bedingung kann auch größer '>100' oder kleiner '<99' als ein "
"definierter Grenzwert sein."

#: lib/eventhandler/base.py:248
msgid ""
"Action is triggered, if the last authentication of the token is older than "
"7h, 10d or 1y."
msgstr ""
"Die Aktion wird ausgeführt, wenn die letzte Authentisierung mit diesem Token "
"länger als 7 Stunden, 10 Tage oder 1 Jahr (7h, 10d, 1y) zurückliegt."

#: lib/eventhandler/base.py:254
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth' is bigger than 100, less than 99 or exactly 100."
msgstr ""
"Dies kann '>100', '<99' oder '=100' sein, um eine Aktion auszulösen. Das "
"Feld 'count_auth' in Tokeninfo ist dann größer als 100, kleiner als 99 oder "
"exakt 100."

#: lib/eventhandler/base.py:261
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth_success' is bigger than 100, less than 99 or "
"exactly 100."
msgstr ""
"Dies kann '>100', '<99' oder '=100' sein, um eine Aktion auszulösen. Das "
"Feld 'count_auth_success' in Tokeninfo ist dann größer als 100, kleiner als "
"99 oder exakt 100."

#: lib/eventhandler/base.py:269
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"difference between the tokeninfo field 'count_auth' and 'count_auth_success "
"is bigger than 100, less than 99 or exactly 100."
msgstr ""
"Dies kann '>100', '<99' oder '=100' sein, um eine Aktion auszulösen. Das "
"Feld 'count_auth' und 'count_auth_success' in Tokeninfo ist dann größer als "
"100, kleiner als 99 oder exakt 100."

#: lib/eventhandler/base.py:277
msgid ""
"This can be '>9', '<9', or '=10', to trigger the action, if the failcounter "
"of a token matches this value. Note that the failcounter stops increasing, "
"if the max_failcount is reached."
msgstr ""
"Hier können Bedingung wie '>9', '<9' oder '=10' eingetragen werden, um eine "
"Aktion auszulösen, wenn der Failcounter des Tokens einen entsprechenden Wert "
"hat. Bitte beachten Sie, dass der Failcounter nicht mehr erhöht wird, sobald "
"er den Maximalwert erreicht hat."

#: lib/eventhandler/base.py:285
msgid ""
"This condition can check any arbitrary tokeninfo field. You need to enter "
"something like '<fieldname> == <fieldvalue>', '<fieldname> > <fieldvalue>' "
"or '<fieldname> < <fieldvalue>'."
msgstr ""
"Diese Bedingung prüft beliebige Werte in der Tokeninfo. Zulässige Vergleiche "
"sind: '<Feldname> == <Feldinhalt>', '<Feldname> > <Feldinhalt>' oder "
"'<Feldname> < <Feldinhalt>'."

#: lib/eventhandler/base.py:293
msgid ""
"This condition can check the value of an arbitrary event counter and compare "
"it like 'myCounter == 1000', 'myCounter > 1000' or 'myCounter < 1000'."
msgstr ""
"Diese Bedingung überprüft einen beliebigen Eventcounter und vergleicht in "
"bspw. wie 'myCounter == 1000', 'myCounter > 1000' oder 'myCounter < 1000'."

#: lib/eventhandler/base.py:300
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->error->message in the response."
msgstr ""
"Hier können Sie einen regulären Ausdruck eingeben. Die Bedingung greift nur, "
"wenn der reguläre Ausdruck auf das Feld detail->error->message im HTTP "
"Response passt."

#: lib/eventhandler/base.py:307
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->message in the response."
msgstr ""
"Hier können Sie einen regulären Ausdruck eingeben. Die Bedingung greift nur, "
"wenn der reguläre Ausdruck auf das Feld detail->message im HTTP Response "
"passt."

#: lib/eventhandler/base.py:314
msgid "Trigger the action, if the client IP matches."
msgstr "Die Aktion wird ausgeführt, wenn die Client IP passt."

#: lib/eventhandler/counterhandler.py:69 lib/eventhandler/counterhandler.py:74
#: lib/eventhandler/counterhandler.py:82
msgid "The identifier/key of the counter."
msgstr "Die ID des Zählers."

#: lib/eventhandler/counterhandler.py:77
msgid "Don't stop counter if it reaches zero."
msgstr "Der Counter darf auch negative Werte erreichen."

#: lib/eventhandler/customuserattributeshandler.py:61
msgid "The user for whom the custom attribute should be set."
msgstr "Der Benutzer, für den das Attribut gesetzt werden soll."

#: lib/eventhandler/customuserattributeshandler.py:68
msgid "The key of the custom user attribute that should be set."
msgstr "Der Schlüssel des Attributes, das gesetzt werden soll."

#: lib/eventhandler/customuserattributeshandler.py:71
msgid "The value of the custom user attribute."
msgstr "Wert des benutzerdefinierten Benutzerattributs."

#: lib/eventhandler/customuserattributeshandler.py:77
msgid "The user from which the custom attribute should be deleted."
msgstr "Der Benutzer, dessen Attribut gelöscht werden soll."

#: lib/eventhandler/customuserattributeshandler.py:84
msgid "The key of the custom user attribute that should be deleted."
msgstr "Der Schlüssel des Attributes, das gelöscht werden soll."

#: lib/eventhandler/federationhandler.py:76
msgid "The remote/child privacyIDEA Server."
msgstr "Der entfernte privacyIDEA Server."

#: lib/eventhandler/federationhandler.py:81
msgid "Change the realm name to a realm on the child privacyIDEA system."
msgstr ""
"Der Realmname wird auf diesen Realmnamen auf dem entfernenten privacyIDEA "
"Server geändert."

#: lib/eventhandler/federationhandler.py:87
msgid "Change the resolver name to a resolver on the child privacyIDEA system."
msgstr ""
"Der Resolvername wird auf diesen Resolvernamen auf dem entfernten "
"privacyIDEA Server geändert."

#: lib/eventhandler/federationhandler.py:93
msgid ""
"Forward the client IP to the child privacyIDEA server. Otherwise this server "
"will be the client."
msgstr ""
"Die Client-IP wird an den entfernten privacyIDEA Server durchgereicht. "
"Ansonsten ist der lokale privacyIDEA Server der Client für den entfernten "
"Server."

#: lib/eventhandler/federationhandler.py:100
msgid ""
"Forward the authorization header. This allows to also forward request like "
"token- and system-requests."
msgstr ""
"Den HTML-Authorisierungsheader weiterleiten. So können bspw. auch Token- und "
"System-Requests weitergeleitet werden."

#: lib/eventhandler/logginghandler.py:87
msgid "The name of the logging facility"
msgstr "Der Name des Logging-Bereichs"

#: lib/eventhandler/logginghandler.py:93
msgid "The string to write to the log"
msgstr "Die Zeichenkette, die ins Log geschrieben werden soll"

#: lib/eventhandler/logginghandler.py:99
msgid "The logging level for this logging notification"
msgstr "Der Loglevel der Log-Benachrichtigung"

#: lib/eventhandler/requestmangler.py:100
msgid "The parameter that should be deleted."
msgstr "Der Parameter der gelöscht werden soll."

#: lib/eventhandler/requestmangler.py:106
msgid "The parameter that should be added or modified."
msgstr "Der Parameter der hinzugefügt oder verändert werden soll."

#: lib/eventhandler/requestmangler.py:111
msgid ""
"The new value of the parameter. Can contain tags like {0}, {1} for the "
"matched sub strings."
msgstr ""
"Der neue Wert des Parameters. Er kann Tags wie '{0}' oder '{1}' enthalten "
"entsprechend der passenden Teil-Zeichenfolge."

#: lib/eventhandler/requestmangler.py:116
msgid "The parameter, that should match some values."
msgstr "Der Parameter der mit einem Wert übereinstimmen soll."

#: lib/eventhandler/requestmangler.py:120
msgid ""
"The value of the match_parameter. It can contain a regular expression and "
"'()' to transfer values to the new parameter."
msgstr ""
"Der Wert von 'match_parameter'. Er kann einen regulären Ausdruck und '()' "
"enthalten um Werte auf den neuen Parameter zu übertragen."

#: lib/eventhandler/responsemangler.py:81
msgid ""
"The JSON pointer (key) that should be deleted. Please specify in the format "
"'/detail/message'."
msgstr ""
"Der JSON-Verweis (Schlüssel) welcher gelöscht werden soll. Bitte im Format '/"
"details/message' angeben."

#: lib/eventhandler/responsemangler.py:88
msgid ""
"The JSON pointer (key) that should be set. Please specify in the format '/"
"detail/message'."
msgstr ""
"Der JSON-Verweis (Schlüssel) welcher gesetzt werden soll. Bitte im Format '/"
"details/message' angeben."

#: lib/eventhandler/responsemangler.py:94
msgid "The type of the value."
msgstr "Der Typ des Wertes."

#: lib/eventhandler/responsemangler.py:100
msgid "The value of the JSON key that should be set."
msgstr "Wert des JSON Schlüssels, welcher gesetzt werden soll."

#: lib/eventhandler/scripthandler.py:96
#: lib/smsprovider/ScriptSMSProvider.py:123
msgid ""
"Wait for script to complete or run script in background. This will either "
"return the HTTP request early or could also block the request."
msgstr ""
"Auf das Ende des Skripts warten oder das Skript im Hintergrund ausführen. "
"Somit wird die HTTP-Antwort entweder direkt zurückgegeben oder das Skript "
"kann einen HTTP-Aufruf blockieren."

#: lib/eventhandler/scripthandler.py:104
msgid "On script error raise exception in HTTP request."
msgstr "Wenn das Skript einen Fehler hat, soll ein HTTP-Fehler erzeugt werden."

#: lib/eventhandler/scripthandler.py:108
msgid ""
"Finish current transaction before running the script. This is useful if "
"changes to the database should be made available to the script or the "
"running request."
msgstr ""
"Die aktuelle Datenbank-Transaktion wird beendet, bevor das Skript aufgerufen "
"wird. Dies kann notwendig sein, wenn Änderungen in der Datenbank dem Skript "
"oder dem Request verfügbar gemacht werden sollen."

#: lib/eventhandler/scripthandler.py:115
msgid "Add '--serial <serial number>' as script parameter."
msgstr "Nutze '--serial <serial number>' als Skript-Parameter."

#: lib/eventhandler/scripthandler.py:120
msgid "Add '--user <username>' as script parameter."
msgstr "Nutze '--user <username>' als Skript-Parameter."

#: lib/eventhandler/scripthandler.py:125
msgid "Add '--realm <realm>' as script parameter."
msgstr "Nutze '--realm <realm>' als Skript-Parameter."

#: lib/eventhandler/scripthandler.py:130
msgid ""
"Add the username of the logged in user as script parameter like '--"
"logged_in_user <username>'."
msgstr ""
"Nutze den Benutzernamen des angemeldeten Benutzers als Skript-Parameter '--"
"logged_in_user <username>'."

#: lib/eventhandler/scripthandler.py:136
msgid ""
"Add the role (either admin or user) of the logged in user as script "
"parameter like '--logged_in_role <role>'."
msgstr ""
"Nutze die Rolle des angemeldeten Benutzers als Skript-Parameter '--"
"logged_in_role <role>'."

#: lib/eventhandler/tokenhandler.py:139
msgid "set a new realm of the token"
msgstr "Setze einen neuen Token-Realm"

#: lib/eventhandler/tokenhandler.py:143
msgid ""
"The new realm will be the only realm of the token. I.e. all other realms "
"will be removed from this token. If disabled, the realm will be added to the "
"token."
msgstr ""
"Der neue Realm ist der einzige Realm des Tokens. D.h. alle anderen evtl. "
"zugeordneten Realms dieses Tokens werden gelöscht. Ist diese Option "
"deaktiviert, wird der Realm zu den vorhandenen Realms des Tokens hinzugefügt."

#: lib/eventhandler/tokenhandler.py:158
msgid "set the PIN of the token to a random PIN of this length."
msgstr "Setze die PIN des Tokens auf einen zufälligen Wert dieser Länge."

#: lib/eventhandler/tokenhandler.py:165
msgid "Token type to create"
msgstr "Tokentyp der angelegt werden soll"

#: lib/eventhandler/tokenhandler.py:170
msgid "Assign token to user in request or to tokenowner."
msgstr "Token dem Benutzer aus dem Request oder dem Tokenbesitzer zuweisen."

#: lib/eventhandler/tokenhandler.py:175
msgid "Set the realm of the newly created token."
msgstr "Realm des neu angelegten Tokens."

#: lib/eventhandler/tokenhandler.py:182
msgid "Dynamically read the mobile number from the user store."
msgstr "Die Mobil-Nummer wird dynamisch aus dem Benutzerverzeichnis gelesen."

#: lib/eventhandler/tokenhandler.py:189
msgid "Dynamically read the email address from the user store."
msgstr "Die Email-Adresse wird dynamisch aus dem Benutzerverzeichnis gelesen."

#: lib/eventhandler/tokenhandler.py:196
msgid "Use a specific SMTP server configuration for this token."
msgstr "Benutze eine spezifische SMTP Server Konfiguration für diesen Token."

#: lib/eventhandler/tokenhandler.py:203
msgid "Use a specific SMS gateway configuration for this token."
msgstr "Benutze eine spezifische SMS Gateway Konfiguration für diesen Token."

#: lib/eventhandler/tokenhandler.py:208
msgid "A dictionary of additional init parameters."
msgstr "Zusätzliche Parameter zum Ausrollen des Tokens."

#: lib/eventhandler/tokenhandler.py:214
msgid ""
"Set the MOTP PIN of the MOTP token during enrollment. This is a required "
"value for enrolling MOTP tokens."
msgstr ""
"Setze die MOTP PIN während des Rollout-Prozesses. MOTP Token benötigen eine "
"MOTP PIN."

#: lib/eventhandler/tokenhandler.py:223
msgid "The new description of the token."
msgstr "Die neue Beschreibung des Tokens."

#: lib/eventhandler/tokenhandler.py:230
msgid ""
"The token will be valid starting at the given date. Can be a fixed date or "
"an offset like +10m, +24h, +7d."
msgstr ""
"Der Token ist ab dem angegebenen Datum gültig. Dies kann ein fixes Datum "
"oder eine Differenz wie +10m, +24h, +7d (10 Minuten, 24 Stunden, 7 Tage) "
"sein."

#: lib/eventhandler/tokenhandler.py:237
msgid ""
"The token will be valid until the given date. Can be a fixed date or an "
"offset like +10m, +24h, +7d."
msgstr ""
"Der Token wird bis zu dem angegebenen Datum gültig sein. Dies kann ein fixes "
"Datum oder eine Differenz wie +10m, +24h, +7d sein (10 Minuten, 24 Stunden, "
"7 Tage)."

#: lib/eventhandler/tokenhandler.py:250
msgid "Set the new count window of the token."
msgstr "Das neue Zähler-Fenster des Tokens setzen."

#: lib/eventhandler/tokenhandler.py:260
msgid "Set the failcounter of the token."
msgstr "Setze den Fehlerzähler des Tokens."

#: lib/eventhandler/tokenhandler.py:270
msgid ""
"Increase or decrease the fail counter of the token. Values of +n, -n with n "
"being an integer are accepted."
msgstr ""
"Der Fehlerzähler wird inkrementiert oder dekrementiert. Werte +n und -n, "
"wobei n eine Zahl ist, werden akzeptiert."

#: lib/eventhandler/tokenhandler.py:280
msgid "Set the maximum failcounter of the token."
msgstr "Setze den maximalen Fehlerzähler des Tokens."

#: lib/eventhandler/tokenhandler.py:288
msgid "Set this tokeninfo key."
msgstr "Setze diesen Schlüssel in der Tokeninfo-Tabelle."

#: lib/eventhandler/tokenhandler.py:293
msgid "Set the above key to this value."
msgstr "Setze den oben genannten Schlüssel auf diesen Wert."

#: lib/eventhandler/tokenhandler.py:302
msgid "Delete this tokeninfo key."
msgstr "Diesen Tokeninfo-Eintrag löschen."

#: lib/eventhandler/tokenhandler.py:310
msgid "Add a tokengroup to the token."
msgstr "Füge dem Token eine Token-Gruppe hinzu."

#: lib/eventhandler/tokenhandler.py:319
msgid "Remove a tokengroup from the token."
msgstr "Entferne eine Token-Gruppe vom Token."

#: lib/eventhandler/tokenhandler.py:328
msgid "The ID of the machine you want to attach the token to"
msgstr ""
"Die Kennzeichnung der Maschine an die dieser Token angehängt werden soll"

#: lib/eventhandler/tokenhandler.py:334
msgid "Set the service_id for an SSH application."
msgstr "Legen Sie die Dienste-Kennzeichnung für eine SSH-Anwendung fest."

#: lib/eventhandler/tokenhandler.py:342
msgid ""
"Set a token application like 'offline' or 'SSH'. Note: Not all tokens work "
"well with all applications!"
msgstr ""
"Legen Sie eine Token-Anwendung wie \"offline\" oder \"SSH\" fest. Hinweis: "
"Nicht alle Token funktionieren mit allen Anwendungen gleichermaßen!"

#: lib/eventhandler/tokenhandler.py:351
msgid "The number of offline OTP values available"
msgstr "Die Anzahl der verfügbaren Offline-OTP-Werte"

#: lib/eventhandler/tokenhandler.py:359
msgid "The number of rounds for password hashing"
msgstr "Die Anzahl der Runden für das Passwort Hashing"

#: lib/eventhandler/usernotification.py:123
msgid "Send notification email via this email server."
msgstr "Benachrichtigungs-EMail über diesen Email-Server versenden."

#: lib/eventhandler/usernotification.py:127
msgid "Either send email as plain text or HTML."
msgstr "Sende Email als Text oder HTML."

#: lib/eventhandler/usernotification.py:131
msgid "Send QR-Code image as an attachment (cid URL: token_image)"
msgstr "Der QR-Code wird als Bild-Anhang versendet (cid URL: token_image)"

#: lib/eventhandler/usernotification.py:136
msgid "The subject of the mail that is sent."
msgstr "Die Betreffzeile der Email."

#: lib/eventhandler/usernotification.py:140
msgid "The Reply-To header in the sent email."
msgstr "Das Antworten-An Feld in der gesendeten EMail."

#: lib/eventhandler/usernotification.py:162
#: lib/eventhandler/usernotification.py:194
msgid "Any email address, to which the notification should be sent."
msgstr ""
"Eine EMail-Adresse, an welche die Benachrichtigung gesendet werden soll."

#: lib/eventhandler/usernotification.py:169
msgid "The body of the mail that is sent."
msgstr "Der Textkörper der EMail."

#: lib/eventhandler/usernotification.py:173
#: lib/eventhandler/usernotification.py:211
msgid "Send notification to this user."
msgstr "Benachrichtigung an diesen Benutzer senden."

#: lib/eventhandler/usernotification.py:203
msgid "Send the user notification via a predefined SMS gateway."
msgstr "Benutzerbenachrichtigung über dieses SMS-Gateway schicken."

#: lib/eventhandler/usernotification.py:208
msgid "The text of the SMS."
msgstr "Der Text der SMS."

#: lib/eventhandler/usernotification.py:218
msgid ""
"This is the template content of the new file. Can contain the tags as "
"specified in the documentation."
msgstr ""
"Dies ist die Vorlage für die neue Datei. Sie kann die in der Dokumentation "
"spezifizierten Tags enthalten."

#: lib/eventhandler/usernotification.py:224
msgid ""
"The filename of the notification. Existing files are overwritten. The name "
"can contain tags as specified in the documentation and can also contain the "
"tag {random}."
msgstr ""
"Der Name der Benachrichtigungs-Datei. Vorhandene Dateien werden "
"überschrieben. Der Name kann die in der Dokumentation spezifizierten Tags "
"enthalten, und auch den Tag '{random}'."

#: lib/eventhandler/webhookeventhandler.py:86
msgid "The URL the WebHook is posted to"
msgstr "Die URL, an die der WebHook gesendet wird"

#: lib/eventhandler/webhookeventhandler.py:91
msgid "The encoding that is sent to the WebHook, for example json"
msgstr "Das Format, welches an den WebHook gesendet wird, beispielsweise json"

#: lib/eventhandler/webhookeventhandler.py:99
msgid "You can replace placeholder like {logged_in_user}"
msgstr "Sie können Platzhalter wie {logged_in_user} benutzen"

#: lib/eventhandler/webhookeventhandler.py:104
msgid "The data posted in the WebHook"
msgstr "Die an den WebHook gesendeten Daten"

#: lib/machines/ldap.py:338
#, python-format
msgid "Your LDAP config seems to be OK, %i machine objects found."
msgstr ""
"Die LDAP-Konfiguration scheint in Ordnung zu sein. Es wurden %i Maschinen-"
"Objekte gefunden."

#: lib/resolvers/LDAPIdResolver.py:1130
msgid ""
"Your LDAP config found {0!s} user objects, but only {1!s} with the specified "
"uidtype"
msgstr ""
"Für die LDAP-Konfiguration wurden {0!s} Benutzerobjekte gefunden, aber "
"lediglich {1!s} mit dem angegebenen UID Typ"

#: lib/resolvers/LDAPIdResolver.py:1133
msgid "Your LDAP config seems to be OK, {0!s} user objects found."
msgstr ""
"Die LDAP-Konfiguration scheint in Ordnung zu sein. Es wurden {0!s} "
"Benutzerobjekte gefunden."

#: lib/smsprovider/FirebaseProvider.py:201
msgid ""
"The filename of the JSON config file, that allows privacyIDEA to talk to the "
"Firebase REST API."
msgstr ""
"Der Name (mit Pfad) der JSON Config Datei. Diese ermöglicht privacyIDEA mit "
"der Firebase REST API zu kommunizieren."

#: lib/smsprovider/FirebaseProvider.py:206
msgid "Proxy setting for HTTPS connections to googleapis.com."
msgstr "Proxy-Einstellungen für die HTTPS-Verbindung zu googleapis.com."

#: lib/smsprovider/HttpSMSProvider.py:244
msgid "The base URL of the HTTP Gateway"
msgstr "Die Basis URL des HTTP Gateways"

#: lib/smsprovider/HttpSMSProvider.py:247
msgid "Should the HTTP Gateway be connected via an HTTP GET or POST request."
msgstr "Das Gateway wird mittels GET oder POST-Request angesprochen."

#: lib/smsprovider/HttpSMSProvider.py:252
msgid ""
"Specify a substring, that indicates, that the SMS was delivered successfully."
msgstr ""
"Ein Substring in der Antwort, der angibt, ob die SMS erfolgreich zugestellt "
"wurde."

#: lib/smsprovider/HttpSMSProvider.py:256
msgid ""
"Specify a substring, that indicates, that the SMS failed to be delivered."
msgstr ""
"Ein Substring in der Antwort, der angibt, ob die SMS nicht zugestellt werden "
"konnte."

#: lib/smsprovider/HttpSMSProvider.py:260
msgid "Username in case of basic authentication."
msgstr "Benutzername (Basic Authentication)."

#: lib/smsprovider/HttpSMSProvider.py:264
msgid "Password in case of basic authentication."
msgstr "Passwort (Basic Authentication)."

#: lib/smsprovider/HttpSMSProvider.py:269
msgid "Should the SSL certificate be verified."
msgstr "Das SSL-Zertifikat wird überprüft."

#: lib/smsprovider/HttpSMSProvider.py:275
msgid "Should the data in a POST Request be sent as JSON."
msgstr "Sollen die Daten in einer POST-Anfrage als JSON gesendet werden."

#: lib/smsprovider/HttpSMSProvider.py:282
msgid ""
"An optional proxy string. DEPRECATED. Do not use this anymore. Rather use "
"HTTP_PROXY for http connections and HTTPS_PROXY for https connection. The "
"PROXY option will be removed in future."
msgstr ""
"Eine optional PROXY Konfiguration. (VERALTET). Bitte benutzen Sie diese "
"Einstellung nicht mehr, sie wird in der Zukunft entfernt werden. Benutzen "
"Sie bitte HTTP_PROXY für HTTP-Verbindungen und HTTPS_PROXY für HTTPS-"
"Verbindungen."

#: lib/smsprovider/HttpSMSProvider.py:287
msgid "Proxy setting for HTTP connections."
msgstr "Proxy-Einstellung für HTTP-Verbindungen."

#: lib/smsprovider/HttpSMSProvider.py:288
msgid "Proxy setting for HTTPS connections."
msgstr "Proxy-Einstellung für HTTPS-Verbindungen."

#: lib/smsprovider/HttpSMSProvider.py:289
msgid "The timeout in seconds."
msgstr "Timeout in Sekunden."

#: lib/smsprovider/SMSProvider.py:76
msgid ""
"Regular expression to modify the phone number to make it compatible with "
"provider. For example to remove pluses and slashes enter something like '/[\\"
"+/]//'."
msgstr ""
"Ein regulärer Ausdruck, der die Telefonnummer verändert. Dies ist nützlich, "
"wenn Provider manche Zeichen in der Telefonnummer nicht erlauben. Geben Sie "
"z.B. '/[\\+/]//' ein, um Plus-Zeichen und Schrägstriche zu entfernen."

#: lib/smsprovider/ScriptSMSProvider.py:115
msgid ""
"The script in script directory PI_SCRIPT_SMSPROVIDER_DIRECTORY to call. "
"Expects phone as the parameter and the message from stdin."
msgstr ""
"Das Skript, das aus dem Skripte-Verzeichnis PI_SCRIPT_SMSPROVIDER_DIRECTORY "
"aufgerufen werden soll. Dieses Skript erhält die Telefonnummer als Parameter "
"und die Nachricht über Stdin."

#: lib/smsprovider/SmppSMSProvider.py:127
msgid "SMSC Host IP"
msgstr "SMSC IP Adresse"

#: lib/smsprovider/SmppSMSProvider.py:130
msgid "SMSC Port"
msgstr "SMSC Port"

#: lib/smsprovider/SmppSMSProvider.py:132
msgid "SMSC Service ID"
msgstr "Service ID, mit dem sich privacyIDEA beim SMSC meldet"

#: lib/smsprovider/SmppSMSProvider.py:134
msgid "Password for authentication on SMSC"
msgstr "Das Passwort, mit dem sich privacyIDEA am SMSC authentisiert"

#: lib/smsprovider/SmppSMSProvider.py:136
msgid "SOURCE_ADDR_TON Special Flag"
msgstr "Code des Nummerntyps des Senders. Wird vom SMSC Operator mitgeteilt"

#: lib/smsprovider/SmppSMSProvider.py:138
msgid "S_ADDR_NPI Special Flag"
msgstr "Code des Nummernplans des Senders. Wird vom SMSC Operator mitgeteilt"

#: lib/smsprovider/SmppSMSProvider.py:140
msgid "Source address (SMS sender)"
msgstr "Absender-Telefonnummer"

#: lib/smsprovider/SmppSMSProvider.py:141
msgid "DESTINATION_ADDR_TON Special Flag"
msgstr "Code des Nummertyps des Empfängers. Wird vom SMSC Operator mitgeteilt"

#: lib/smsprovider/SmppSMSProvider.py:142
msgid "D_ADDR_NPI Special Flag"
msgstr ""
"Code des Nummernplans des Empfängers. Wird vom SMSC Operator mitgeteilt"

#: lib/task/eventcounter.py:42
msgid "The name of the event counter to read."
msgstr "Der Name des Eventzählers, der gelesen wird."

#: lib/task/eventcounter.py:47
msgid "The name of the stats key to write to the MonitoringStats table."
msgstr ""
"Der Name des Statistikschlüssels, der in die Monitoring-Tabelle geschrieben "
"wird."

#: lib/task/eventcounter.py:53
msgid ""
"Whether to reset the event_counter, if it is read and written to the "
"MonitoringStats table."
msgstr ""
"Eventzähler zurücksetzen, wenn der Wert gelesen und in die Monitoring-"
"Tabelle geschrieben wird."

#: lib/task/simplestats.py:48
msgid "Total number of tokens"
msgstr "Anzahl aller Token"

#: lib/task/simplestats.py:51
msgid "Total number of hardware tokens"
msgstr "Anzahl aller Hardware-Token"

#: lib/task/simplestats.py:54
msgid "Total number of software tokens"
msgstr "Anzahl aller Software-Token"

#: lib/task/simplestats.py:57
msgid "Number of hardware tokens not assigned to a user"
msgstr "Anzahl der Hardware-Token, die keinem Benutzer zugewiesen sind"

#: lib/task/simplestats.py:60
msgid "Number of tokens assigned to users"
msgstr "Anzahl der Benutzern zugewiesenen Token"

#: lib/task/simplestats.py:63
msgid "Number of users with tokens assigned"
msgstr "Anzahl der Benutzer mit zugewiesenen Token"

#: lib/tokens/applicationspecificpasswordtoken.py:76
msgid ""
"Application Specific Password: A token with a fixed password. Can be used "
"for certain applications or services."
msgstr ""
"Anwendungsspezifisches Passwort: Ein Token mit einem festen Passwort. Kann "
"für bestimmte Anwendungen oder Dienste verwendet werden."

#: lib/tokens/applicationspecificpasswordtoken.py:87
msgid ""
"The user may only have this maximum number of application specific password "
"tokens assigned."
msgstr ""
"Dem Benutzer darf nur diese maximale Anzahl von anwendungsspezifischen "
"Passwort-Tokens zugewiesen werden."

#: lib/tokens/applicationspecificpasswordtoken.py:93
msgid ""
"The user may only have this maximum number of active application specific "
"password tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven anwendungsspezifischen "
"Password-Token zugewiesen haben."

#: lib/tokens/certificatetoken.py:282
msgid "Certificate: Enroll an x509 Certificate Token."
msgstr "Certificate: Ein x509 Zertifikats-Token ausrollen."

#: lib/tokens/certificatetoken.py:293
msgid "The user may only have this maximum number of certificates assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Zertifikaten zugewiesen haben."

#: lib/tokens/certificatetoken.py:298
msgid ""
"The user may only have this maximum number of active certificates assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Zertifikaten "
"zugewiesen haben."

#: lib/tokens/certificatetoken.py:303
msgid ""
"Enrolling a certificate token can require an attestation certificate. "
"(Default: ignore)"
msgstr ""
"Das Ausrollen eines Zertifikats erfordert ein Attestation Zertifikat. "
"(Standard: \"ignore\")"

#: lib/tokens/certificatetoken.py:312
msgid "The CA connector that should be used during certificate enrollment."
msgstr ""
"Der CA-Konnektor welcher für die Zertifikatserstellung genutzt werden soll."

#: lib/tokens/certificatetoken.py:318
msgid "The template that should be used to issue a certificate."
msgstr ""
"Die Zertifikatsvorlage die für das Ausstellen von Zertifikaten genutzt "
"werden soll."

#: lib/tokens/certificatetoken.py:323
msgid ""
"This takes a space separated list of elements to be added to the subject. "
"Can be 'email' and 'realm'."
msgstr ""
"Eine durch Leerzeichen getrennte Liste von Elementen, die dem Subjekt des "
"Zertifikats hinzugefügt werden. Mögliche Elemente sind 'email' und 'realm'."

#: lib/tokens/certificatetoken.py:331 lib/tokens/certificatetoken.py:338
msgid "The directory containing attestation certificate chains."
msgstr ""
"Das Verzeichnis, in dem die Zertifikatsketten der Attestation Zertifikate "
"liegen."

#: lib/tokens/daplugtoken.py:124
msgid "event based OTP token using the HOTP algorithm"
msgstr "Ereignisbasiertes Einmalpasswort auf Basis des HOTP Algorithmus"

#: lib/tokens/daplugtoken.py:130
msgid "The user may only have this maximum number of daplug tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an DAPlug Token zugewiesen haben."

#: lib/tokens/daplugtoken.py:135
msgid ""
"The user may only have this maximum number of active daplug tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven DAPlug Token "
"zugewiesen haben."

#: lib/tokens/daypasswordtoken.py:36
msgid "Specify the time step of the DayPassword token."
msgstr "Geben Sie den Zeitschritt für das DayPassword-Token an."

#: lib/tokens/daypasswordtoken.py:84
msgid ""
"DayPassword: A time-based token with a variable timestep and the possibility "
"to use the OTP more than once."
msgstr ""
"DayPassword: Ein zeit-basierter Token mit einem variablen Zeitschritt und "
"der Möglichkeit, den OTP-Wert mehr als einmal zu verwenden."

#: lib/tokens/daypasswordtoken.py:121 lib/tokens/hotptoken.py:176
#: lib/tokens/totptoken.py:161
msgid "Enforce setting an app pin for the privacyIDEA Authenticator App"
msgstr ""
"Erzwingt das Setzen einer Token-PIN in der privacyIDEA Authenticator App"

#: lib/tokens/daypasswordtoken.py:126
msgid ""
"The user may only have this maximum number of daypassword tokens assigned."
msgstr ""
"Dem Benutzer darf nur diese maximale Anzahl von DayPasswort-Tokens "
"zugewiesen werden."

#: lib/tokens/daypasswordtoken.py:132
msgid ""
"The user may only have this maximum number of active daypassword tokens "
"assigned."
msgstr ""
"Dem Benutzer darf nur diese maximale Anzahl von aktiven DayPassword-Tokens "
"zugewiesen werden."

#: lib/tokens/emailtoken.py:156
msgid "EMail Token"
msgstr "EMail Token"

#: lib/tokens/emailtoken.py:158
msgid "EMail: Send a One Time Password to the users email address."
msgstr ""
"E-Mail: Ein Einmalpasswort an die E-Mail-Adresse des Benutzers versenden."

#: lib/tokens/emailtoken.py:166
msgid ""
"The text that will be sent via EMail for an EMail-token. Several tags like "
"{otp} and {serial} can be used as parameters. You may also specify a "
"filename as email template starting with \"file:\"."
msgstr ""
"Der Text der beim EMail-Token via EMail versendet wird. Sie können die "
"Schlagworte {otp} und {serial} als Parameter verwenden. Alternativ können "
"Sie eine EMail-Vorlage als Datei verwenden indem Sie den Dateinamen mit "
"\"file:\" angeben."

#: lib/tokens/emailtoken.py:173
msgid ""
"The subject of the EMail for an EMail token. Use tags like {otp} and "
"{serial} as parameters."
msgstr ""
"Die Betreff-Zeile der EMail eines EMail-Tokens. Es können die Schlagworte "
"{otp} und {serial} verwendet werden."

#: lib/tokens/emailtoken.py:178
msgid ""
"If set, a new EMail OTP will be sent after successful authentication with "
"one EMail OTP."
msgstr ""
"Ein neues Einmalpasswort wird per Email versendet, direkt nachdem sich der "
"Benutzer mit dem Einmalpasswort aus der letzten Email angemeldet hat."

#: lib/tokens/emailtoken.py:183
msgid ""
"Use an alternate challenge text for telling the user to enter the code from "
"the eMail."
msgstr ""
"Ein alternativer Challenge-Text, um den Benutzer aufzufordern, den Code aus "
"der Email einzugeben."

#: lib/tokens/emailtoken.py:190
msgid "The user may only have this maximum number of email tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Email Token zugewiesen haben."

#: lib/tokens/emailtoken.py:195
msgid ""
"The user may only have this maximum number of active email tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Email Token zugewiesen "
"haben."

#: lib/tokens/emailtoken.py:277
msgid "Enter the OTP from the Email:"
msgstr "Bitte geben Sie das Einmalpasswort aus der Email ein:"

#: lib/tokens/emailtoken.py:316
msgid "The PIN was correct, but the EMail could not be sent!"
msgstr "Die PIN ist korrekt aber die EMail konnte nicht gesendet werden!"

#: lib/tokens/emailtoken.py:547
msgid "Please enter your new email address!"
msgstr "Bitte geben Sie Ihre neue Email-Adresse ein!"

#: lib/tokens/foureyestoken.py:132
msgid "4Eyes Token: Use tokens of two or more users to authenticate"
msgstr ""
"Vier-Augen-Token: Zwei oder mehr Personen müssen zusammenkommen, damit sich "
"ein Account anmelden kann"

#: lib/tokens/foureyestoken.py:143
msgid "The user may only have this maximum number of 4eyes tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an 4-Augen-Token zugewiesen haben."

#: lib/tokens/foureyestoken.py:148
msgid ""
"The user may only have this maximum number of active 4eyes tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven 4-Augen-Token "
"zugewiesen haben."

#: lib/tokens/hotptoken.py:85
msgid "Please enter a valid OTP value of the new token."
msgstr "Bitte geben Sie einen gültigen OTP-Wert des neuen Tokens ein."

#: lib/tokens/hotptoken.py:100
msgid "Specify the hashing function to be used. Can be SHA1, SHA256 or SHA512."
msgstr ""
"Der zu verwendende Hash-Algorithmus. Möglich sind SHA-1, SHA-256 oder "
"SHA-512."

#: lib/tokens/hotptoken.py:102
msgid "Specify the OTP length to be used. Can be 6 or 8 digits."
msgstr "Die Länge des OTPs. Möglich sind entweder 6 oder 8 Zeichen."

#: lib/tokens/hotptoken.py:103
msgid "Force the key to be generated on the server."
msgstr "Den Key auf dem Server generieren."

#: lib/tokens/hotptoken.py:104
msgid "Specify whether users are allowed or forced to use two-step enrollment."
msgstr "Benutzer dürfen oder müssen den Zwei-Schritt-Rollout verwenden."

#: lib/tokens/hotptoken.py:106
msgid ""
"Specify whether admins are allowed or forced to use two-step enrollment."
msgstr "Administratoren dürfen oder müssen den Zwei-Schritt-Rollout verwenden."

#: lib/tokens/hotptoken.py:143
msgid "HOTP: Event based One Time Passwords."
msgstr "HOTP: Ereignisbasiertes Einmalpasswort."

#: lib/tokens/hotptoken.py:151
msgid "The user may only have this maximum number of HOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an HOTP Token zugewiesen haben."

#: lib/tokens/hotptoken.py:156
msgid ""
"The user may only have this maximum number of active HOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven HOTP Token zugewiesen "
"haben."

#: lib/tokens/hotptoken.py:161 lib/tokens/totptoken.py:150
msgid "The size of the OTP seed part contributed by the client (in bytes)"
msgstr "Die Größe des Smartphone-Anteils (in Byte)"

#: lib/tokens/hotptoken.py:166 lib/tokens/totptoken.py:153
msgid "The size of the OTP seed part contributed by the server (in bytes)"
msgstr "Die Große des Server-Anteils (in Byte)"

#: lib/tokens/hotptoken.py:171 lib/tokens/totptoken.py:156
msgid ""
"The difficulty factor used for the OTP seed generation (should be at least "
"10000)"
msgstr ""
"Die Schweregrad zur Generierung des OTP Seeds. (Sollte wenigstens 10000 sein)"

#: lib/tokens/hotptoken.py:282
msgid "URL for google Authenticator"
msgstr "URL für Google Authenticator und vergleichbare Apps"

#: lib/tokens/hotptoken.py:295
msgid "URL for OATH token"
msgstr "URL für OATH Token"

#: lib/tokens/hotptoken.py:827 lib/tokens/pushtoken.py:1048
msgid "Please scan the QR code!"
msgstr "Bitte scannen Sie den QR-Code!"

#: lib/tokens/indexedsecrettoken.py:51
msgid "Please enter the positions {0!s} from your secret."
msgstr "Bitte geben Sie die Positionen {0!s} Ihres Geheimnisses ein."

#: lib/tokens/indexedsecrettoken.py:100
msgid "Indexed Secret Token"
msgstr "Indexed Secret Token"

#: lib/tokens/indexedsecrettoken.py:102
msgid ""
"IndexedSecret: Request certain positions of a shared secret from the user."
msgstr ""
"IndexedSecret: Fordert zufällige Positionen von einer geheimen Zeichenkette "
"vom Benutzer."

#: lib/tokens/indexedsecrettoken.py:109
msgid ""
"Use an alternate challenge text for telling the user which positions of the "
"secret he should enter."
msgstr ""
"Benutzen Sie einen alternativen Text, um den Benutzer zur Eingabe der "
"zufälligen Positionen aufzufordern."

#: lib/tokens/indexedsecrettoken.py:115
msgid "Number of necessary positions to be answered by the user."
msgstr "Die Anzahl der notwendigen Positionen, die der Benutzer eingeben muss."

#: lib/tokens/indexedsecrettoken.py:122
msgid "Preset the enrollment with the value of the given attribute."
msgstr ""
"Der Wert der folgenden Benutzerattributes als Voreinstellung verwenden."

#: lib/tokens/indexedsecrettoken.py:129 lib/tokens/indexedsecrettoken.py:136
msgid "The attribute whose value should be force set during enrollment."
msgstr ""
"Das Attribute, dessen Wert zwingend, automatisch beim Ausrollen gesetzt wird."

#: lib/tokens/indexedsecrettoken.py:143
msgid ""
"The user may only have this maximum number of indexed secret tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an IndexedSecret Token zugewiesen "
"haben."

#: lib/tokens/indexedsecrettoken.py:148
msgid ""
"The user may only have this maximum number of active indexed secret tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven IndexedSecret Token "
"zugewiesen haben."

#: lib/tokens/motptoken.py:105
msgid "The user may only have this maximum number of mOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an mOTP Token zugewiesen haben."

#: lib/tokens/motptoken.py:110
msgid ""
"The user may only have this maximum number of active mOTP tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven mOTP Token zugewiesen "
"haben."

#: lib/tokens/motptoken.py:153
msgid "URL for MOTP token"
msgstr "URL für MOTP Token"

#: lib/tokens/ocratoken.py:91
msgid "OCRA: Enroll an OCRA token."
msgstr "OCRA: Einen OCRA-Token ausrollen."

#: lib/tokens/ocratoken.py:101
msgid "The user may only have this maximum number of OCRA tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an OCRA Token zugewiesen haben."

#: lib/tokens/ocratoken.py:106
msgid ""
"The user may only have this maximum number of active OCRA tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven OCRA Token zugewiesen "
"haben."

#: lib/tokens/papertoken.py:109 lib/tokens/tantoken.py:107
msgid "The number of OTP values, which are printed on the paper."
msgstr "Anzahl der gedruckten OTP-Werte."

#: lib/tokens/papertoken.py:114
msgid "The user may only have this maximum number of paper tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Paper Token zugewiesen haben."

#: lib/tokens/papertoken.py:119
msgid ""
"The user may only have this maximum number of active paper tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Paper Token zugewiesen "
"haben."

#: lib/tokens/passwordtoken.py:115
msgid ""
"A token with a fixed password. Can be combined  with the OTP PIN. Is used "
"for the lost token scenario."
msgstr ""
"Ein Token mit einem festen Passwort. Dieses kann mit der OTP PIN verwendet "
"werden. Wir im Workflow \"Verlorener Token\" verwendet."

#: lib/tokens/passwordtoken.py:127
msgid "The user may only have this maximum number of password tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Password Token zugewiesen "
"haben."

#: lib/tokens/passwordtoken.py:132
msgid ""
"The user may only have this maximum number of active password tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Password Token "
"zugewiesen haben."

#: lib/tokens/pushtoken.py:71
msgid "Please confirm the authentication on your mobile device!"
msgstr "Bitte bestätigen Sie die Anmeldung auf Ihrem Mobilgerät!"

#: lib/tokens/pushtoken.py:72
msgid ""
"Use the polling feature of your privacyIDEA Authenticator App to check for a "
"new Login request."
msgstr ""
"Verwenden Sie die Polling-Funktion Ihrer privacyIDEA Authenticator App, um "
"nach einer neuen Anmeldeanfrage zu suchen."

#: lib/tokens/pushtoken.py:74
msgid "Do you want to confirm the login?"
msgstr "Wollen Sie die Anmeldung bestätigen?"

#: lib/tokens/pushtoken.py:300
msgid "PUSH Token"
msgstr "PUSH Token"

#: lib/tokens/pushtoken.py:302
msgid "PUSH: Send a push notification to a smartphone."
msgstr "PUSH: Sendet eine Push Nachricht an ein Smartphone."

#: lib/tokens/pushtoken.py:310
msgid "The configuration of your Firebase application."
msgstr "Die Konfiguration der Firebase Anwendung."

#: lib/tokens/pushtoken.py:318
msgid ""
"The URL the Push App should contact in the second enrollment step. Usually "
"it is the endpoint /ttype/push of the privacyIDEA server."
msgstr ""
"Die URL für den zweiten Ausrollschritt. Diese URL ruft das Smartphone auf, "
"nachdem der Benutzer den QR-Code gescannt hat. Üblicherweise ist das der "
"Endpunkt /ttype/push des privacyIDEA Servers."

#: lib/tokens/pushtoken.py:324
msgid ""
"The second enrollment step must be completed within this time (in minutes)."
msgstr ""
"Der zweite Rollout-Schritt muss innerhalb dieser Zeit abgeschlossen sein (in "
"Minuten)."

#: lib/tokens/pushtoken.py:328
msgid "The smartphone needs to verify SSL during the enrollment. (default 1)"
msgstr ""
"Das Smartphone überprüft die SSL-Verbindung während des Rollouts. (Standard: "
"1)"

#: lib/tokens/pushtoken.py:334
msgid "The user may only have this maximum number of Push tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Push Token zugewiesen haben."

#: lib/tokens/pushtoken.py:339
msgid ""
"The user may only have this maximum number of active Push tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Push Token zugewiesen "
"haben."

#: lib/tokens/pushtoken.py:345
msgid "Require to unlock the Smartphone before Push requests can be accepted"
msgstr ""
"Das Smartphone muss entsperrt werden, bevor Push-Anfragen akzeptiert werden "
"können"

#: lib/tokens/pushtoken.py:351
msgid "The question the user sees on his mobile phone."
msgstr "Die Frage, die der Benutzer auf seinem Mobilgerät angezeigt bekommt."

#: lib/tokens/pushtoken.py:356
msgid "The title of the notification, the user sees on his mobile phone."
msgstr ""
"Die Überschrift, die der Benutzer auf seinem Mobilgerät angezeigt bekommt."

#: lib/tokens/pushtoken.py:361
msgid "The smartphone needs to verify SSL during authentication. (default 1)"
msgstr ""
"Das Smartphone überprüft die SSL-Verbindung während des Anmeldevorgangs. "
"(Standard: 1)"

#: lib/tokens/pushtoken.py:367
msgid ""
"Wait for number of seconds for the user to confirm the challenge in the "
"first request."
msgstr ""
"Der Benutzer hat die Anzahl an Sekunden Zeit, um die Challenge in der ersten "
"Anfrage zu beantworten."

#: lib/tokens/pushtoken.py:373
msgid "Configure whether to allow push tokens to poll for challenges"
msgstr ""
"Push Token können den privacyIDEA Server nach "
"Authentifizierungsanforderungen abfragen"

#: lib/tokens/pushtoken.py:508
msgid "URL for privacyIDEA Push Token"
msgstr "URL des privacyIDEA Push Tokens"

#: lib/tokens/questionnairetoken.py:98
msgid "Questionnaire: Enroll Questions for the user."
msgstr "Fragenkatalog: Einen Fragenkatalog-Token ausrollen."

#: lib/tokens/questionnairetoken.py:109
msgid "The user has to answer this number of questions during authentication."
msgstr ""
"Der Benutzer muss während der Authentifizierung dies Anzahl an Fragen "
"beantworten."

#: lib/tokens/questionnairetoken.py:117
msgid ""
"The user may only have this maximum number of questionaire tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Fragenkatalog Token zugewiesen "
"haben."

#: lib/tokens/questionnairetoken.py:122
msgid ""
"The user may only have this maximum number of active questionaire tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Fragenkatalog Token "
"zugewiesen haben."

#: lib/tokens/questionnairetoken.py:166
#, python-format
msgid "You need to provide at least %s answers."
msgstr "Sie müssen wenigstens %s Antworten angeben."

#: lib/tokens/radiustoken.py:108
msgid "RADIUS: Forward authentication request to a RADIUS server."
msgstr ""
"RADIUS: Die Authentifizierungsanfrage an einen RADIUS-Server weiterleiten."

#: lib/tokens/radiustoken.py:117
msgid "The user may only have this maximum number of RADIUS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an RADIUS Token zugewiesen haben."

#: lib/tokens/radiustoken.py:122
msgid ""
"The user may only have this maximum number of active RADIUS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven RADIUS Token "
"zugewiesen haben."

#: lib/tokens/registrationtoken.py:129
msgid ""
"Registration: A token that creates a registration code that can be used as a "
"second factor once."
msgstr ""
"Registrierung: Ein Token, der einen Registrierungs-Code erzeugt, den der "
"Benutzer einmal verwenden kann."

#: lib/tokens/registrationtoken.py:141
msgid ""
"The user may only have this maximum number of registration tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Registrierungs-Token "
"zugewiesen haben."

#: lib/tokens/registrationtoken.py:146
msgid ""
"The user may only have this maximum number of active registration tokens "
"assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Registrierungs-Token "
"zugewiesen haben."

#: lib/tokens/remotetoken.py:114
msgid "Remote Token: Forward authentication request to another server."
msgstr ""
"Remote Token: Die Authentifizierungsanfrage an einen anderen privacyIDEA "
"Server weiterleiten."

#: lib/tokens/remotetoken.py:123 lib/tokens/totptoken.py:166
msgid "The user may only have this maximum number of remote tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Remote Token zugewiesen haben."

#: lib/tokens/remotetoken.py:128 lib/tokens/totptoken.py:171
msgid ""
"The user may only have this maximum number of active remote tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Remote Token "
"zugewiesen haben."

#: lib/tokens/smstoken.py:200
msgid "SMS Token"
msgstr "SMS Token"

#: lib/tokens/smstoken.py:202
msgid "SMS: Send a One Time Password to the users mobile phone."
msgstr ""
"SMS: Ein Einmalpasswort per SMS an das Mobiltelefon des Benutzers senden."

#: lib/tokens/smstoken.py:211
msgid ""
"The text that will be send via SMS for an SMS token. Use tags like {otp} and "
"{serial} as parameters."
msgstr ""
"Der Text der als SMS für ein SMS-Token versendet wird. Es können die "
"Schlagwörter {otp} und {serial} verwendet werden."

#: lib/tokens/smstoken.py:216
msgid ""
"If set, a new SMS OTP will be sent after successful authentication with one "
"SMS OTP."
msgstr ""
"Ein neues Einmalpasswort wird direkt gesendet, nachdem sich der Benutzer "
"erfolgreich mit dem bisherigen Einmalpasswort aus der letzten SMS "
"authentisiert hat."

#: lib/tokens/smstoken.py:221
msgid ""
"Use an alternate challenge text for telling the user to enter the code from "
"the SMS."
msgstr ""
"Ein alternativer Challenge-Text, um den Benutzer aufzufordern, der Code aus "
"der SMS einzugeben."

#: lib/tokens/smstoken.py:229
msgid "Choose the gateways the administrator is allowed to set."
msgstr "Die Gateways, die der Administrator verwenden darf."

#: lib/tokens/smstoken.py:237
msgid "Choose the gateways the user is allowed to set."
msgstr "Die Gateways, die der Benutzer verwenden darf."

#: lib/tokens/smstoken.py:244
msgid "The user may only have this maximum number of SMS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an SMS Token zugewiesen haben."

#: lib/tokens/smstoken.py:249
msgid ""
"The user may only have this maximum number of active SMS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven SMS Token zugewiesen "
"haben."

#: lib/tokens/smstoken.py:326
msgid "Enter the OTP from the SMS:"
msgstr "Bitte geben Sie das Einmalpasswort aus der SMS ein:"

#: lib/tokens/smstoken.py:357
msgid "The PIN was correct, but the SMS could not be sent!"
msgstr "Die PIN ist korrekt aber die SMS konnte nicht gesendet werden!"

#: lib/tokens/smstoken.py:605
msgid "Please enter your new phone number!"
msgstr "Bitte geben Sie Ihre neue Telefonnummer ein!"

#: lib/tokens/spasstoken.py:88
msgid "SPass: Simple Pass token. Static passwords."
msgstr ""
"SPass: Simple Pass Token. Der zweite Faktor entfällt. Authentisierung nur "
"mit OTP PIN."

#: lib/tokens/spasstoken.py:100
msgid "The user may only have this maximum number of SPASS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an SPASS Token zugewiesen haben."

#: lib/tokens/spasstoken.py:105
msgid ""
"The user may only have this maximum number of active SPASS tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven SPASS Token zugewiesen "
"haben."

#: lib/tokens/sshkeytoken.py:84
msgid "SSH Public Key: The public SSH key."
msgstr "SSH Public Key: Der öffentliche SSH-Schlüssel."

#: lib/tokens/sshkeytoken.py:93
msgid "The user may only have this maximum number of SSH keys assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an SSH Schlüsseln zugewiesen "
"haben."

#: lib/tokens/sshkeytoken.py:98
msgid "The user may only have this maximum number of active SSH keys assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven SSH Schlüsseln "
"zugewiesen haben."

#: lib/tokens/tantoken.py:112
msgid "The user may only have this maximum number of TAN tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an TAN Token zugewiesen haben."

#: lib/tokens/tantoken.py:117
msgid ""
"The user may only have this maximum number of active TAN tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven TAN Token zugewiesen "
"haben."

#: lib/tokens/tiqrtoken.py:158
msgid "TiQR: Enroll a TiQR token."
msgstr "TiQR: Einen TiQR-Token ausrollen."

#: lib/tokens/tiqrtoken.py:168
msgid "The user may only have this maximum number of TiQR tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an TiQR Token zugewiesen haben."

#: lib/tokens/tiqrtoken.py:173
msgid ""
"The user may only have this maximum number of active TiQR tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven TiQR Token zugewiesen "
"haben."

#: lib/tokens/tiqrtoken.py:238
msgid "URL for TiQR enrollment"
msgstr "URL zum Ausrollen des TiQR Token"

#: lib/tokens/tiqrtoken.py:395
msgid "Please scan the QR Code"
msgstr "Bitte scannen Sie den QR-Code"

#: lib/tokens/totptoken.py:62
msgid "Specify the time step of the time-based OTP token."
msgstr "Geben Sie den Zeitschritt des zeitbasierten OTP-Tokens an."

#: lib/tokens/totptoken.py:109
msgid "TOTP: Time based One Time Passwords."
msgstr "TOTP: Zeitbasiertes Einmalpasswort."

#: lib/tokens/u2ftoken.py:260
msgid "This is a list of FQDN hostnames trusting the registered U2F tokens."
msgstr ""
"Die Liste der FQDNs, bei denen der registrierte U2F-Token verwendet werden "
"kann."

#: lib/tokens/u2ftoken.py:264
msgid ""
"Use an alternate challenge text for telling the user to confirm with his U2F "
"device."
msgstr ""
"Ein alternativer Challenge-Text, um den Benutzer aufzufordern, die Anmeldung "
"mit seinem U2F-Token zu bestätigen."

#: lib/tokens/u2ftoken.py:271
msgid "Only specified U2F tokens are authorized."
msgstr "Nur die angegebenen U2F Geräten sind für die Anmeldung autorisiert."

#: lib/tokens/u2ftoken.py:279
msgid "Only specified U2F tokens are allowed to be registered."
msgstr "Nur die angegebenen U2F Geräte dürfen registriert werden."

#: lib/tokens/u2ftoken.py:284
msgid "Do not verify the U2F attestation certificate."
msgstr "Das U2F Attestation Zertifikat NICHT überprüfen."

#: lib/tokens/u2ftoken.py:289
msgid "The user may only have this maximum number of U2F tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an U2F Token zugewiesen haben."

#: lib/tokens/u2ftoken.py:294
msgid ""
"The user may only have this maximum number of active U2F tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven U2F Token zugewiesen "
"haben."

#: lib/tokens/u2ftoken.py:379
msgid "You need to define the appId in the token config!"
msgstr "Sie müssen in der Token-Konfiguration die AppId definieren!"

#: lib/tokens/u2ftoken.py:444
msgid "Please confirm with your U2F token ({0!s})"
msgstr "Bitte bestätigen Sie mit Ihrem U2F token ({0!s})"

#: lib/tokens/vascotoken.py:101
msgid "VASCO Token: Authentication using VASCO tokens"
msgstr "VASCO Token: Authentisierung mit VASCO Token"

#: lib/tokens/vascotoken.py:110
msgid "The user may only have this maximum number of Vasco tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Vasco Token zugewiesen haben."

#: lib/tokens/vascotoken.py:115
msgid ""
"The user may only have this maximum number of active Vasco tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Vasco Token zugewiesen "
"haben."

#: lib/tokens/webauthntoken.py:460
msgid "Generic WebAuthn Token"
msgstr "Generischer WebAuthn Token"

#: lib/tokens/webauthntoken.py:470
msgid "Please confirm with your WebAuthn token ({0!s})"
msgstr "Bitte bestätigen Sie mit Ihrem WebAuthn Token ({0!s})"

#: lib/tokens/webauthntoken.py:471
msgid "Please confirm with your WebAuthn token"
msgstr "Bitte bestätigen Sie mit Ihrem WebAuthn Token"

#: lib/tokens/webauthntoken.py:608
msgid ""
"A list of transports to prefer to communicate with WebAuthn tokens. Default: "
"usb ble nfc internal (All standard transports)"
msgstr ""
"Eine Liste von Transport-Definitionen die bevorzugt für die Kommunikation zu "
"WebAuthn-Token verwendet werden soll. Standard: usb ble nfc internal (Alle "
"verfügbaren Transport-Definitionen)"

#: lib/tokens/webauthntoken.py:613
msgid ""
"The time in seconds the user has to confirm authorization on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"Die Zeit in Sekunden in welcher der Benutzer die Autorisierung mit seinem "
"WebAuthn Token bestätigen muss. Sie sollten die ChallengeValidityTime "
"entsprechend anpassen. Standard: 60"

#: lib/tokens/webauthntoken.py:619
msgid ""
"Whether the user's identity should be verified when authenticating with a "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"Die Identität des Benutzers soll bei der Authentifizierung mit bestimmt "
"werden. Standard: \"preferred\" (überprüfe den Benutzer, wenn der Token es "
"erlaubt)"

#: lib/tokens/webauthntoken.py:629
msgid ""
"Use an alternative challenge text for telling the user to confirm with his "
"WebAuthn token."
msgstr ""
"Ein alternativer Text, der den Benutzer auffordert die Authentifizierung mit "
"seinem WebAuthn Token zu bestätigen."

#: lib/tokens/webauthntoken.py:636
msgid ""
"A list of WebAuthn authenticators acceptable for authorization, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"Eine Liste an WebAuthn Authenticators, die für die Autorisierung akzeptiert "
"werden. In einer mit Leerzeichen getrennten Liste von AAGUIDs. Standardmäßig "
"werden alle akzeptiert."

#: lib/tokens/webauthntoken.py:642
msgid "Only the specified WebAuthn-tokens are authorized."
msgstr "Lediglich die angegebenen WebAuthn Token sind autorisiert."

#: lib/tokens/webauthntoken.py:649
msgid "One webauthn token can not be registered to a user more than once."
msgstr ""
"Ein Webauthn-Token kann nicht mehr als einmal für einen Benutzer registriert "
"werden."

#: lib/tokens/webauthntoken.py:654
msgid "A human-readable name for the organization rolling out WebAuthn tokens."
msgstr "Der Name der Organisation, welche die WebAuthn-Token ausstellt."

#: lib/tokens/webauthntoken.py:659
msgid ""
"A domain name that is a subset of the respective FQDNs for all the "
"webservices the users should be able to sign in to using WebAuthn tokens."
msgstr ""
"Der Domänenname, der alle FQDNs der Webdienste enthält, an denen sich der "
"Benutzer mit einem WebAuthn Token anmelden können soll."

#: lib/tokens/webauthntoken.py:665
msgid ""
"The time in seconds the user has to confirm enrollment on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"Die Zeit in Sekunden, die der Benutzer hat, um den Rollout seines WebAuthn "
"Tokens zu bestätigen. Sie sollten die ChallengeValidityTime entsprechend "
"anpassen. Standard: 60"

#: lib/tokens/webauthntoken.py:672
msgid ""
"Whether to limit roll out of WebAuthn tokens to either only platform "
"authenticators, or only cross-platform authenticators. Default: either"
msgstr ""
"Den Rollout von WebAuthn Token auf entweder \"platform\" authenticators oder "
"\"cross-platform\" beschränken. Standard: \"either\""

#: lib/tokens/webauthntoken.py:683
msgid ""
"A list of WebAuthn authenticators acceptable for enrollment, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"Eine Liste an WebAuthn Authenticators, die beim Rollout aktzeptiert werden. "
"Als eine Leerzeichen getrennte Liste von AAGUIDs. Standardmäßig werden all "
"aktzeptiert."

#: lib/tokens/webauthntoken.py:689
msgid ""
"Whether the user's identity should be verified when rolling out a new "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"Die Identität des Benutzers soll bei der Registrierung des WebAuthn Tokens "
"geprüft werden. Standard: \"preferred\" (Überprüfe den Benutzer, wenn der "
"Token dies unterstützt)"

#: lib/tokens/webauthntoken.py:703
msgid ""
"Which algorithm are available to use for creating public key credentials for "
"WebAuthn tokens. (Default: [{0!s}], Order: [{1!s}])"
msgstr ""
"Der Algorithmus, mit dem Schlüsselpaare für WebAuthn Token erzeugt werden "
"sollen. Standard: [{0!s}], Reihenfolge: [{1!s}]"

#: lib/tokens/webauthntoken.py:710
msgid ""
"Whether to request attestation data when enrolling a new WebAuthn token. "
"Note: for u2f_req to work with WebAuthn, this cannot be set to none. "
"Default: direct (ask for non-anonymized attestation data)"
msgstr ""
"Bei der Registrierung eines neuen WebAuthn Tokens sollen die Attestation "
"Daten angefordert werden. Damit u2f_req mit WebAuthn funktioniert, muss "
"dieser Wert auf \"none\" gesetzt werden. Standard: \"direct\" (Es werden "
"nicht-anonymisierte Attestation Daten angefordert)"

#: lib/tokens/webauthntoken.py:722
msgid ""
"Whether and how strictly to check authenticator attestation data. Note: If "
"the attestation form is none, the attestation level needs to also be none. "
"Default: untrusted (attestation is required, but can be unknown or self-"
"signed)"
msgstr ""
"Ob und wie genau Attestation Daten überprüft werden soll. Wenn die "
"\"attestation form\" auf \"none\" gesetzt ist, muss der \"attestation level"
"\" ebenfalls auf \"none\" gesetzt sein. Standard: \"untrusted\" (Attestation "
"wird angefordert, can aber auch unbekannt oder selbstsigniert sein)"

#: lib/tokens/webauthntoken.py:734
msgid "Only the specified WebAuthn-tokens are allowed to be registered."
msgstr "Lediglich die angegebenen WebAuthn Token dürfen registriert werden."

#: lib/tokens/webauthntoken.py:739
msgid "The user may only have this number of WebAuthn tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an WebAuthn Token zugewiesen "
"haben."

#: lib/tokens/webauthntoken.py:744
msgid "The user may only have this number of active WebAuthn tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven WebAuthn Token "
"zugewiesen haben."

#: lib/tokens/webauthntoken.py:749
msgid ""
"Use an alternate challenge text for telling the user to confirm with his "
"WebAuthn device."
msgstr ""
"Geben Sie einen alternativen Text an, der die Benutzer dazu auffordert, die "
"Anmeldung mit einem WebAuthn Gerät zu bestätigen."

#: lib/tokens/yubicotoken.py:103
msgid "Yubikey Cloud mode: Forward authentication request to YubiCloud."
msgstr ""
"Yubikey Cloud Modus: Die Authentifizierungsanfrage wird an die YubiCloud "
"weitergeleitet."

#: lib/tokens/yubicotoken.py:112
msgid "The user may only have this maximum number of Yubico tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Yubico Token zugewiesen haben."

#: lib/tokens/yubicotoken.py:117
msgid ""
"The user may only have this maximum number of active Yubico tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Yubico Token "
"zugewiesen haben."

#: lib/tokens/yubikeytoken.py:161
msgid "Yubikey AES mode: One Time Passwords with Yubikey."
msgstr "Yubikey AES Mode: Einmalpasswort mit dem Yubikey."

#: lib/tokens/yubikeytoken.py:170
msgid "The user may only have this maximum number of Yubikey tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an Yubikey Token zugewiesen haben."

#: lib/tokens/yubikeytoken.py:175
msgid ""
"The user may only have this maximum number of active Yubikey tokens assigned."
msgstr ""
"Der Benutzer darf nur maximal diese Anzahl an aktiven Yubikey Token "
"zugewiesen haben."

#: lib/tokens/yubikeytoken.py:181
msgid ""
"The Yubikey access code can be read by an enrollment client to initialize "
"Yubikeys."
msgstr ""
"Der Yubikey Access Code kann vom Rollout-Client gelesen werden, um Yubikeys "
"auszurollen."

#: lib/utils/compare.py:191
msgid "true if the value of the left attribute contains the right value"
msgstr "Wahr, wenn der Wert des linken Attributes den rechten Wert beinhaltet"

#: lib/utils/compare.py:192
msgid "false if the value of the left attribute contains the right value"
msgstr ""
"Falsch, wenn der Wert des linken Attributes den rechten Wert beinhaltet"

#: lib/utils/compare.py:194
msgid "true if the value of the left attribute equals the right value"
msgstr "Wahr, wenn der Wert des linken Attributes gleich dem rechten Wert ist"

#: lib/utils/compare.py:195
msgid "false if the value of the left attribute equals the right value"
msgstr ""
"Falsch, wenn der Wert des linken Attributes gleich dem rechten Wert ist"

#: lib/utils/compare.py:197
msgid ""
"true if the value of the left attribute completely matches the given regular "
"expression pattern on the right"
msgstr ""
"Wahr, wenn der Wert des linken Attributes komplett dem auf der rechten Seite "
"angegebenen regulären Ausdruck entspricht"

#: lib/utils/compare.py:198
msgid ""
"false if the value of the left attribute completely matches the given "
"regular expression pattern on the right"
msgstr ""
"Falsch, wenn der Wert des linken Attributes komplett dem auf der rechten "
"Seite angegebenen regulären Ausdruck entspricht"

#: lib/utils/compare.py:200
msgid ""
"true if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr ""
"Wahr, wenn der Wert des linken Attributes in der Komma-separierten Liste auf "
"der rechten Seite enthalten ist"

#: lib/utils/compare.py:201
msgid ""
"false if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr ""
"Falsch, wenn der Wert des linken Attributes in der Komma-separierten Liste "
"auf der rechten Seite enthalten ist"

#: lib/utils/compare.py:203
msgid ""
"true if the integer value of the left attribute is smaller than the right "
"integer value"
msgstr ""
"Wahr, wenn der Zahlenwert des linken Attributes kleiner ist als der "
"Zahlenwert auf der rechten Seite"

#: lib/utils/compare.py:204
msgid ""
"true if the integer value of the left attribute is bigger than the right "
"integer value"
msgstr ""
"Wahr, wenn der Zahlenwert des linken Attributes größer ist als der "
"Zahlenwert auf der rechten Seite"

#~ msgid ""
#~ "Set label for a new enrolled Google Authenticator. Possible tags are &lt;"
#~ "u&gt; (user), &lt;r&gt; (realm), &lt;s&gt; (serial)."
#~ msgstr ""
#~ "Setzt die Beschriftung für einen neu ausgerollten Google Authenticator "
#~ "oder vergleichbare App. Mögliche Platzhalter sind &lt;u&gt; (Benutzer), "
#~ "&lt;r&gt; (Realm) und &lt;s&gt; (Seriennummer)."

#~ msgid "This is the issuer label for new enrolled Google Authenticators."
#~ msgstr ""
#~ "Die Bezeichnung des Ausstellers für neu ausgerollte Google Authenticator "
#~ "oder vergleichbare Apps."

#~ msgid ""
#~ "Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
#~ "(s)pecial, (o)thers. [+/-]!"
#~ msgstr ""
#~ "Der erforderliche Inhalt einer OTP PIN. 'c' für Buchstaben, 'n' für "
#~ "Ziffern, 's' für Sonderzeichen, 'o' für andere. '+' und '-' nutzbar!"

#~ msgid ""
#~ "If set to \"privacyIDEA\" the users and admins need to authenticate "
#~ "against privacyIDEA when they log in to the Web UI. Defaults to "
#~ "\"userstore\""
#~ msgstr ""
#~ "Benutzer müssen sich entweder gegen privacyIDEA oder gegen die "
#~ "Benutzerquelle (Vorgabe) authentisieren."

#~ msgid ""
#~ "This condition can check any arbitrary tokeninfo field. You need to enter "
#~ "something like '<fieldname> == <fieldvalue>', '<fieldname> > "
#~ "<fieldvalue>' or '<fieldname> < <fieldvalue>'"
#~ msgstr ""
#~ "Diese Bedingung kann jedes beliebige Tokeninfo Feld überprüfen. Hier "
#~ "können Sie Ausdrücke wie '<Feldname> == <Feldwert>', '<Feldname> > "
#~ "<Feldwert>' oder '<Feldname> < <Feldwert>' eingeben."

#~ msgid ""
#~ "An optional proxy string. DEPRECATED. Do not usethis anymore. Rather use "
#~ "HTTP_PROXY for http connections andHTTPS_PROXY for https connection. The "
#~ "PROXY option will beremoved in future."
#~ msgstr ""
#~ "Optional Proxy. VERALTET. Diese Option wird in Zukunft (Version > 2.21) "
#~ "nicht mehr unterstützt werden."

#~ msgid ""
#~ "A list of transports to prefer to communicate with WebAuthn tokens. "
#~ "Default: usb ble nfc internal lightning (All standard transports)"
#~ msgstr ""
#~ "Eine Liste der Transport-Protokolle die bevorzugt bei der Kommunikation "
#~ "mit WebAuthn Token verwendet wird. Standard: usb ble nfc internal "
#~ "lightning"

#~ msgid ""
#~ "The Admin is allowed to set certain additional user attributes. If the "
#~ "Admin should be allowed to set any attribute, set this to '*:*'. For more "
#~ "details, check the documenation."
#~ msgstr ""
#~ "Der Administrator kann zusätzliche Attribute zu Benutzern setzen. Wenn "
#~ "der Administrator beliebige Attribute setzen können soll, dann geben Sie "
#~ "hier '*:*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid ""
#~ "The Admin is allowed to deleted certain additional user attributes. If "
#~ "the Admin should be allowed to delete any attribute, set this to '*'. For "
#~ "more details, check the documentation."
#~ msgstr ""
#~ "Der Administrator kann zusätzliche Attribute zu Benutzern löschen. Wenn "
#~ "der Administrator beliebige Attribute löschen können soll, dann geben Sie "
#~ "hier '*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid ""
#~ "The user is allowed to set certain additional user attributes. If the "
#~ "user should be allowed to set any attribute, set this to '*:*'. For more "
#~ "details, check the documenation."
#~ msgstr ""
#~ "Der Benutzer kann zusätzliche Attribute zu seinem eigenen Benutzeraccount "
#~ "setzen. Wenn er beliebige Attribute setzen können soll, dann geben Sie "
#~ "hier '*:*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid ""
#~ "The user is allowed to deleted certain additional user attributes. If the "
#~ "user should be allowed to delete any attribute, set this to '*'. For more "
#~ "details, check the documentation."
#~ msgstr ""
#~ "Der Benutzer kann zusätzliche Attribute zu seinem eigenen Benutzeraccount "
#~ "löschen. Wenn er beliebige Attribute löschen können soll, dann geben Sie "
#~ "hier '*' ein. Für weitere Details lesen Sie bitte die Dokumentation."

#~ msgid "This is the URL to the token image for smartphone apps like FreeOTP."
#~ msgstr ""
#~ "URL zu einem Bild, das zum Token in einer App wie FreeOTP angezeigt wird."

#~ msgid ""
#~ "The project ID, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die Firebase Projekt ID. Diese finden Sie in Ihrer Firebase Konsole."

#~ msgid ""
#~ "The project number, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die Firebase Projektnummer. Diese finden Sie in Ihrer Firebase Konsole."

#~ msgid ""
#~ "The App ID, that the Android client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die App ID für den Android Client. Sie finden diese in der Firebase "
#~ "Konsole."

#~ msgid ""
#~ "The API Key, that the Android client should use. Get it from your "
#~ "Firebase console."
#~ msgstr ""
#~ "Der API Schlüssel für den Android Client. Sie finden diesen in der "
#~ "Firebase Konsole."

#~ msgid ""
#~ "The App ID, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Die App ID für den iOS Client. Sie finden diese in der Firebase Konsole."

#~ msgid ""
#~ "The API Key, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr ""
#~ "Der API Schlüssel für den iOS Client. Sie finden diesen in der Firebase "
#~ "Konsole."

#~ msgid "token create failed {0!r}"
#~ msgstr "Token-Erstellung fehlgeschlagen: {0!r}"
