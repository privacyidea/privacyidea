# Chinese (Simplified) translations for PROJECT.
# Copyright (C) 2020 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2023-08-15 17:33+0200\n"
"PO-Revision-Date: 2022-12-10 13:47+0000\n"
"Last-Translator: Eric <hamburger1024@duck.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"privacyidea/privacyidea-ui/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.12.1\n"

#: api/auth.py:225
msgid "Authentication failure. Unknown realm: {0!s}."
msgstr "验证失败,未知的域: {0!s}."

#: api/auth.py:229
msgid "Authentication failure. Missing Username"
msgstr "验证失败,缺少用户名"

#: api/auth.py:350
msgid "Authentication failure. Wrong credentials"
msgstr "验证失败，凭证错误"

#: api/lib/prepolicy.py:2237
#, fuzzy
msgid "Missing description for {} token."
msgstr "令牌的新描述。"

#: api/lib/prepolicy.py:2238
#, fuzzy
msgid "Description required for {} token."
msgstr "令牌的新描述。"

#: api/lib/utils.py:345
msgid "Authentication failure. Missing Authorization header."
msgstr "验证失败。缺少授权标头。"

#: api/lib/utils.py:351 api/lib/utils.py:384
msgid "Authentication failure. Error during decoding your token: {0!s}"
msgstr "验证失败。解码令牌时出错：{0！s}"

#: api/lib/utils.py:377 api/lib/utils.py:387
msgid "Authentication failure. Your token has expired: {0!s}"
msgstr "验证失败,因为您的令牌已过期: {0!s}"

#: api/lib/utils.py:391
msgid ""
"Authentication failure. The username {0!s} is not allowed to impersonate via "
"JWT."
msgstr "验证失败。用户名{0！s}不允许通过JWT模拟。"

#: api/lib/utils.py:395
msgid ""
"Authentication failure. You do not have the necessary role ({0!s}) to access "
"this resource!"
msgstr "验证失败。您没有访问此资源所需的角色（{0！s}）！"

#: api/lib/utils.py:413
msgid "'{0!s}' is an invalid policy name."
msgstr "'{0！s}'是无效的策略名称。"

#: api/lib/utils.py:416
msgid "The name of the policy may only contain the characters a-zA-Z0-9_. -"
msgstr "该策略的名称只能包含字符a-zA-Z0-9_。--"

#: lib/challengeresponsedecorators.py:151
msgid "Please enter the new PIN again"
msgstr "请再次输入新的PIN码"

#: lib/challengeresponsedecorators.py:165
msgid "Please enter a new PIN"
msgstr "请输入新的PIN码"

#: lib/challengeresponsedecorators.py:203
msgid "To resync your token, please enter the next OTP value"
msgstr ""

#: lib/decorators.py:43 lib/token.py:2193
msgid "This action is not possible, since the token is locked"
msgstr "由于令牌已锁定，因此无法执行此操作"

#: lib/decorators.py:94
msgid "You need to specify a serial or a user."
msgstr "您需要指定一个序列号或一个用户。"

#: lib/decorators.py:96
msgid "Invalid serial number."
msgstr "无效序列号。"

#: lib/decorators.py:98
msgid "Invalid user."
msgstr "无效的用户。"

#: lib/error.py:194
msgid "You either need to provide user or serial"
msgstr "您需要提供用户或序列号"

#: lib/policy.py:1367
msgid "Invalid client definition!"
msgstr ""

#: lib/policy.py:1548
msgid "Define in which resolver the user should be registered."
msgstr "定义应该在哪个解析器中已注册的用户。"

#: lib/policy.py:1552
msgid "Define in which realm the user should be registered."
msgstr "定义应该在哪个领域中已注册的用户。"

#: lib/policy.py:1556
msgid ""
"The SMTP server configuration, that should be used to send the registration "
"email."
msgstr "SMTP服务器配置，应用于发送注册电子邮件。"

#: lib/policy.py:1560
msgid ""
"Only users with this email address are allowed to register. This is a "
"regular expression."
msgstr "仅具有该电子邮件地址的用户可以注册。这是一个正则表达式。"

#: lib/policy.py:1565
msgid ""
"The body of the registration email. Use '{regkey}' as tag for the "
"registration key."
msgstr "注册电子邮件的正文。使用“ {regkey}”作为注册密钥的标签。"

#: lib/policy.py:1571
msgid "Admin is allowed to enable tokens."
msgstr "允许管理员启用令牌。"

#: lib/policy.py:1575
msgid "Admin is allowed to disable tokens."
msgstr "允许管理员禁用令牌。"

#: lib/policy.py:1579
msgid "Admin is allowed to set token properties."
msgstr "允许管理员设置令牌属性。"

#: lib/policy.py:1584
#, fuzzy
msgid "The admin is allowed to set the token description."
msgstr "允许用户设置令牌描述。"

#: lib/policy.py:1588
msgid "Admin is allowed to set the OTP PIN of tokens."
msgstr "允许管理员设置令牌的OTP PIN。"

#: lib/policy.py:1594
msgid "Admin is allowed to set a random OTP PIN of tokens."
msgstr "允许管理员设置令牌的随机OTP PIN。"

#: lib/policy.py:1598
msgid "Admin is allowed to manually set and delete token info."
msgstr "管理员可以手动设置和删除令牌信息。"

#: lib/policy.py:1602
msgid "Admin is allowed to set the OTP PIN during enrollment."
msgstr "管理员可以在注册过程中设置OTP PIN码。"

#: lib/policy.py:1607
msgid "Admin is allowed to resync tokens."
msgstr "允许管理员重新同步令牌。"

#: lib/policy.py:1611
msgid "Admin is allowed to reset the Failcounter of a token."
msgstr "允许管理员重置令牌的失败计数器。"

#: lib/policy.py:1617
msgid "Admin is allowed to revoke a token"
msgstr "允许管理员撤销令牌"

#: lib/policy.py:1621
msgid "Admin is allowed to assign a token to a user."
msgstr "允许管理员向用户分配令牌。"

#: lib/policy.py:1627
msgid ""
"Admin is allowed to remove the token from a user, i.e. unassign a token."
msgstr "允许管理员从用户删除令牌，即取消分配令牌。"

#: lib/policy.py:1633
msgid "Admin is allowed to import token files."
msgstr "允许管理员导入令牌文件。"

#: lib/policy.py:1638
msgid "Admin is allowed to remove tokens from the database."
msgstr "允许管理员从数据库中删除令牌。"

#: lib/policy.py:1644
msgid "Admin is allowed to view the list of the users."
msgstr "允许管理员查看用户列表。"

#: lib/policy.py:1650
msgid "The Admin is allowed to list the machines."
msgstr "允许管理员列出计算机。"

#: lib/policy.py:1655
msgid "The Admin is allowed to attach and detach tokens to machines."
msgstr "允许管理员将令牌附加和分离到计算机。"

#: lib/policy.py:1662
msgid ""
"The Admin is allowed to fetch authentication items of tokens assigned to "
"machines."
msgstr "允许管理员获取分配给计算机的令牌的身份验证项目。"

#: lib/policy.py:1667
msgid "Admin is allowed to manage the realms of a token."
msgstr "允许管理员管理令牌的领域。"

#: lib/policy.py:1672
msgid "Admin is allowed to list tokens."
msgstr "管理员可以列出令牌。"

#: lib/policy.py:1676
msgid "Admin is allowed to retrieve a serial for a given OTP value."
msgstr "允许管理员检索给定OTP值的序列号。"

#: lib/policy.py:1681
msgid "Admin is allowed to retrieve random keys from privacyIDEA."
msgstr "允许管理员从privacyIDEA检索随机密钥。"

#: lib/policy.py:1685
msgid "Admin is allowed to copy the PIN of one token to another token."
msgstr "管理员可以将一个令牌的PIN复制到另一个令牌。"

#: lib/policy.py:1690
msgid ""
"Admin is allowed to copy the assigned user to another token, i.e. assign a "
"user to another token."
msgstr "管理员被允许复制分配的用户到另一个令牌，即分配一个用户到另一个令牌。"

#: lib/policy.py:1696
msgid "Admin is allowed to trigger the lost token workflow."
msgstr "允许管理员触发丢失的令牌工作流程。"

#: lib/policy.py:1702
msgid "Admin is allowed to write and modify the system configuration."
msgstr "允许管理员编写和修改系统配置。"

#: lib/policy.py:1707
msgid "Admin is allowed to delete keys in the system configuration."
msgstr "允许管理员删除系统配置中的密钥。"

#: lib/policy.py:1713
msgid "Admin is allowed to read basic system configuration."
msgstr "允许管理员读取基本系统配置。"

#: lib/policy.py:1718
msgid ""
"Admin is allowed to export a documentation of the complete configuration "
"including resolvers and realm."
msgstr "管理员可以导出完整配置的文档，包括解析器和领域。"

#: lib/policy.py:1726
msgid "Admin is allowed to write and modify the policies."
msgstr "允许管理员编写和修改策略。"

#: lib/policy.py:1731
msgid "Admin is allowed to delete policies."
msgstr "允许管理员删除策略。"

#: lib/policy.py:1736
msgid "Admin is allowed to read policies."
msgstr "允许管理员读取策略。"

#: lib/policy.py:1740
msgid ""
"Admin is allowed to write and modify the resolver and realm configuration."
msgstr "允许管理员编写和修改解析器和领域配置。"

#: lib/policy.py:1747
msgid "Admin is allowed to delete resolvers and realms."
msgstr "允许管理员删除解析器和领域。"

#: lib/policy.py:1752
msgid "Admin is allowed to read resolvers."
msgstr "允许管理员读取解析器。"

#: lib/policy.py:1756
msgid ""
"Admin is allowed to create new CA Connector definitions and modify existing "
"ones."
msgstr "允许管理员创建新的CA Connector定义并修改现有的定义。"

#: lib/policy.py:1762
msgid "Admin is allowed to delete CA Connector definitions."
msgstr "允许管理员删除CA Connector定义。"

#: lib/policy.py:1767
msgid "Admin is allowed to read CA Connector definitions."
msgstr "允许管理员读取CA Connector定义。"

#: lib/policy.py:1772
msgid "Admin is allowed to write and modify the machine resolvers."
msgstr "允许管理员编写和修改主机设备解析器。"

#: lib/policy.py:1778
msgid "Admin is allowed to delete machine resolvers."
msgstr "允许管理员删除主机设备解析器。"

#: lib/policy.py:1784
msgid "Admin is allowed to read machine resolvers."
msgstr "允许管理员读取主机设备解析器。"

#: lib/policy.py:1791 lib/policy.py:2072
msgid "Set the maximum allowed length of the OTP PIN."
msgstr "设置OTP PIN允许的最大长度。"

#: lib/policy.py:1796 lib/policy.py:2077
msgid "Set the minimum required length of the OTP PIN."
msgstr "设置OTP PIN所需的最小长度。"

#: lib/policy.py:1800 lib/policy.py:2081
msgid ""
"Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
"(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgstr ""
"指定OTP PIN的必需内容。（c）个字符，（n）个数字，（s）个。使用修饰符+/-或允许"
"的字符列表[1234567890]"

#: lib/policy.py:1809
msgid "The length of a random PIN set by the administrator."
msgstr "管理员设置的随机PIN的长度。"

#: lib/policy.py:1812
msgid "Admin is allowed to view the Audit log."
msgstr "允许管理员查看审核日志。"

#: lib/policy.py:1816
msgid "The admin will only see audit entries of the last 10d, 3m or 2y."
msgstr "管理员只会看到最近10天，3个月或2年的审核条目。"

#: lib/policy.py:1821
msgid "The admin will not see the specified columns in the audit."
msgstr ""

#: lib/policy.py:1826
msgid "The admin is allowed to download the complete auditlog."
msgstr "允许管理员下载完整的审核日志。"

#: lib/policy.py:1831
msgid "Admin is allowed to add users in a userstore/UserIdResolver."
msgstr "允许管理员在用户存储中/用户解析器中添加用户。"

#: lib/policy.py:1836
msgid "Admin is allowed to update the users data in a userstore."
msgstr "允许管理员更新用户存储中的用户数据。"

#: lib/policy.py:1841
msgid "Admin is allowed to delete a user object in a userstore."
msgstr "允许管理员删除用户存储中的用户对象。"

#: lib/policy.py:1846
msgid "Admin is allowed to set the password of the HSM/Security Module."
msgstr "允许管理员设置HSM /安全模块的密码。"

#: lib/policy.py:1850
msgid "Admin is allowed to retrieve the list of active challenges."
msgstr "允许管理员检索活动挑战的列表。"

#: lib/policy.py:1856
msgid "Admin is allowed to write new SMTP server definitions."
msgstr "允许管理员编写新的SMTP服务器定义。"

#: lib/policy.py:1861
msgid "Admin is allowed to read SMTP server definitions."
msgstr "允许管理员读取SMTP服务器定义。"

#: lib/policy.py:1866
msgid "Admin is allowed to write new RADIUS server definitions."
msgstr "允许管理员编写新的RADIUS服务器定义。"

#: lib/policy.py:1872
msgid "Admin is allowed to read RADIUS server definitions."
msgstr "允许管理员读取SMTP服务器定义。"

#: lib/policy.py:1877
msgid "Admin is allowed to write remote privacyIDEA server definitions."
msgstr "允许管理员编写远程privacyIDEA服务器定义。"

#: lib/policy.py:1884
msgid "Admin is allowed to read remote privacyIDEA server definitions."
msgstr "允许管理员读取远程privacyIDEA服务器定义。"

#: lib/policy.py:1891
msgid "Admin is allowed to write periodic task definitions."
msgstr "允许管理员编写定期任务定义。"

#: lib/policy.py:1896
msgid "Admin is allowed to read periodic task definitions."
msgstr "允许管理员读取定期任务定义。"

#: lib/policy.py:1901
msgid "Admin is allowed to read statistics data."
msgstr "允许管理员读取统计数据。"

#: lib/policy.py:1904
msgid "Admin is allowed to delete statistics data."
msgstr "允许管理员删除统计数据。"

#: lib/policy.py:1907
msgid "Admin is allowed to write and modify the event handling configuration."
msgstr "允许管理员编写和修改事件处理配置。"

#: lib/policy.py:1913
msgid "Admin is allowed to read event handling configuration."
msgstr "允许管理员读取事件处理配置。"

#: lib/policy.py:1918
msgid "Admin is allowed to write and modify SMS gateway definitions."
msgstr "允许管理员编写和修改SMS网关定义。"

#: lib/policy.py:1924
msgid "Admin is allowed to read SMS gateway definitions."
msgstr "允许管理员读取SMS网关定义。"

#: lib/policy.py:1929
msgid ""
"Admin is allowed to get the list of authenticated clients and their types."
msgstr "允许管理员获取经过身份验证的客户端及其类型的列表。"

#: lib/policy.py:1936
msgid "Admin is allowed to add and delete component subscriptions."
msgstr "允许管理员添加和删除组件订阅。"

#: lib/policy.py:1942
msgid "The Admin is allowed to trigger a challenge for e.g. SMS OTP token."
msgstr "允许管理员触发例如SMS OTP令牌的质询。"

#: lib/policy.py:1948
msgid ""
"The Admin is allowed to set certain custom user attributes. If the Admin "
"should be allowed to set any attribute, set this to '*:*'. For more details, "
"check the documentation."
msgstr ""

#: lib/policy.py:1956
msgid ""
"The Admin is allowed to delete certain custom user attributes. If the Admin "
"should be allowed to delete any attribute, set this to '*'. For more "
"details, check the documentation."
msgstr ""

#: lib/policy.py:1964
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the admin."
msgstr ""

#: lib/policy.py:1969
msgid "The Admin is allowed list the available tokengroups."
msgstr "允许管理员列出可用的令牌组。"

#: lib/policy.py:1974
msgid "The Admin is allowed to add a new tokengroup."
msgstr "允许管理员添加新的令牌组。"

#: lib/policy.py:1979
msgid "The Admin is allowed delete a tokengroup."
msgstr "允许管理员删除令牌组。"

#: lib/policy.py:1984
#, fuzzy
msgid "The Admin is allowed list the available service ID definitions."
msgstr "允许管理员列出可用的令牌组。"

#: lib/policy.py:1989
#, fuzzy
msgid "The Admin is allowed to add a new service ID definition."
msgstr "允许管理员读取SMTP服务器定义。"

#: lib/policy.py:1994
#, fuzzy
msgid "The Admin is allowed delete a service ID definition."
msgstr "允许管理员删除CA Connector定义。"

#: lib/policy.py:1999
msgid "The Admin is allowed to manage the tokengroups of a token."
msgstr "允许管理员管理令牌的令牌组。"

#: lib/policy.py:2006
msgid ""
"The user is allowed to assign an existing token that is not yet assigned "
"using the token serial number."
msgstr "允许用户分配尚未使用令牌序列号分配的现有令牌。"

#: lib/policy.py:2012
msgid "The user is allowed to disable his own tokens."
msgstr "允许用户禁用自己的令牌。"

#: lib/policy.py:2018
msgid "The user is allowed to enable his own tokens."
msgstr "允许用户启用自己的令牌。"

#: lib/policy.py:2024
msgid "The user is allowed to delete his own tokens."
msgstr "允许用户删除自己的令牌。"

#: lib/policy.py:2030
msgid "The user is allowed to unassign his own tokens."
msgstr "允许用户取消分配自己的令牌。"

#: lib/policy.py:2035
msgid "The user is allowed to resyncronize his tokens."
msgstr "允许用户重新同步他的令牌。"

#: lib/policy.py:2040
msgid "The user is allowed to revoke a token"
msgstr "允许用户撤销令牌"

#: lib/policy.py:2045
msgid "The user is allowed to reset the failcounter of his tokens."
msgstr "允许用户重置其令牌的故障计数器。"

#: lib/policy.py:2050
msgid "The user is allowed to set the OTP PIN of his tokens."
msgstr "允许用户设置其令牌的OTP PIN。"

#: lib/policy.py:2055
msgid "The user is allowed to set a random OTP PIN of his tokens."
msgstr "允许用户设置其令牌的随机OTP PIN。"

#: lib/policy.py:2060
msgid "The length of a random PIN set by the user."
msgstr "用户设置的随机PIN的长度。"

#: lib/policy.py:2063
msgid "The user is allowed to set the token description."
msgstr "允许用户设置令牌描述。"

#: lib/policy.py:2067
msgid "The user is allowed to set the OTP PIN during enrollment."
msgstr "允许用户在注册期间设置OTP PIN。"

#: lib/policy.py:2090
msgid "Allow the user to view his own token history."
msgstr "允许用户查看自己的令牌历史记录。"

#: lib/policy.py:2093
msgid "The user will only see audit entries of the last 10d, 3m or 2y."
msgstr "用户将仅看到最近10d，3m或2y的审核条目。"

#: lib/policy.py:2097
msgid "The user will not see the specified columns in the audit."
msgstr ""

#: lib/policy.py:2102
msgid "The user is allowed to view his own user information."
msgstr "允许用户查看自己的用户信息。"

#: lib/policy.py:2106
msgid ""
"The user is allowed to update his own user information, like changing his "
"password."
msgstr "允许用户更新自己的用户信息，例如更改密码。"

#: lib/policy.py:2111
msgid ""
"The user is allowed to do a password reset in an editable UserIdResolver."
msgstr "允许用户在可编辑的用户解析器中重置密码。"

#: lib/policy.py:2117
msgid ""
"The user is allowed to set certain custom user attributes. If the user "
"should be allowed to set any attribute, set this to '*:*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""

#: lib/policy.py:2125
msgid ""
"The user is allowed to delete certain custom user attributes. If the user "
"should be allowed to delete any attribute, set this to '*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""

#: lib/policy.py:2133
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the user."
msgstr ""

#: lib/policy.py:2141
msgid "Limit the number of allowed tokens in a realm."
msgstr "限制领域中允许的令牌数量。"

#: lib/policy.py:2145
msgid ""
"During the rollout process, this policy makes the description required for "
"all selected tokentypes."
msgstr ""

#: lib/policy.py:2153
msgid "Limit the number of tokens a user may have assigned."
msgstr "限制用户可能分配的令牌数量。"

#: lib/policy.py:2158
msgid "Limit the number of active tokens a user may have assigned."
msgstr "限制用户可能已分配的活动令牌的数量。"

#: lib/policy.py:2163
msgid ""
"Set a random OTP PIN with this length for a token during the enrollment "
"process."
msgstr "在注册过程中，为此令牌设置一个随机的OTP PIN码。"

#: lib/policy.py:2168
msgid "In case of a random OTP PIN use this python module to process the PIN."
msgstr "如果是随机OTP PIN，请使用此python模块处理PIN。"

#: lib/policy.py:2173
msgid ""
"If the administrator sets the OTP PIN during enrollment or later, the user "
"will have to change the PIN during first use."
msgstr ""
"如果管理员在注册期间或之后设置OTP PIN，则用户将不得不在首次使用时更改PIN。"

#: lib/policy.py:2180
msgid ""
"The user needs to change his PIN on a regular basis. To change the PIN every "
"180 days, enter '180d'."
msgstr "用户需要定期更改其PIN。要每180天更改一次PIN，请输入“ 180d”。"

#: lib/policy.py:2187
msgid ""
"The OTP PIN can be hashed or encrypted. Hashing the PIN is the default "
"behaviour."
msgstr "可以对OTP PIN进行哈希处理或加密。散列PIN是默认行为。"

#: lib/policy.py:2192
msgid ""
"The label for a new enrolled Smartphone token. Possible tags are <code>{user}"
"</code>, <code>{realm}</code>, <code>{serial}</code>, <code>{givenname}</"
"code> and <code>{surname}</code>."
msgstr ""

#: lib/policy.py:2198
msgid ""
"The issuer label for new enrolled Smartphone token.Possible tags are "
"<code>{user}</code>, <code>{realm}</code>, <code>{serial}</code>, "
"<code>{givenname}</code> and <code>{surname}</code>."
msgstr ""

#: lib/policy.py:2205
msgid ""
"This is the URL to the token image for the privacyIDEA Authenticator and "
"some other apps like FreeOTP (supported file formats: PNG, JPG and GIF)."
msgstr ""

#: lib/policy.py:2212
msgid ""
"Users can assign a token just by using the unassigned token to authenticate."
msgstr "用户可以仅使用未分配的令牌进行身份验证来分配令牌。"

#: lib/policy.py:2218
msgid "The length of the password in case of temporary token (lost token)."
msgstr "临时令牌（丢失令牌）时密码的长度。"

#: lib/policy.py:2222
msgid ""
"The contents of the temporary password, described by the characters C, c, n, "
"s, 8."
msgstr "临时密码的内容，由字符C，c，n，s，8表示。"

#: lib/policy.py:2227
msgid "The length of the validity for the temporary token (in days)."
msgstr "临时令牌的有效期限（以天为单位）。"

#: lib/policy.py:2232
msgid "Set the length of registration codes."
msgstr ""

#: lib/policy.py:2236
msgid ""
"Specify the required contents of the registration code. (c)haracters, "
"(n)umeric, (s)pecial. Use modifiers +/- or a list of allowed characters "
"[1234567890]"
msgstr ""
"请指定注册码需要填写的内容。(c) 字符、 (n) 数字、(s) 特殊符号。使用修饰符 "
"+/- 或允许的字符列表 [1234567890]"

#: lib/policy.py:2245
msgid "Set the length of the password of generated password tokens."
msgstr "设定生成的密码令牌的密码的长度。"

#: lib/policy.py:2249
msgid ""
"Specify the required contents of the password of a password token. "
"(c)haracters, (n)umeric, (s)pecial. Use modifiers +/- or a list of allowed "
"characters [1234567890]"
msgstr ""
"指定密码令牌的密码的需要的内容。(c)字符、 (n)数字、 (s)特殊符号。使用修饰符 "
"+/- 或允许字符[1234567890] 的列表"

#: lib/policy.py:2257
msgid ""
"Specify a white space separated list of token types, that should be verified "
"during enrollment."
msgstr "指定由空格分隔的令牌类型列表， 应该在注册时对它们进行核实。"

#: lib/policy.py:2266
msgid ""
"Either use the Token PIN , use the Userstore Password or use no fixed "
"password component."
msgstr "使用令牌PIN，使用用户存储密码或不使用固定的密码组件。"

#: lib/policy.py:2271
msgid ""
"This is a whitespace separated list of tokentypes, that can be used with "
"challenge response."
msgstr "这是由空格分隔的令牌类型列表，可以与质询响应一起使用。"

#: lib/policy.py:2278
msgid ""
"Use an alternate challenge text for telling the user to enter an OTP value."
msgstr "使用备用质询文本告诉用户输入OTP值。"

#: lib/policy.py:2283
msgid ""
"If there are several different challenges, this text precedes the list of "
"the challenge texts."
msgstr "使用令牌PIN，使用用户存储密码或不使用固定的密码组件。"

#: lib/policy.py:2288
msgid ""
"If there are several different challenges, this text follows the list of the "
"challenge texts."
msgstr "如果存在多个不同的挑战，则该文本紧随挑战文本列表之后。"

#: lib/policy.py:2293
msgid ""
"If the PIN of a token is to be changed, this will allow the user to change "
"the PIN during a validate/check request via challenge / response."
msgstr ""
"如果要更改令牌的PIN，这将允许用户通过质询/响应在验证/检查请求期间更改PIN。"

#: lib/policy.py:2298
msgid ""
"The autoresync of a token can be done via a challenge response message.You "
"need to activate 'Automatic resync' in the general settings!"
msgstr ""

#: lib/policy.py:2303
msgid ""
"In case of a successful authentication the following tokentype is enrolled. "
"The maximum number of tokens for a user is checked."
msgstr ""

#: lib/policy.py:2310
msgid ""
"If set, the user in this realm will be authenticated against the userstore "
"or against the given RADIUS config, if the user has no tokens assigned."
msgstr ""
"如果设置，则将根据用户存储或给定的RADIUS配置对该领域的用户进行身份验证（如果"
"未分配令牌）。"

#: lib/policy.py:2317
msgid ""
"This allows to automatically assign a Token within privacyIDEA, if the user "
"was authenticated via passthru against a RADIUS server. The OTP value is "
"used to find the unassigned token in privacyIDEA. Enter the length of the "
"OTP value and where the PIN is set like 8:pin or pin:6."
msgstr ""
"如果用户是通过passthru对RADIUS服务器进行身份验证的，则这允许在privacyIDEA中自"
"动分配令牌。OTP值用于在privacyIDEA中查找未分配的令牌。输入OTP值的长度以及PIN"
"的设置位置，例如8：pin或pin：6。"

#: lib/policy.py:2324
msgid ""
"If the user has no token, the authentication request for this user will "
"always be true."
msgstr "如果用户没有令牌，则对此用户的身份验证请求将始终为true。"

#: lib/policy.py:2329
msgid ""
"If the user user does not exist, the authentication request for this non-"
"existing user will always be true."
msgstr "如果用户用户不存在，则此不存在的用户的身份验证请求将始终为true。"

#: lib/policy.py:2335
msgid ""
"Can be used to modify the parameters pass, user and realm in an "
"authentication request. See the documentation for an example."
msgstr ""
"可用于修改身份验证请求中的参数pass，user和realm。有关示例，请参见文档。"

#: lib/policy.py:2341
msgid ""
"If a user authenticates successfully reset the failcounter of all of his "
"tokens."
msgstr "如果用户成功进行身份验证，则重置其所有令牌的故障计数器。"

#: lib/policy.py:2346
msgid ""
"Increase the failcounter for all the tokens, for which a challenge has been "
"triggered."
msgstr ""

#: lib/policy.py:2350
msgid ""
"Cache the password used for authentication and allow authentication with the "
"same credentials for a certain amount of time. Specify timeout like 4h or "
"4h/5m."
msgstr ""
"缓存用于身份验证的密码，并允许在一定时间内使用相同的凭据进行身份验证。指定超"
"时时间，例如4h或4h / 5m。"

#: lib/policy.py:2357
msgid ""
"You can set the client modes in the order that you prefer. For example: "
"\"interactive webauthn poll u2f\". Accepted values are: <code>interactive "
"webauthn poll u2f</code>"
msgstr ""

#: lib/policy.py:2365
msgid ""
"Allow the user to authenticate (default). If set to '{0!s}', the "
"authentication of the user will be denied."
msgstr ""
"允许用户进行身份验证（默认）。如果设置为“ {0！s}”，则将拒绝用户的身份验证。"

#: lib/policy.py:2372
msgid ""
"Allow the application to choose which token types should be used for "
"authentication. Application may set the parameter 'type' in the request. "
"Works with validate/check, validate/samlcheck and validate/triggerchallenge."
msgstr ""
"允许应用程序选择应使用哪些令牌类型进行身份验证。应用程序可以在请求中设置参"
"数“类型”。与验证/检查，验证/ samlcheck和验证/触发挑战一起使用。"

#: lib/policy.py:2379
msgid ""
"You can specify how many successful authentication requests a user is "
"allowed to do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h "
"being second, minute and hour."
msgstr ""
"您可以指定在给定时间内允许用户执行多少次成功的身份验证请求。指定为1 / 5s，"
"2 / 10m，10 / 1h-s，m，h为秒，分钟和小时。"

#: lib/policy.py:2387
msgid ""
"You can specify how many failed authentication requests a user is allowed to "
"do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h being second, "
"minute and hour."
msgstr ""
"您可以指定在给定时间内允许用户执行多少次失败的身份验证请求。指定为1 / 5s，"
"2 / 10m，10 / 1h-s，m，h为秒，分钟和小时。"

#: lib/policy.py:2395
msgid ""
"You can specify in which time frame the user needs to authenticate again "
"with this token. If the user authenticates later, authentication will fail. "
"Specify like 30h, 7d or 1y."
msgstr ""
"您可以指定用户需要在哪个时间范围内使用此令牌再次进行身份验证。如果用户稍后进"
"行身份验证，则身份验证将失败。指定为30h，7d或1y。"

#: lib/policy.py:2403
msgid "The user will only be authenticated with this very tokentype."
msgstr "将仅使用此令牌类型对用户进行身份验证。"

#: lib/policy.py:2410
msgid ""
"The user will only be authenticated if the serial number of the token "
"matches this regexp."
msgstr "仅当令牌的序列号与此正则表达式匹配时，用户才会通过身份验证。"

#: lib/policy.py:2416
#, fuzzy
#| msgid ""
#| "The user will only be authenticated if the tokeninfo field matches the "
#| "regexp. key/&lt;regexp&gt;/"
msgid ""
"The user will only be authenticated if the tokeninfo field matches the "
"regexp (key/&lt;regexp&gt;/)."
msgstr ""
"仅当tokeninfo字段与regexp匹配时，才会对用户进行身份验证。key/&lt;regexp&gt;/"

#: lib/policy.py:2423
msgid ""
"The Realm of the user is set to this very realm. This is important if the "
"user is not contained in the default realm and can not pass his realm."
msgstr ""
"用户的领域已设置为该领域。如果用户未包含在默认领域中并且无法通过其领域，则这"
"一点很重要。"

#: lib/policy.py:2430
msgid ""
"In case of successful authentication additional no detail information will "
"be returned."
msgstr "如果认证成功，则不会返回任何详细信息。"

#: lib/policy.py:2436
msgid ""
"In case of failed authentication additional no detail information will be "
"returned."
msgstr "如果认证失败，则不会返回任何详细信息。"

#: lib/policy.py:2442
msgid ""
"In case of successful authentication user data will be added in the detail "
"branch of the authentication response."
msgstr "如果认证成功，则将用户数据添加到认证响应的详细分支中。"

#: lib/policy.py:2449
msgid ""
"In case of successful authentication the user resolver and realm will be "
"added in the detail branch of the authentication response."
msgstr "如果认证成功，则用户解析器和领域将添加到认证响应的详细分支中。"

#: lib/policy.py:2456
msgid ""
"The sending of an API Auth Key is required duringauthentication. This avoids "
"rogue authenticate requests against the /validate/check interface."
msgstr ""
"身份验证期间需要发送API身份验证密钥。这样可以避免针对/ validate / check接口的"
"流氓身份验证请求。"

#: lib/policy.py:2466
msgid ""
"If set, administrators will see a dashboard as start screen when logging in "
"to privacyIDEA WebUI."
msgstr ""
"如果设置了该选项，则管理员在登录privacyIDEA WebUI时会将仪表板作为开始屏幕。"

#: lib/policy.py:2471
msgid ""
"If set to \"privacyIDEA\" the users and admins need to authenticate against "
"privacyIDEA when they log in to the Web UI. Defaults to \"userstore\"."
msgstr ""
"如果设置为“ privacyIDEA”，则用户和管理员在登录Web UI时需要针对privacyIDEA进行"
"身份验证。默认为“用户存储”。"

#: lib/policy.py:2480
msgid ""
"An alternative text to display on the WebUI login dialog instead of \"Please "
"sign in\"."
msgstr "在WebUI登录对话框上显示的替代文本，而不是“请登录”。"

#: lib/policy.py:2484
msgid ""
"When searching in the user list, the search will only performed when "
"pressing enter."
msgstr "在用户列表中搜索时，仅在按Enter键时才执行搜索。"

#: lib/policy.py:2489
msgid ""
"The action taken when a user is idle beyond the logout_time limit. Defaults "
"to \"lockscreen\"."
msgstr "用户闲置超过logout_time限制时采取的操作。默认为“锁屏”。"

#: lib/policy.py:2497
msgid ""
"The REMOTE_USER set by the webserver can be used to login to privacyIDEA or "
"it will be ignored. Defaults to \"disable\"."
msgstr ""
"网络服务器设置的REMOTE_USER可用于登录privacyIDEA，否则将被忽略。默认为“禁"
"用”。"

#: lib/policy.py:2503
msgid ""
"Set the time in seconds after which the user will be logged out from the "
"WebUI. Default: 120"
msgstr "设置以秒为单位的时间，在该时间之后，用户将从WebUI注销。默认值：120"

#: lib/policy.py:2508
msgid "Set how many tokens should be displayed in the token view on one page."
msgstr "设置应在一页的令牌视图中显示多少个令牌。"

#: lib/policy.py:2513
msgid "Set how many users should be displayed in the user view on one page."
msgstr "设置应在一页的用户视图中显示多少个用户。"

#: lib/policy.py:2518
msgid ""
"Set how many audit entries should be displayed in the audit view on one page."
msgstr "设置应在审计视图的一页中显示多少审计条目。"

#: lib/policy.py:2523
msgid "Use your own html template for the web UI menu."
msgstr "将您自己的html模板用于Web UI菜单。"

#: lib/policy.py:2527
msgid "Use your own html template for the web UI baseline/footer."
msgstr "将您自己的html模板用于Web UI基线/页脚。"

#: lib/policy.py:2531
msgid "Link your privacy statement to be displayed in the baseline/footer."
msgstr ""

#: lib/policy.py:2535
msgid ""
"Whether the user ID and the resolver should be displayed in the token list."
msgstr "用户标识和解析器是否应显示在令牌列表中。"

#: lib/policy.py:2540
msgid ""
"The URL of a repository, where the policy templates can be found.  (Default "
"https: //raw.githubusercontent.com/ privacyidea/policy-templates /master/"
"templates/)"
msgstr ""
"可以在其中找到策略模板的存储库的URL。  （默认https：//raw.githubusercontent."
"com/ privacyidea / policy-templates / master / templates /）"

#: lib/policy.py:2547
msgid ""
"The URL of an SSO provider for redirect at logout.(The URL must start with "
"http:// or https://)"
msgstr ""

#: lib/policy.py:2552
msgid ""
"As long as a user has no token, he will only see a token wizard in the UI."
msgstr "只要用户没有令牌，他将仅在UI中看到令牌向导。"

#: lib/policy.py:2557
msgid ""
"The tokenwizard will be displayed in the token menu, even if the user "
"already has a token."
msgstr "即使用户已经拥有令牌，令牌向导也会显示在令牌菜单中。"

#: lib/policy.py:2562
msgid ""
"This is a whitespace separated list of tokentypes, for which a rollover "
"button is displayed in the token details."
msgstr ""

#: lib/policy.py:2569
msgid ""
"The welcome dialog will be displayed if the user has no tokens assigned."
msgstr "如果用户未分配令牌，将显示欢迎对话框。"

#: lib/policy.py:2573
msgid "This is the default token type in the token enrollment dialog."
msgstr "这是令牌注册对话框中的默认令牌类型。"

#: lib/policy.py:2579
msgid ""
"A list of realm names, which are displayed in a drop down menu in the WebUI "
"login screen. Realms are separated by white spaces."
msgstr "领域名称列表，显示在WebUI登录屏幕的下拉菜单中。领域之间用空格隔开。"

#: lib/policy.py:2585
msgid ""
"If this checked, the administrator will not see the welcome dialog anymore."
msgstr "如果选中此选项，则管理员将不再看到“欢迎”对话框。"

#: lib/policy.py:2590
msgid ""
"Per default disabled actions result in disabled buttons. When checking this "
"action, buttons of disabled actions are hidden."
msgstr ""
"默认情况下，禁用操作会导致禁用按钮。检查此操作时，禁用操作的按钮将被隐藏。"

#: lib/policy.py:2595
msgid ""
"If this is checked, there will be a confirmation prompt when deleting "
"policies, events, mresolver, resolver or periodic tasks!"
msgstr ""

#: lib/policy.py:2600
msgid ""
"If this is checked, the seed will be displayed as text during enrollment."
msgstr "如果选中此选项，则种子将在注册过程中显示为文本。"

#: lib/policy.py:2605
msgid ""
"If this is checked, the privacyIDEA Node name will be displayed in the menu "
"bar."
msgstr "如果选中此选项，则 privacyIDEA 节点名称将显示在菜单栏中。"

#: lib/policy.py:2610
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the Google "
"Play Store."
msgstr ""
"如果选中此选项，则HOTP，TOTP和Push令牌的注册页面将包含一个QR码，可转到Google "
"Play商店中的privacyIDEA身份验证器。"

#: lib/policy.py:2617
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the iOS App "
"Store."
msgstr ""
"如果选中此选项，那么HOTP，TOTP和Push令牌的注册页面将包含一个QR码，可通往iOS "
"App Store中的privacyIDEA Authenticator。"

#: lib/policy.py:2624
msgid ""
"This action adds a QR code in the enrollment page for HOTP, TOTP and Push "
"tokens, that lead to this given URL."
msgstr ""
"此操作会在注册页面中为HOTP，TOTP和Push令牌添加QR码，该QR码会导致该给定URL。"

#: lib/policy.py:2669
msgid ""
"The policy only matches if certain conditions on the user info are fulfilled."
msgstr "该策略仅在满足用户信息的某些条件时匹配。"

#: lib/policy.py:2672
msgid ""
"The policy only matches if certain conditions of the token attributes are "
"fulfilled."
msgstr ""

#: lib/policy.py:2675
msgid ""
"The policy only matches if certain conditions on the token info are "
"fulfilled."
msgstr "该策略只在令牌信息的某些条件得到满足时才匹配。"

#: lib/policy.py:2678
msgid ""
"The policy only matches if certain conditions on the HTTP Request header are "
"fulfilled."
msgstr "该策略仅在满足HTTP Request标头上的某些条件时匹配。"

#: lib/policy.py:2681
msgid ""
"The policy only matches if certain conditions on the HTTP Environment are "
"fulfilled."
msgstr ""

#: lib/radiusserver.py:225 lib/radiusserver.py:257
msgid "The RADIUS secret is too long"
msgstr "RADIUS秘钥太长"

#: lib/token.py:152
msgid "create_tokenclass_object failed:  {0!r}"
msgstr ""

#: lib/token.py:308
msgid "I can only create SQL filters from tokeninfo of length 1."
msgstr ""

#: lib/token.py:565
msgid "The requested token could not be found."
msgstr ""

#: lib/token.py:567
msgid "More than one matching token were found."
msgstr ""

#: lib/token.py:881
msgid "multiple tokens are matching this OTP value!"
msgstr ""

#: lib/token.py:1041
msgid "init token failed: unknown token type {0!r}"
msgstr ""

#: lib/token.py:1062
msgid "initToken failed: {0!s}"
msgstr ""

#: lib/token.py:1222
msgid "Token already assigned to user {0!r}"
msgstr "已分配给用户的令牌 {0!r}"

#: lib/token.py:1236
msgid "Token assign failed for {0!r}/{1!s} : {2!r}"
msgstr ""

#: lib/token.py:1264
msgid "Token unassign failed for {0!r}/{1!r}: {2!r}"
msgstr ""

#: lib/token.py:1340
msgid "Parameter user must not be a string: {0!r}"
msgstr ""

#: lib/token.py:1879
msgid "You can only define a lost token for an assigned token."
msgstr ""

#: lib/token.py:1905
msgid "temporary replacement for {0!s}"
msgstr ""

#: lib/token.py:1961
msgid "There is no active and assigned token in this realm"
msgstr ""

#: lib/token.py:1973
msgid ""
"There is no active and assigned token in this realm, included types: {0!s}, "
"excluded types: {1!s}"
msgstr ""

#: lib/token.py:2027
msgid "OTP verification failed."
msgstr ""

#: lib/token.py:2060
msgid "The user has no tokens assigned"
msgstr "用户没有分配到令牌"

#: lib/token.py:2275
msgid "matching {0:d} tokens"
msgstr ""

#: lib/token.py:2327
msgid "Challenge matches, but token is not fit for challenge"
msgstr ""

#: lib/token.py:2337
msgid "Found matching challenge"
msgstr ""

#: lib/token.py:2379
msgid "Response did not match the challenge."
msgstr ""

#: lib/token.py:2381
msgid "Response did not match for {0!s} tokens."
msgstr ""

#: lib/token.py:2389
msgid "No active challenge response token found"
msgstr ""

#: lib/token.py:2405
msgid "wrong otp value"
msgstr ""

#: lib/token.py:2412
msgid ". previous otp used again"
msgstr ""

#: lib/token.py:2426
msgid "wrong otp pin"
msgstr ""

#: lib/token.py:2434
msgid "No suitable token found for authentication."
msgstr ""

#: lib/token.py:2459
#, fuzzy
msgid "Admin is allowed to initialize {0!s} tokens."
msgstr "允许管理员初始化{0！s}令牌。"

#: lib/token.py:2467
msgid "The user is allowed to enroll a {0!s} token."
msgstr "允许用户注册{0！s}令牌。"

#: lib/token.py:2498
msgid "Set the maximum allowed PIN length of the {0!s} token."
msgstr "设置{0！s}令牌的最大允许PIN长度。"

#: lib/token.py:2505
msgid "Set the minimum required PIN length of the {0!s} token."
msgstr "设置{0！s}令牌所需的最小PIN长度。"

#: lib/token.py:2511
msgid ""
"Specifiy the required PIN contents of the {0!s} token. (c)haracters, "
"(n)umeric, (s)pecial, (o)thers. [+/-]!"
msgstr ""
"指定{0！s}令牌的必需PIN内容。（c）字符，（n）数值，（s）特殊，（o）其他。"
"[+/-]！"

#: lib/token.py:2556 lib/token.py:2572
msgid "The tokengroup does not exist."
msgstr ""

#: lib/tokenclass.py:1674
msgid "please enter otp: "
msgstr "请输入otp： "

#: lib/applications/ssh.py:104
#, fuzzy
msgid "The username on the SSH server."
msgstr "强制在服务器上生成密钥."

#: lib/applications/ssh.py:106
msgid ""
"The service ID of the SSH server. Several servers can have the same service "
"ID."
msgstr ""

#: lib/eventhandler/base.py:146
msgid ""
"The rollout_state of the token has a certain value like 'clientwait' or "
"'enrolled'."
msgstr "令牌的rollout_state具有某个值，例如“ clientwait”或“ enrolled”。"

#: lib/eventhandler/base.py:151
msgid "The realm of the user, for which this event should apply."
msgstr "应应用此事件的用户领域。"

#: lib/eventhandler/base.py:157
msgid "The resolver of the user, for which this event should apply."
msgstr "用户的解析器，应应用此事件。"

#: lib/eventhandler/base.py:163
msgid "The realm of the token, for which this event should apply."
msgstr "此事件应适用的令牌领域。"

#: lib/eventhandler/base.py:170
msgid "The resolver of the token, for which this event should apply."
msgstr "令牌的解析器，此事件应适用于该解析器。"

#: lib/eventhandler/base.py:177
msgid "The type of the token."
msgstr "令牌的类型。"

#: lib/eventhandler/base.py:183
msgid "The logged in user is of the following type."
msgstr "登录的用户属于以下类型。"

#: lib/eventhandler/base.py:189
msgid "The result.value within the response is True or False."
msgstr "响应中的result.value为True或False。"

#: lib/eventhandler/base.py:196
msgid "The result.status within the response is True or False."
msgstr "响应中的result.status为True或False。"

#: lib/eventhandler/base.py:203
msgid "Check if the max failcounter of the token is reached."
msgstr "检查是否达到令牌的最大故障计数器。"

#: lib/eventhandler/base.py:210
msgid "The token has a user assigned."
msgstr "令牌已分配用户。"

#: lib/eventhandler/base.py:216
msgid ""
"The token has a user assigned, but the user does not exist in the userstore "
"anymore."
msgstr "令牌已分配了一个用户，但是该用户不再存在于用户存储中。"

#: lib/eventhandler/base.py:223
msgid "Check if the token is within its validity period."
msgstr "检查令牌是否在其有效期内。"

#: lib/eventhandler/base.py:229
msgid "Action is triggered, if the serial matches this regular expression."
msgstr "如果序列匹配此正则表达式，则触发操作。"

#: lib/eventhandler/base.py:235
msgid "Action is triggered, if the user has this number of tokens assigned."
msgstr "如果用户分配了此令牌数量，则触发操作。"

#: lib/eventhandler/base.py:241
msgid ""
"Action is triggered, if the counter of the token equals this setting. Can "
"also be '>100' or '<99' for no exact match."
msgstr ""
"如果令牌的计数器等于此设置，则触发操作。也可以是'> 100'或'<99'（不完全匹"
"配）。"

#: lib/eventhandler/base.py:248
msgid ""
"Action is triggered, if the last authentication of the token is older than "
"7h, 10d or 1y."
msgstr "如果令牌的最后认证时间早于7h，10d或1y，则触发操作。"

#: lib/eventhandler/base.py:254
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth' is bigger than 100, less than 99 or exactly 100."
msgstr ""
"如果tokeninfo字段'count_auth'大于100，小于99或恰好是100，则可以为'> "
"100'，'<99'或'= 100'来触发操作。"

#: lib/eventhandler/base.py:261
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth_success' is bigger than 100, less than 99 or "
"exactly 100."
msgstr ""
"如果tokeninfo字段'count_auth_success'大于100，小于99或正好是100，则可以为'> "
"100'，'<99'或'= 100'来触发操作。"

#: lib/eventhandler/base.py:269
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"difference between the tokeninfo field 'count_auth' and 'count_auth_success "
"is bigger than 100, less than 99 or exactly 100."
msgstr ""
"如果tokeninfo字段'count_auth'和'count_auth_success之间的差大于100，小于99或恰"
"好是100，则可以为'> 100'，'<99'或'= 100'来触发操作。"

#: lib/eventhandler/base.py:277
msgid ""
"This can be '>9', '<9', or '=10', to trigger the action, if the failcounter "
"of a token matches this value. Note that the failcounter stops increasing, "
"if the max_failcount is reached."
msgstr ""
"如果令牌的故障计数器与此值匹配，则可以为'> 9'，'<9'或'= 10'来触发操作。请注"
"意，如果达到max_failcount，则故障计数器将停止增加。"

#: lib/eventhandler/base.py:285
msgid ""
"This condition can check any arbitrary tokeninfo field. You need to enter "
"something like '<fieldname> == <fieldvalue>', '<fieldname> > <fieldvalue>' "
"or '<fieldname> < <fieldvalue>'."
msgstr ""
"此条件可以检查任何任意的tokeninfo字段。您需要输入类似“ <字段名称> == <字段值"
">”，“ <字段名称>> <字段值>”或“ <字段名称> <<字段值>”之类的内容。"

#: lib/eventhandler/base.py:293
msgid ""
"This condition can check the value of an arbitrary event counter and compare "
"it like 'myCounter == 1000', 'myCounter > 1000' or 'myCounter < 1000'."
msgstr ""
"此条件可以检查任意事件计数器的值并进行比较，例如“ myCounter == 1000”，“ "
"myCounter> 1000”或“ myCounter <1000”。"

#: lib/eventhandler/base.py:300
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->error->message in the response."
msgstr ""
"在这里您可以输入正则表达式。仅当正则表达式与响应中的detail-> error-> message"
"相匹配时，该条件才适用。"

#: lib/eventhandler/base.py:307
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->message in the response."
msgstr ""
"在这里您可以输入正则表达式。仅当正则表达式与响应中的detail-> message相匹配"
"时，该条件才适用。"

#: lib/eventhandler/base.py:314
msgid "Trigger the action, if the client IP matches."
msgstr "如果客户端IP匹配，则触发操作。"

#: lib/eventhandler/counterhandler.py:69 lib/eventhandler/counterhandler.py:74
#: lib/eventhandler/counterhandler.py:82
msgid "The identifier/key of the counter."
msgstr "计数器的标识符/密钥。"

#: lib/eventhandler/counterhandler.py:77
msgid "Don't stop counter if it reaches zero."
msgstr "如果计数器达到零，请不要停止。"

#: lib/eventhandler/customuserattributeshandler.py:61
msgid "The user for whom the custom attribute should be set."
msgstr "应设置自定义属性的用户。"

#: lib/eventhandler/customuserattributeshandler.py:68
msgid "The key of the custom user attribute that should be set."
msgstr "应设置的自定义用户属性的键。"

#: lib/eventhandler/customuserattributeshandler.py:71
msgid "The value of the custom user attribute."
msgstr ""

#: lib/eventhandler/customuserattributeshandler.py:77
msgid "The user from which the custom attribute should be deleted."
msgstr "应删除自定义属性的用户。"

#: lib/eventhandler/customuserattributeshandler.py:84
msgid "The key of the custom user attribute that should be deleted."
msgstr "应该删除的自定义用户属性的键。"

#: lib/eventhandler/federationhandler.py:76
msgid "The remote/child privacyIDEA Server."
msgstr "远程/子级privacyIDEA服务器。"

#: lib/eventhandler/federationhandler.py:81
msgid "Change the realm name to a realm on the child privacyIDEA system."
msgstr "将领域名称更改为子privacyIDEA系统上的领域。"

#: lib/eventhandler/federationhandler.py:87
msgid "Change the resolver name to a resolver on the child privacyIDEA system."
msgstr "在子privacyIDEA系统上将解析器名称更改为解析器。"

#: lib/eventhandler/federationhandler.py:93
msgid ""
"Forward the client IP to the child privacyIDEA server. Otherwise this server "
"will be the client."
msgstr "将客户端IP转发到子privacyIDEA服务器。否则，该服务器将成为客户端。"

#: lib/eventhandler/federationhandler.py:100
msgid ""
"Forward the authorization header. This allows to also forward request like "
"token- and system-requests."
msgstr "转发授权标头。这还可以转发诸如令牌请求和系统请求之类的请求。"

#: lib/eventhandler/logginghandler.py:87
msgid "The name of the logging facility"
msgstr "日志记录设施的名称"

#: lib/eventhandler/logginghandler.py:93
msgid "The string to write to the log"
msgstr "写入日志的字符串"

#: lib/eventhandler/logginghandler.py:99
msgid "The logging level for this logging notification"
msgstr "此日志记录通知的日志记录级别"

#: lib/eventhandler/requestmangler.py:100
msgid "The parameter that should be deleted."
msgstr "应该删除的参数。"

#: lib/eventhandler/requestmangler.py:106
msgid "The parameter that should be added or modified."
msgstr "应该添加或修改的参数。"

#: lib/eventhandler/requestmangler.py:111
msgid ""
"The new value of the parameter. Can contain tags like {0}, {1} for the "
"matched sub strings."
msgstr "参数的新值。可以包含诸如{0}，{1}之类的标签作为匹配的子字符串。"

#: lib/eventhandler/requestmangler.py:116
msgid "The parameter, that should match some values."
msgstr "该参数应与某些值匹配。"

#: lib/eventhandler/requestmangler.py:120
msgid ""
"The value of the match_parameter. It can contain a regular expression and "
"'()' to transfer values to the new parameter."
msgstr ""
"match_parameter的值。它可以包含一个正则表达式和'（）'来将值传输到新参数。"

#: lib/eventhandler/responsemangler.py:81
msgid ""
"The JSON pointer (key) that should be deleted. Please specify in the format "
"'/detail/message'."
msgstr "应该删除的JSON指针（键）。请以'/ detail / message'格式指定。"

#: lib/eventhandler/responsemangler.py:88
msgid ""
"The JSON pointer (key) that should be set. Please specify in the format '/"
"detail/message'."
msgstr "应该设置的JSON指针（键）。请以'/ detail / message'格式指定。"

#: lib/eventhandler/responsemangler.py:94
msgid "The type of the value."
msgstr "值的类型。"

#: lib/eventhandler/responsemangler.py:100
msgid "The value of the JSON key that should be set."
msgstr "应该设置的JSON密钥的值。"

#: lib/eventhandler/scripthandler.py:96
#: lib/smsprovider/ScriptSMSProvider.py:123
msgid ""
"Wait for script to complete or run script in background. This will either "
"return the HTTP request early or could also block the request."
msgstr ""
"等待脚本完成或在后台运行脚本。这将提早返回HTTP请求，或者也可能阻止该请求。"

#: lib/eventhandler/scripthandler.py:104
msgid "On script error raise exception in HTTP request."
msgstr "在脚本错误上引发HTTP请求中的异常。"

#: lib/eventhandler/scripthandler.py:108
msgid ""
"Finish current transaction before running the script. This is useful if "
"changes to the database should be made available to the script or the "
"running request."
msgstr ""
"在运行脚本之前完成当前事务。如果应该使脚本或正在运行的请求可以使用对数据库的"
"更改，则这很有用。"

#: lib/eventhandler/scripthandler.py:115
msgid "Add '--serial <serial number>' as script parameter."
msgstr "添加“ --serial <序列号>”作为脚本参数。"

#: lib/eventhandler/scripthandler.py:120
msgid "Add '--user <username>' as script parameter."
msgstr "添加“ --user <用户名>”作为脚本参数。"

#: lib/eventhandler/scripthandler.py:125
msgid "Add '--realm <realm>' as script parameter."
msgstr "添加“ --realm <realm>”作为脚本参数。"

#: lib/eventhandler/scripthandler.py:130
msgid ""
"Add the username of the logged in user as script parameter like '--"
"logged_in_user <username>'."
msgstr "将登录用户的用户名添加为脚本参数，例如“ --logged_in_user <用户名>”。"

#: lib/eventhandler/scripthandler.py:136
msgid ""
"Add the role (either admin or user) of the logged in user as script "
"parameter like '--logged_in_role <role>'."
msgstr ""
"将已登录用户的角色（管理员或用户）添加为脚本参数，例如'--logged_in_role "
"<role>'。"

#: lib/eventhandler/tokenhandler.py:139
msgid "set a new realm of the token"
msgstr "设置令牌的新领域"

#: lib/eventhandler/tokenhandler.py:143
#, fuzzy
msgid ""
"The new realm will be the only realm of the token. I.e. all other realms "
"will be removed from this token. If disabled, the realm will be added to the "
"token."
msgstr ""
"新领域将是令牌的唯一领域。即所有其他领域将从此令牌中删除。否则，领域将被添加"
"到令牌中。"

#: lib/eventhandler/tokenhandler.py:158
msgid "set the PIN of the token to a random PIN of this length."
msgstr "将令牌的PIN设置为此长度的随机PIN。"

#: lib/eventhandler/tokenhandler.py:165
msgid "Token type to create"
msgstr "要创建的令牌类型"

#: lib/eventhandler/tokenhandler.py:170
msgid "Assign token to user in request or to tokenowner."
msgstr "将令牌分配给请求中的用户或令牌所有者。"

#: lib/eventhandler/tokenhandler.py:175
msgid "Set the realm of the newly created token."
msgstr "设置新创建的令牌的领域。"

#: lib/eventhandler/tokenhandler.py:182
msgid "Dynamically read the mobile number from the user store."
msgstr "从用户商店动态读取手机号码。"

#: lib/eventhandler/tokenhandler.py:189
msgid "Dynamically read the email address from the user store."
msgstr "从用户商店动态读取电子邮件地址。"

#: lib/eventhandler/tokenhandler.py:196
msgid "Use a specific SMTP server configuration for this token."
msgstr ""

#: lib/eventhandler/tokenhandler.py:203
msgid "Use a specific SMS gateway configuration for this token."
msgstr ""

#: lib/eventhandler/tokenhandler.py:208
msgid "A dictionary of additional init parameters."
msgstr "从用户商店动态读取电子邮件地址。"

#: lib/eventhandler/tokenhandler.py:214
msgid ""
"Set the MOTP PIN of the MOTP token during enrollment. This is a required "
"value for enrolling MOTP tokens."
msgstr "在注册期间设置MOTP令牌的MOTP PIN。这是注册MOTP令牌的必需值。"

#: lib/eventhandler/tokenhandler.py:223
msgid "The new description of the token."
msgstr "令牌的新描述。"

#: lib/eventhandler/tokenhandler.py:230
msgid ""
"The token will be valid starting at the given date. Can be a fixed date or "
"an offset like +10m, +24h, +7d."
msgstr ""
"令牌将从给定日期开始有效。可以是固定日期，也可以是偏移量，例如+ 10m，+ "
"24h，+ 7d。"

#: lib/eventhandler/tokenhandler.py:237
msgid ""
"The token will be valid until the given date. Can be a fixed date or an "
"offset like +10m, +24h, +7d."
msgstr ""
"该令牌在给定日期之前一直有效。可以是固定日期，也可以是偏移量，例如+ 10m，+ "
"24h，+ 7d。"

#: lib/eventhandler/tokenhandler.py:250
msgid "Set the new count window of the token."
msgstr "设置令牌的新计数窗口。"

#: lib/eventhandler/tokenhandler.py:260
msgid "Set the failcounter of the token."
msgstr "设置令牌的故障计数器。"

#: lib/eventhandler/tokenhandler.py:270
msgid ""
"Increase or decrease the fail counter of the token. Values of +n, -n with n "
"being an integer are accepted."
msgstr ""

#: lib/eventhandler/tokenhandler.py:280
msgid "Set the maximum failcounter of the token."
msgstr "设置令牌的最大失败次数。"

#: lib/eventhandler/tokenhandler.py:288
msgid "Set this tokeninfo key."
msgstr "设置此tokeninfo密钥。"

#: lib/eventhandler/tokenhandler.py:293
#, fuzzy
msgid "Set the above key to this value."
msgstr "将上面的键设置为此值。"

#: lib/eventhandler/tokenhandler.py:302
msgid "Delete this tokeninfo key."
msgstr "删除此tokeninfo密钥。"

#: lib/eventhandler/tokenhandler.py:310
msgid "Add a tokengroup to the token."
msgstr "将令牌组添加到令牌。"

#: lib/eventhandler/tokenhandler.py:319
msgid "Remove a tokengroup from the token."
msgstr ""

#: lib/eventhandler/tokenhandler.py:328
msgid "The ID of the machine you want to attach the token to"
msgstr ""

#: lib/eventhandler/tokenhandler.py:334
msgid "Set the service_id for an SSH application."
msgstr ""

#: lib/eventhandler/tokenhandler.py:342
msgid ""
"Set a token application like 'offline' or 'SSH'. Note: Not all tokens work "
"well with all applications!"
msgstr ""

#: lib/eventhandler/tokenhandler.py:351
msgid "The number of offline OTP values available"
msgstr ""

#: lib/eventhandler/tokenhandler.py:359
msgid "The number of rounds for password hashing"
msgstr ""

#: lib/eventhandler/usernotification.py:123
msgid "Send notification email via this email server."
msgstr "通过此电子邮件服务器发送通知电子邮件。"

#: lib/eventhandler/usernotification.py:127
msgid "Either send email as plain text or HTML."
msgstr "以纯文本或HTML格式发送电子邮件。"

#: lib/eventhandler/usernotification.py:131
msgid "Send QR-Code image as an attachment (cid URL: token_image)"
msgstr "发送QR码图像作为附件（cid URL：token_image）"

#: lib/eventhandler/usernotification.py:136
msgid "The subject of the mail that is sent."
msgstr "发送邮件的主题。"

#: lib/eventhandler/usernotification.py:140
msgid "The Reply-To header in the sent email."
msgstr "发送的电子邮件中的Reply-To标头。"

#: lib/eventhandler/usernotification.py:162
#: lib/eventhandler/usernotification.py:194
msgid "Any email address, to which the notification should be sent."
msgstr "通知应发送到的任何电子邮件地址。"

#: lib/eventhandler/usernotification.py:169
msgid "The body of the mail that is sent."
msgstr "发送的邮件正文。"

#: lib/eventhandler/usernotification.py:173
#: lib/eventhandler/usernotification.py:211
msgid "Send notification to this user."
msgstr "向该用户发送通知。"

#: lib/eventhandler/usernotification.py:203
msgid "Send the user notification via a predefined SMS gateway."
msgstr "通过预定义的SMS网关发送用户通知。"

#: lib/eventhandler/usernotification.py:208
msgid "The text of the SMS."
msgstr "SMS的文本。"

#: lib/eventhandler/usernotification.py:218
msgid ""
"This is the template content of the new file. Can contain the tags as "
"specified in the documentation."
msgstr "这是新文件的模板内容。可以包含文档中指定的标签。"

#: lib/eventhandler/usernotification.py:224
msgid ""
"The filename of the notification. Existing files are overwritten. The name "
"can contain tags as specified in the documentation and can also contain the "
"tag {random}."
msgstr ""
"通知的文件名。现有文件将被覆盖。该名称可以包含文档中指定的标签，也可以包含标"
"签{random}。"

#: lib/eventhandler/webhookeventhandler.py:86
msgid "The URL the WebHook is posted to"
msgstr ""

#: lib/eventhandler/webhookeventhandler.py:91
msgid "The encoding that is sent to the WebHook, for example json"
msgstr ""

#: lib/eventhandler/webhookeventhandler.py:99
msgid "You can replace placeholder like {logged_in_user}"
msgstr ""

#: lib/eventhandler/webhookeventhandler.py:104
msgid "The data posted in the WebHook"
msgstr ""

#: lib/machines/ldap.py:338
#, python-format
msgid "Your LDAP config seems to be OK, %i machine objects found."
msgstr "您的LDAP配置似乎正常，%i机器对象已发现。"

#: lib/resolvers/LDAPIdResolver.py:1130
msgid ""
"Your LDAP config found {0!s} user objects, but only {1!s} with the specified "
"uidtype"
msgstr ""
"您的LDAP配置找到{0！s}个用户对象，但只有{1！s}个具有指定uidtype的用户对象"

#: lib/resolvers/LDAPIdResolver.py:1133
msgid "Your LDAP config seems to be OK, {0!s} user objects found."
msgstr "您的LDAP配置似乎正常，找到了{0！s}个用户对象。"

#: lib/smsprovider/FirebaseProvider.py:201
msgid ""
"The filename of the JSON config file, that allows privacyIDEA to talk to the "
"Firebase REST API."
msgstr "JSON配置文件的文件名，允许privacyIDEA与Firebase REST API进行通信。"

#: lib/smsprovider/FirebaseProvider.py:206
msgid "Proxy setting for HTTPS connections to googleapis.com."
msgstr "HTTPS与googleapis.com的连接的代理设置。"

#: lib/smsprovider/HttpSMSProvider.py:244
msgid "The base URL of the HTTP Gateway"
msgstr "HTTP网关的基本URL"

#: lib/smsprovider/HttpSMSProvider.py:247
msgid "Should the HTTP Gateway be connected via an HTTP GET or POST request."
msgstr "是否应通过HTTP GET或POST请求连接HTTP网关。"

#: lib/smsprovider/HttpSMSProvider.py:252
msgid ""
"Specify a substring, that indicates, that the SMS was delivered successfully."
msgstr "指定一个子字符串，它指示SMS已成功传递。"

#: lib/smsprovider/HttpSMSProvider.py:256
msgid ""
"Specify a substring, that indicates, that the SMS failed to be delivered."
msgstr "指定一个子字符串，该字符串指示SMS传递失败。"

#: lib/smsprovider/HttpSMSProvider.py:260
msgid "Username in case of basic authentication."
msgstr "基本身份验证的用户名。"

#: lib/smsprovider/HttpSMSProvider.py:264
msgid "Password in case of basic authentication."
msgstr "基本身份验证时输入密码。"

#: lib/smsprovider/HttpSMSProvider.py:269
msgid "Should the SSL certificate be verified."
msgstr "应该验证SSL证书。"

#: lib/smsprovider/HttpSMSProvider.py:275
msgid "Should the data in a POST Request be sent as JSON."
msgstr ""

#: lib/smsprovider/HttpSMSProvider.py:282
msgid ""
"An optional proxy string. DEPRECATED. Do not use this anymore. Rather use "
"HTTP_PROXY for http connections and HTTPS_PROXY for https connection. The "
"PROXY option will be removed in future."
msgstr ""
"可选的代理字符串。已淘汰。不要再使用它了。而是将HTTP_PROXY用于HTTP连接，将"
"HTTPS_PROXY用于https连接。将来会删除PROXY选项。"

#: lib/smsprovider/HttpSMSProvider.py:287
msgid "Proxy setting for HTTP connections."
msgstr "HTTP连接的代理设置。"

#: lib/smsprovider/HttpSMSProvider.py:288
msgid "Proxy setting for HTTPS connections."
msgstr "HTTPS连接的代理设置。"

#: lib/smsprovider/HttpSMSProvider.py:289
msgid "The timeout in seconds."
msgstr "超时（以秒为单位）。"

#: lib/smsprovider/SMSProvider.py:76
#, fuzzy
msgid ""
"Regular expression to modify the phone number to make it compatible with "
"provider. For example to remove pluses and slashes enter something like '/[\\"
"+/]//'."
msgstr ""
"用于修改电话号码以使其与提供程序兼容的正则表达式。输入“ / [\\ + /] //”之类的"
"内容以删除加号和斜杠。"

#: lib/smsprovider/ScriptSMSProvider.py:115
msgid ""
"The script in script directory PI_SCRIPT_SMSPROVIDER_DIRECTORY to call. "
"Expects phone as the parameter and the message from stdin."
msgstr ""
"脚本目录PI_SCRIPT_SMSPROVIDER_DIRECTORY中要调用的脚本。期望将phone作为参数，"
"并接收来自stdin的消息。"

#: lib/smsprovider/SmppSMSProvider.py:127
msgid "SMSC Host IP"
msgstr "SMS主机IP"

#: lib/smsprovider/SmppSMSProvider.py:130
msgid "SMSC Port"
msgstr "SMS主机端口"

#: lib/smsprovider/SmppSMSProvider.py:132
msgid "SMSC Service ID"
msgstr "SMS主机 ID"

#: lib/smsprovider/SmppSMSProvider.py:134
msgid "Password for authentication on SMSC"
msgstr "SMS主机上的认证密码"

#: lib/smsprovider/SmppSMSProvider.py:136
msgid "SOURCE_ADDR_TON Special Flag"
msgstr "SOURCE_ADDR_TON特殊标志"

#: lib/smsprovider/SmppSMSProvider.py:138
msgid "S_ADDR_NPI Special Flag"
msgstr "S_ADDR_NPI特殊标志"

#: lib/smsprovider/SmppSMSProvider.py:140
msgid "Source address (SMS sender)"
msgstr "源地址（SMS发件人）"

#: lib/smsprovider/SmppSMSProvider.py:141
msgid "DESTINATION_ADDR_TON Special Flag"
msgstr "DESTINATION_ADDR_TON特殊标志"

#: lib/smsprovider/SmppSMSProvider.py:142
msgid "D_ADDR_NPI Special Flag"
msgstr "D_ADDR_NPI特殊标志"

#: lib/task/eventcounter.py:42
msgid "The name of the event counter to read."
msgstr "要读取的事件计数器的名称。"

#: lib/task/eventcounter.py:47
msgid "The name of the stats key to write to the MonitoringStats table."
msgstr "写入到MonitoringStats表的stats键的名称。"

#: lib/task/eventcounter.py:53
msgid ""
"Whether to reset the event_counter, if it is read and written to the "
"MonitoringStats table."
msgstr "是否重置event_counter（如果已将其读写到MonitoringStats表中）。"

#: lib/task/simplestats.py:48
msgid "Total number of tokens"
msgstr "本地令牌数量"

#: lib/task/simplestats.py:51
msgid "Total number of hardware tokens"
msgstr "本地硬件令牌数量"

#: lib/task/simplestats.py:54
msgid "Total number of software tokens"
msgstr "本地软件令牌数量"

#: lib/task/simplestats.py:57
msgid "Number of hardware tokens not assigned to a user"
msgstr "未分配给用户的硬件令牌数量"

#: lib/task/simplestats.py:60
msgid "Number of tokens assigned to users"
msgstr "分配给用户的令牌数量"

#: lib/task/simplestats.py:63
msgid "Number of users with tokens assigned"
msgstr "分配了令牌的用户数"

#: lib/tokens/applicationspecificpasswordtoken.py:76
msgid ""
"Application Specific Password: A token with a fixed password. Can be used "
"for certain applications or services."
msgstr ""

#: lib/tokens/applicationspecificpasswordtoken.py:87
#, fuzzy
msgid ""
"The user may only have this maximum number of application specific password "
"tokens assigned."
msgstr "用户只能分配此最大数量的活动密码令牌。"

#: lib/tokens/applicationspecificpasswordtoken.py:93
#, fuzzy
msgid ""
"The user may only have this maximum number of active application specific "
"password tokens assigned."
msgstr "用户只能分配此最大数量的活动密码令牌。"

#: lib/tokens/certificatetoken.py:282
msgid "Certificate: Enroll an x509 Certificate Token."
msgstr "证书：注册一个 x509 证书令牌。"

#: lib/tokens/certificatetoken.py:293
msgid "The user may only have this maximum number of certificates assigned."
msgstr "用户只能分配此最大数量的证书。"

#: lib/tokens/certificatetoken.py:298
msgid ""
"The user may only have this maximum number of active certificates assigned."
msgstr "用户只能分配此最大数量的活动证书。"

#: lib/tokens/certificatetoken.py:303
msgid ""
"Enrolling a certificate token can require an attestation certificate. "
"(Default: ignore)"
msgstr ""

#: lib/tokens/certificatetoken.py:312
msgid "The CA connector that should be used during certificate enrollment."
msgstr "证书注册期间应使用的 CA 连接器。"

#: lib/tokens/certificatetoken.py:318
msgid "The template that should be used to issue a certificate."
msgstr "应该用于颁发证书的模板。"

#: lib/tokens/certificatetoken.py:323
msgid ""
"This takes a space separated list of elements to be added to the subject. "
"Can be 'email' and 'realm'."
msgstr ""
"需要一个要添加到主题的元素组成的列表， 不同元素间用空格隔开。 可以是“电子邮"
"件”和“领域”。"

#: lib/tokens/certificatetoken.py:331 lib/tokens/certificatetoken.py:338
msgid "The directory containing attestation certificate chains."
msgstr ""

#: lib/tokens/daplugtoken.py:124
msgid "event based OTP token using the HOTP algorithm"
msgstr "使用HOTP算法的基于事件的OTP令牌"

#: lib/tokens/daplugtoken.py:130
msgid "The user may only have this maximum number of daplug tokens assigned."
msgstr "用户只能分配此最大数量的daplug令牌。"

#: lib/tokens/daplugtoken.py:135
msgid ""
"The user may only have this maximum number of active daplug tokens assigned."
msgstr "用户只能分配此最大数量的活动daplug令牌。"

#: lib/tokens/daypasswordtoken.py:36
#, fuzzy
msgid "Specify the time step of the DayPassword token."
msgstr "设定生成的密码令牌的密码的长度。"

#: lib/tokens/daypasswordtoken.py:84
msgid ""
"DayPassword: A time-based token with a variable timestep and the possibility "
"to use the OTP more than once."
msgstr ""

#: lib/tokens/daypasswordtoken.py:121 lib/tokens/hotptoken.py:176
#: lib/tokens/totptoken.py:161
msgid "Enforce setting an app pin for the privacyIDEA Authenticator App"
msgstr "强制为privacyIDEA Authenticator App设置应用程序PIN"

#: lib/tokens/daypasswordtoken.py:126
#, fuzzy
msgid ""
"The user may only have this maximum number of daypassword tokens assigned."
msgstr "用户只能分配此最大数量的密码令牌。"

#: lib/tokens/daypasswordtoken.py:132
#, fuzzy
msgid ""
"The user may only have this maximum number of active daypassword tokens "
"assigned."
msgstr "用户只能分配此最大数量的活动密码令牌。"

#: lib/tokens/emailtoken.py:156
msgid "EMail Token"
msgstr "电子邮件令牌"

#: lib/tokens/emailtoken.py:158
msgid "EMail: Send a One Time Password to the users email address."
msgstr "电子邮件：向用户的电子邮件地址发送一次性密码。"

#: lib/tokens/emailtoken.py:166
msgid ""
"The text that will be sent via EMail for an EMail-token. Several tags like "
"{otp} and {serial} can be used as parameters. You may also specify a "
"filename as email template starting with \"file:\"."
msgstr ""
"将通过电子邮件发送的电子邮件令牌的文本。可以使用如 <otp> 和 <serial> 等标签作"
"为参数。你也可以将文件名指定为以“ file：”开头的电子邮件模板。"

#: lib/tokens/emailtoken.py:173
msgid ""
"The subject of the EMail for an EMail token. Use tags like {otp} and "
"{serial} as parameters."
msgstr "电子邮件令牌的电子邮件主题。使用 <otp> 和 <serial> 等标签作为参数。"

#: lib/tokens/emailtoken.py:178
msgid ""
"If set, a new EMail OTP will be sent after successful authentication with "
"one EMail OTP."
msgstr ""
"如果设置，则在通过一个电子邮件OTP成功进行身份验证之后，将发送新的电子邮件"
"OTP。"

#: lib/tokens/emailtoken.py:183
msgid ""
"Use an alternate challenge text for telling the user to enter the code from "
"the eMail."
msgstr "使用替代质询文本告诉用户输入电子邮件中的代码。"

#: lib/tokens/emailtoken.py:190
msgid "The user may only have this maximum number of email tokens assigned."
msgstr "用户只能分配此最大数量的电子邮件令牌。"

#: lib/tokens/emailtoken.py:195
msgid ""
"The user may only have this maximum number of active email tokens assigned."
msgstr "用户只能分配此最大数量的活动电子邮件令牌。"

#: lib/tokens/emailtoken.py:277
msgid "Enter the OTP from the Email:"
msgstr "从电子邮件中输入OTP："

#: lib/tokens/emailtoken.py:316
msgid "The PIN was correct, but the EMail could not be sent!"
msgstr ""

#: lib/tokens/emailtoken.py:547
msgid "Please enter your new email address!"
msgstr "请输入你的新邮箱地址！"

#: lib/tokens/foureyestoken.py:132
msgid "4Eyes Token: Use tokens of two or more users to authenticate"
msgstr "4Eyes令牌：使用两个或多个用户的令牌进行身份验证"

#: lib/tokens/foureyestoken.py:143
msgid "The user may only have this maximum number of 4eyes tokens assigned."
msgstr "用户只能分配此最大数量的4eyes令牌。"

#: lib/tokens/foureyestoken.py:148
msgid ""
"The user may only have this maximum number of active 4eyes tokens assigned."
msgstr "用户只能分配此最大数量的活动4eyes令牌。"

#: lib/tokens/hotptoken.py:85
msgid "Please enter a valid OTP value of the new token."
msgstr ""

#: lib/tokens/hotptoken.py:100
msgid "Specify the hashing function to be used. Can be SHA1, SHA256 or SHA512."
msgstr "指定要使用的 hashlib 函数。可以是 SHA1、SHA256 或 SHA512。"

#: lib/tokens/hotptoken.py:102
msgid "Specify the OTP length to be used. Can be 6 or 8 digits."
msgstr "指定要使用的 OTP 长度。 可以是 6 位或 8 位数字。"

#: lib/tokens/hotptoken.py:103
msgid "Force the key to be generated on the server."
msgstr "强制在服务器上生成密钥."

#: lib/tokens/hotptoken.py:104
msgid "Specify whether users are allowed or forced to use two-step enrollment."
msgstr "指定是允许还是强制用户使用两步注册。"

#: lib/tokens/hotptoken.py:106
msgid ""
"Specify whether admins are allowed or forced to use two-step enrollment."
msgstr "指定是允许还是强制管理员使用两步注册。"

#: lib/tokens/hotptoken.py:143
msgid "HOTP: Event based One Time Passwords."
msgstr "HOTP：基于事件的一次性密码。"

#: lib/tokens/hotptoken.py:151
msgid "The user may only have this maximum number of HOTP tokens assigned."
msgstr "用户只能分配此最大数量的HOTP令牌。"

#: lib/tokens/hotptoken.py:156
msgid ""
"The user may only have this maximum number of active HOTP tokens assigned."
msgstr "用户只能分配此最大数量的活动HOTP令牌。"

#: lib/tokens/hotptoken.py:161 lib/tokens/totptoken.py:150
msgid "The size of the OTP seed part contributed by the client (in bytes)"
msgstr "客户端贡献的OTP种子部分的大小（以字节为单位）"

#: lib/tokens/hotptoken.py:166 lib/tokens/totptoken.py:153
msgid "The size of the OTP seed part contributed by the server (in bytes)"
msgstr "服务器贡献的OTP种子部分的大小（以字节为单位）"

#: lib/tokens/hotptoken.py:171 lib/tokens/totptoken.py:156
msgid ""
"The difficulty factor used for the OTP seed generation (should be at least "
"10000)"
msgstr "用于生成OTP种子的难度系数（至少应为10000）"

#: lib/tokens/hotptoken.py:282
msgid "URL for google Authenticator"
msgstr "谷歌身份验证器的URL"

#: lib/tokens/hotptoken.py:295
msgid "URL for OATH token"
msgstr "OATH令牌的URL"

#: lib/tokens/hotptoken.py:827 lib/tokens/pushtoken.py:1048
msgid "Please scan the QR code!"
msgstr "请扫描二维码！"

#: lib/tokens/indexedsecrettoken.py:51
msgid "Please enter the positions {0!s} from your secret."
msgstr "请从您的秘密中输入职位{0！s}。"

#: lib/tokens/indexedsecrettoken.py:100
msgid "Indexed Secret Token"
msgstr "索引安全令牌"

#: lib/tokens/indexedsecrettoken.py:102
msgid ""
"IndexedSecret: Request certain positions of a shared secret from the user."
msgstr "ndexedSecret：向用户请求共享机密的某些位置。"

#: lib/tokens/indexedsecrettoken.py:109
msgid ""
"Use an alternate challenge text for telling the user which positions of the "
"secret he should enter."
msgstr "使用备用质询文本来告诉用户应该输入的机密位置。"

#: lib/tokens/indexedsecrettoken.py:115
msgid "Number of necessary positions to be answered by the user."
msgstr "用户需要回答的必要职位数。"

#: lib/tokens/indexedsecrettoken.py:122
msgid "Preset the enrollment with the value of the given attribute."
msgstr "使用给定属性的值预设注册。"

#: lib/tokens/indexedsecrettoken.py:129 lib/tokens/indexedsecrettoken.py:136
msgid "The attribute whose value should be force set during enrollment."
msgstr "在注册期间应强制设置其值的属性。"

#: lib/tokens/indexedsecrettoken.py:143
msgid ""
"The user may only have this maximum number of indexed secret tokens assigned."
msgstr "用户只能分配此最大数目的索引安全令牌。"

#: lib/tokens/indexedsecrettoken.py:148
msgid ""
"The user may only have this maximum number of active indexed secret tokens "
"assigned."
msgstr "用户只能分配此最大数目的活动索引安全令牌。"

#: lib/tokens/motptoken.py:105
msgid "The user may only have this maximum number of mOTP tokens assigned."
msgstr "用户只能分配此最大数量的mOTP令牌。"

#: lib/tokens/motptoken.py:110
msgid ""
"The user may only have this maximum number of active mOTP tokens assigned."
msgstr "用户只能分配此最大数量的活动mOTP令牌。"

#: lib/tokens/motptoken.py:153
msgid "URL for MOTP token"
msgstr "MOTP令牌的URL"

#: lib/tokens/ocratoken.py:91
msgid "OCRA: Enroll an OCRA token."
msgstr "OCRA：注册OCRA令牌。"

#: lib/tokens/ocratoken.py:101
msgid "The user may only have this maximum number of OCRA tokens assigned."
msgstr "用户只能分配此最大数量的OCRA令牌。"

#: lib/tokens/ocratoken.py:106
msgid ""
"The user may only have this maximum number of active OCRA tokens assigned."
msgstr "用户只能分配此最大数量的活动OCRA令牌。"

#: lib/tokens/papertoken.py:109 lib/tokens/tantoken.py:107
msgid "The number of OTP values, which are printed on the paper."
msgstr "在纸上打印的OTP值的数量。"

#: lib/tokens/papertoken.py:114
msgid "The user may only have this maximum number of paper tokens assigned."
msgstr "用户只能分配此最大数量的纸质令牌。"

#: lib/tokens/papertoken.py:119
msgid ""
"The user may only have this maximum number of active paper tokens assigned."
msgstr "用户只能分配此最大数量的活动纸质令牌。"

#: lib/tokens/passwordtoken.py:115
msgid ""
"A token with a fixed password. Can be combined  with the OTP PIN. Is used "
"for the lost token scenario."
msgstr "具有固定密码的令牌。可以结合  使用OTP PIN。用于丢失的令牌方案。"

#: lib/tokens/passwordtoken.py:127
msgid "The user may only have this maximum number of password tokens assigned."
msgstr "用户只能分配此最大数量的密码令牌。"

#: lib/tokens/passwordtoken.py:132
msgid ""
"The user may only have this maximum number of active password tokens "
"assigned."
msgstr "用户只能分配此最大数量的活动密码令牌。"

#: lib/tokens/pushtoken.py:71
msgid "Please confirm the authentication on your mobile device!"
msgstr "请在您的移动设备上确认身份验证！"

#: lib/tokens/pushtoken.py:72
msgid ""
"Use the polling feature of your privacyIDEA Authenticator App to check for a "
"new Login request."
msgstr ""

#: lib/tokens/pushtoken.py:74
msgid "Do you want to confirm the login?"
msgstr "您要确认登录吗？"

#: lib/tokens/pushtoken.py:300
msgid "PUSH Token"
msgstr "PUSH 令牌"

#: lib/tokens/pushtoken.py:302
msgid "PUSH: Send a push notification to a smartphone."
msgstr "推送：向智能手机发送推送通知。"

#: lib/tokens/pushtoken.py:310
msgid "The configuration of your Firebase application."
msgstr "Firebase应用程序的配置。"

#: lib/tokens/pushtoken.py:318
msgid ""
"The URL the Push App should contact in the second enrollment step. Usually "
"it is the endpoint /ttype/push of the privacyIDEA server."
msgstr ""
"Push App在第二个注册步骤中应联系的URL。通常，它是privacyIDEA服务器的端点/ "
"ttype / push。"

#: lib/tokens/pushtoken.py:324
msgid ""
"The second enrollment step must be completed within this time (in minutes)."
msgstr "第二个注册步骤必须在此时间内（以分钟为单位）完成。"

#: lib/tokens/pushtoken.py:328
msgid "The smartphone needs to verify SSL during the enrollment. (default 1)"
msgstr "智能手机需要在注册过程中验证SSL。（默认为1）"

#: lib/tokens/pushtoken.py:334
msgid "The user may only have this maximum number of Push tokens assigned."
msgstr "用户只能分配此最大数量的Push令牌。"

#: lib/tokens/pushtoken.py:339
msgid ""
"The user may only have this maximum number of active Push tokens assigned."
msgstr "用户只能分配此最大数量的活动Push令牌。"

#: lib/tokens/pushtoken.py:345
msgid "Require to unlock the Smartphone before Push requests can be accepted"
msgstr ""

#: lib/tokens/pushtoken.py:351
msgid "The question the user sees on his mobile phone."
msgstr "用户在手机上看到的问题。"

#: lib/tokens/pushtoken.py:356
msgid "The title of the notification, the user sees on his mobile phone."
msgstr "用户在手机上看到的通知标题。"

#: lib/tokens/pushtoken.py:361
msgid "The smartphone needs to verify SSL during authentication. (default 1)"
msgstr "智能手机需要在身份验证期间验证SSL。（默认为1）"

#: lib/tokens/pushtoken.py:367
msgid ""
"Wait for number of seconds for the user to confirm the challenge in the "
"first request."
msgstr "等待秒数，以便用户在第一个请求中确认挑战。"

#: lib/tokens/pushtoken.py:373
msgid "Configure whether to allow push tokens to poll for challenges"
msgstr "配置是否允许推送令牌轮询挑战"

#: lib/tokens/pushtoken.py:508
msgid "URL for privacyIDEA Push Token"
msgstr "privacyIDEA的推送令牌URL"

#: lib/tokens/questionnairetoken.py:98
msgid "Questionnaire: Enroll Questions for the user."
msgstr "问卷：为用户注册问题。"

#: lib/tokens/questionnairetoken.py:109
msgid "The user has to answer this number of questions during authentication."
msgstr ""

#: lib/tokens/questionnairetoken.py:117
msgid ""
"The user may only have this maximum number of questionaire tokens assigned."
msgstr "用户只能分配此最大数量的问卷调查令牌。"

#: lib/tokens/questionnairetoken.py:122
msgid ""
"The user may only have this maximum number of active questionaire tokens "
"assigned."
msgstr "用户只能分配此最大数量的活动问卷令牌。"

#: lib/tokens/questionnairetoken.py:166
#, python-format
msgid "You need to provide at least %s answers."
msgstr "您至少需要提供 %s 答案。"

#: lib/tokens/radiustoken.py:108
msgid "RADIUS: Forward authentication request to a RADIUS server."
msgstr "RADIUS：将身份验证请求转发到RADIUS服务器。"

#: lib/tokens/radiustoken.py:117
msgid "The user may only have this maximum number of RADIUS tokens assigned."
msgstr "用户只能分配此最大数量的RADIUS令牌。"

#: lib/tokens/radiustoken.py:122
msgid ""
"The user may only have this maximum number of active RADIUS tokens assigned."
msgstr "用户只能分配此最大数量的活动RADIUS令牌。"

#: lib/tokens/registrationtoken.py:129
msgid ""
"Registration: A token that creates a registration code that can be used as a "
"second factor once."
msgstr "注册：创建注册码的令牌，该注册码可以用作第二个因素。"

#: lib/tokens/registrationtoken.py:141
msgid ""
"The user may only have this maximum number of registration tokens assigned."
msgstr "用户只能分配此最大数量的注册令牌。"

#: lib/tokens/registrationtoken.py:146
msgid ""
"The user may only have this maximum number of active registration tokens "
"assigned."
msgstr "用户只能分配此最大数量的活动注册令牌。"

#: lib/tokens/remotetoken.py:114
msgid "Remote Token: Forward authentication request to another server."
msgstr "远程令牌：将身份验证请求转发到另一台服务器。"

#: lib/tokens/remotetoken.py:123 lib/tokens/totptoken.py:166
msgid "The user may only have this maximum number of remote tokens assigned."
msgstr "用户只能分配此最大数量的远程令牌。"

#: lib/tokens/remotetoken.py:128 lib/tokens/totptoken.py:171
msgid ""
"The user may only have this maximum number of active remote tokens assigned."
msgstr "用户只能分配此最大数量的活动远程令牌。"

#: lib/tokens/smstoken.py:200
msgid "SMS Token"
msgstr "短信令牌"

#: lib/tokens/smstoken.py:202
msgid "SMS: Send a One Time Password to the users mobile phone."
msgstr "SMS：向用户手机发送一次性密码。"

#: lib/tokens/smstoken.py:211
msgid ""
"The text that will be send via SMS for an SMS token. Use tags like {otp} and "
"{serial} as parameters."
msgstr "将通过 SMS 发送的 SMS令牌文本。使用 <otp> 和 <serial> 等标签作为参数。"

#: lib/tokens/smstoken.py:216
msgid ""
"If set, a new SMS OTP will be sent after successful authentication with one "
"SMS OTP."
msgstr "如果设置，则在通过一个SMS OTP成功进行身份验证后，将发送新的SMS OTP。"

#: lib/tokens/smstoken.py:221
msgid ""
"Use an alternate challenge text for telling the user to enter the code from "
"the SMS."
msgstr "使用备用质询文本告诉用户输入SMS中的代码。"

#: lib/tokens/smstoken.py:229
msgid "Choose the gateways the administrator is allowed to set."
msgstr "选择允许管理员设置的网关。"

#: lib/tokens/smstoken.py:237
msgid "Choose the gateways the user is allowed to set."
msgstr "选择允许用户设置的网关。"

#: lib/tokens/smstoken.py:244
msgid "The user may only have this maximum number of SMS tokens assigned."
msgstr "用户只能分配此最大数量的SMS令牌。"

#: lib/tokens/smstoken.py:249
msgid ""
"The user may only have this maximum number of active SMS tokens assigned."
msgstr "用户只能分配此最大数量的活动SMS令牌。"

#: lib/tokens/smstoken.py:326
msgid "Enter the OTP from the SMS:"
msgstr "从SMS输入OTP："

#: lib/tokens/smstoken.py:357
msgid "The PIN was correct, but the SMS could not be sent!"
msgstr ""

#: lib/tokens/smstoken.py:605
msgid "Please enter your new phone number!"
msgstr "请输入你的新电话号码！"

#: lib/tokens/spasstoken.py:88
msgid "SPass: Simple Pass token. Static passwords."
msgstr "SPass：简单通行证令牌。静态密码。"

#: lib/tokens/spasstoken.py:100
msgid "The user may only have this maximum number of SPASS tokens assigned."
msgstr "用户只能分配此最大数量的SPASS令牌。"

#: lib/tokens/spasstoken.py:105
msgid ""
"The user may only have this maximum number of active SPASS tokens assigned."
msgstr "用户只能分配此最大数量的活动SPASS令牌。"

#: lib/tokens/sshkeytoken.py:84
msgid "SSH Public Key: The public SSH key."
msgstr "SSH公用密钥：公用SSH密钥。"

#: lib/tokens/sshkeytoken.py:93
msgid "The user may only have this maximum number of SSH keys assigned."
msgstr "用户只能分配此最大数量的SSH密钥。"

#: lib/tokens/sshkeytoken.py:98
msgid "The user may only have this maximum number of active SSH keys assigned."
msgstr "用户只能分配此最大数量的活动SSH密钥。"

#: lib/tokens/tantoken.py:112
msgid "The user may only have this maximum number of TAN tokens assigned."
msgstr "用户只能分配此最大数量的TAN令牌。"

#: lib/tokens/tantoken.py:117
msgid ""
"The user may only have this maximum number of active TAN tokens assigned."
msgstr "用户只能分配此最大数量的活动TAN令牌。"

#: lib/tokens/tiqrtoken.py:158
msgid "TiQR: Enroll a TiQR token."
msgstr "TiQR：注册TiQR令牌。"

#: lib/tokens/tiqrtoken.py:168
msgid "The user may only have this maximum number of TiQR tokens assigned."
msgstr "用户只能分配此最大数量的TiQR令牌。"

#: lib/tokens/tiqrtoken.py:173
msgid ""
"The user may only have this maximum number of active TiQR tokens assigned."
msgstr "用户只能分配此最大数量的活动TiQR令牌。"

#: lib/tokens/tiqrtoken.py:238
msgid "URL for TiQR enrollment"
msgstr "TiQR注册网址"

#: lib/tokens/tiqrtoken.py:395
msgid "Please scan the QR Code"
msgstr "请扫描二维码"

#: lib/tokens/totptoken.py:62
msgid "Specify the time step of the time-based OTP token."
msgstr ""

#: lib/tokens/totptoken.py:109
msgid "TOTP: Time based One Time Passwords."
msgstr "TOTP：基于时间的一次性密码。"

#: lib/tokens/u2ftoken.py:260
msgid "This is a list of FQDN hostnames trusting the registered U2F tokens."
msgstr "这是信任已注册U2F令牌的FQDN主机名的列表。"

#: lib/tokens/u2ftoken.py:264
msgid ""
"Use an alternate challenge text for telling the user to confirm with his U2F "
"device."
msgstr "使用备用质询文本告诉用户使用其U2F设备进行确认。"

#: lib/tokens/u2ftoken.py:271
msgid "Only specified U2F tokens are authorized."
msgstr "仅授权指定的U2F令牌。"

#: lib/tokens/u2ftoken.py:279
msgid "Only specified U2F tokens are allowed to be registered."
msgstr "仅允许注册指定的U2F令牌。"

#: lib/tokens/u2ftoken.py:284
msgid "Do not verify the U2F attestation certificate."
msgstr "不要验证U2F证明证书。"

#: lib/tokens/u2ftoken.py:289
msgid "The user may only have this maximum number of U2F tokens assigned."
msgstr "用户只能分配此最大数量的U2F令牌。"

#: lib/tokens/u2ftoken.py:294
msgid ""
"The user may only have this maximum number of active U2F tokens assigned."
msgstr "用户只能分配此最大数量的活动U2F令牌。"

#: lib/tokens/u2ftoken.py:379
msgid "You need to define the appId in the token config!"
msgstr "您需要在令牌配置中定义appId！"

#: lib/tokens/u2ftoken.py:444
msgid "Please confirm with your U2F token ({0!s})"
msgstr "请使用您的U2F令牌（{0！s}）进行确认"

#: lib/tokens/vascotoken.py:101
msgid "VASCO Token: Authentication using VASCO tokens"
msgstr "VASCO令牌：使用VASCO令牌进行身份验证"

#: lib/tokens/vascotoken.py:110
msgid "The user may only have this maximum number of Vasco tokens assigned."
msgstr "用户只能分配此最大数量的Vasco令牌。"

#: lib/tokens/vascotoken.py:115
msgid ""
"The user may only have this maximum number of active Vasco tokens assigned."
msgstr "用户只能分配此最大数量的活动Vasco令牌。"

#: lib/tokens/webauthntoken.py:460
msgid "Generic WebAuthn Token"
msgstr "通用WebAuthn令牌"

#: lib/tokens/webauthntoken.py:470
msgid "Please confirm with your WebAuthn token ({0!s})"
msgstr "请使用您的WebAuthn令牌（{0！s}）进行确认"

#: lib/tokens/webauthntoken.py:471
msgid "Please confirm with your WebAuthn token"
msgstr "请使用您的WebAuthn令牌进行确认"

#: lib/tokens/webauthntoken.py:608
msgid ""
"A list of transports to prefer to communicate with WebAuthn tokens. Default: "
"usb ble nfc internal (All standard transports)"
msgstr ""
"首选与WebAuthn令牌通信的传输列表。默认值：usb ble nfc internal（所有标准传"
"输）"

#: lib/tokens/webauthntoken.py:613
msgid ""
"The time in seconds the user has to confirm authorization on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"用户必须确认其WebAuthn令牌上的授权的时间（以秒为单位）。注意：您将要与此同时"
"增加ChallengeValidityTime。默认值：60"

#: lib/tokens/webauthntoken.py:619
msgid ""
"Whether the user's identity should be verified when authenticating with a "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"使用WebAuthn令牌进行身份验证时是否应该验证用户的身份。默认值：首选（如果令牌"
"支持，请验证用户）"

#: lib/tokens/webauthntoken.py:629
msgid ""
"Use an alternative challenge text for telling the user to confirm with his "
"WebAuthn token."
msgstr "使用替代质询文本告诉用户使用其WebAuthn令牌进行确认。"

#: lib/tokens/webauthntoken.py:636
msgid ""
"A list of WebAuthn authenticators acceptable for authorization, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"可以接受授权的WebAuthn认证程序列表，以空格分隔的AAGUID列表形式给出。默认情况"
"下，所有身份验证器都是可接受的。"

#: lib/tokens/webauthntoken.py:642
msgid "Only the specified WebAuthn-tokens are authorized."
msgstr "仅指定的WebAuthn令牌被授权。"

#: lib/tokens/webauthntoken.py:649
msgid "One webauthn token can not be registered to a user more than once."
msgstr ""

#: lib/tokens/webauthntoken.py:654
#, fuzzy
msgid "A human-readable name for the organization rolling out WebAuthn tokens."
msgstr "组织推出WebAuthn令牌的人易读的名称。"

#: lib/tokens/webauthntoken.py:659
msgid ""
"A domain name that is a subset of the respective FQDNs for all the "
"webservices the users should be able to sign in to using WebAuthn tokens."
msgstr "域名是用户应能够使用WebAuthn令牌登录的所有Web服务的相应FQDN的子集。"

#: lib/tokens/webauthntoken.py:665
msgid ""
"The time in seconds the user has to confirm enrollment on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"用户必须确认其WebAuthn令牌上的注册时间（以秒为单位）。注意：您将要与此同时增"
"加ChallengeValidityTime。默认值：60"

#: lib/tokens/webauthntoken.py:672
msgid ""
"Whether to limit roll out of WebAuthn tokens to either only platform "
"authenticators, or only cross-platform authenticators. Default: either"
msgstr ""
"是否将仅将WebAuthn令牌的推出限制为仅平台身份验证器或仅跨平台身份验证器。默认"
"值：任一"

#: lib/tokens/webauthntoken.py:683
msgid ""
"A list of WebAuthn authenticators acceptable for enrollment, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"可以接受的WebAuthn身份验证器列表，以空格分隔的AAGUID列表形式给出。默认情况"
"下，所有身份验证器都是可接受的。"

#: lib/tokens/webauthntoken.py:689
msgid ""
"Whether the user's identity should be verified when rolling out a new "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"推出新的WebAuthn令牌时是否应验证用户的身份。默认值：首选（如果令牌支持，请验"
"证用户）"

#: lib/tokens/webauthntoken.py:703
#, fuzzy
msgid ""
"Which algorithm are available to use for creating public key credentials for "
"WebAuthn tokens. (Default: [{0!s}], Order: [{1!s}])"
msgstr ""
"可用于为 WebAuthn 令牌创建公钥凭据的算法。 (默认: [{0!s}], 顺序: [{1!s}]"

#: lib/tokens/webauthntoken.py:710
msgid ""
"Whether to request attestation data when enrolling a new WebAuthn token. "
"Note: for u2f_req to work with WebAuthn, this cannot be set to none. "
"Default: direct (ask for non-anonymized attestation data)"
msgstr ""
"注册新的WebAuthn令牌时是否请求证明数据。注意：为了使u2f_req与WebAuthn一起使"
"用，不能将其设置为none。默认值：直接（询问非匿名证明数据）"

#: lib/tokens/webauthntoken.py:722
msgid ""
"Whether and how strictly to check authenticator attestation data. Note: If "
"the attestation form is none, the attestation level needs to also be none. "
"Default: untrusted (attestation is required, but can be unknown or self-"
"signed)"
msgstr ""
"是否以及如何严格检查身份验证者证明数据。注意：如果证明形式为“无”，则证明级别"
"也必须为“无”。默认值：不受信任（要求提供证明，但可以是未知的或自签名的）"

#: lib/tokens/webauthntoken.py:734
msgid "Only the specified WebAuthn-tokens are allowed to be registered."
msgstr "仅允许注册指定的WebAuthn令牌。"

#: lib/tokens/webauthntoken.py:739
msgid "The user may only have this number of WebAuthn tokens assigned."
msgstr "用户只能分配此数量的WebAuthn令牌。"

#: lib/tokens/webauthntoken.py:744
msgid "The user may only have this number of active WebAuthn tokens assigned."
msgstr "用户只能分配此数量的活动WebAuthn令牌。"

#: lib/tokens/webauthntoken.py:749
msgid ""
"Use an alternate challenge text for telling the user to confirm with his "
"WebAuthn device."
msgstr "使用替代质询文本告诉用户使用其WebAuthn设备进行确认。"

#: lib/tokens/yubicotoken.py:103
msgid "Yubikey Cloud mode: Forward authentication request to YubiCloud."
msgstr "Yubikey Cloud模式：将身份验证请求转发到YubiCloud。"

#: lib/tokens/yubicotoken.py:112
msgid "The user may only have this maximum number of Yubico tokens assigned."
msgstr "用户只能分配此最大数量的Yubico令牌。"

#: lib/tokens/yubicotoken.py:117
msgid ""
"The user may only have this maximum number of active Yubico tokens assigned."
msgstr "用户只能分配此最大数量的活动Yubico令牌。"

#: lib/tokens/yubikeytoken.py:161
msgid "Yubikey AES mode: One Time Passwords with Yubikey."
msgstr "Yubikey AES模式：使用Yubikey一次性密码。"

#: lib/tokens/yubikeytoken.py:170
msgid "The user may only have this maximum number of Yubikey tokens assigned."
msgstr "用户只能分配此最大数量的Yubikey令牌。"

#: lib/tokens/yubikeytoken.py:175
msgid ""
"The user may only have this maximum number of active Yubikey tokens assigned."
msgstr "用户只能分配此最大数量的活动Yubikey令牌。"

#: lib/tokens/yubikeytoken.py:181
msgid ""
"The Yubikey access code can be read by an enrollment client to initialize "
"Yubikeys."
msgstr "注册客户端可以读取 Yubikey 访问代码来初始化 Yubikey。"

#: lib/utils/compare.py:191
msgid "true if the value of the left attribute contains the right value"
msgstr "如果left属性的值包含正确的值，则为true"

#: lib/utils/compare.py:192
msgid "false if the value of the left attribute contains the right value"
msgstr "如果left属性的值包含正确的值，则返回false"

#: lib/utils/compare.py:194
msgid "true if the value of the left attribute equals the right value"
msgstr "如果left属性的值等于right值，则为true"

#: lib/utils/compare.py:195
msgid "false if the value of the left attribute equals the right value"
msgstr "如果left属性的值等于right值，则返回false"

#: lib/utils/compare.py:197
msgid ""
"true if the value of the left attribute completely matches the given regular "
"expression pattern on the right"
msgstr "如果left属性的值与右边的给定正则表达式模式完全匹配，则为true"

#: lib/utils/compare.py:198
msgid ""
"false if the value of the left attribute completely matches the given "
"regular expression pattern on the right"
msgstr "如果left属性的值与右边的给定正则表达式模式完全匹配，则返回false"

#: lib/utils/compare.py:200
msgid ""
"true if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr "如果left属性的值包含在右边的逗号分隔值中，则为true"

#: lib/utils/compare.py:201
msgid ""
"false if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr "如果left属性的值包含在右边的逗号分隔值中，则返回false"

#: lib/utils/compare.py:203
msgid ""
"true if the integer value of the left attribute is smaller than the right "
"integer value"
msgstr ""

#: lib/utils/compare.py:204
msgid ""
"true if the integer value of the left attribute is bigger than the right "
"integer value"
msgstr ""

#~ msgid ""
#~ "Set label for a new enrolled Google Authenticator. Possible tags are &lt;"
#~ "u&gt; (user), &lt;r&gt; (realm), &lt;s&gt; (serial)."
#~ msgstr ""
#~ "为新注册的Google身份验证器设置标签。可能的标签是&lt;u&gt;（用户）、&lt;"
#~ "u&gt;（领域）、&lt;u&gt;（序列）。"

#~ msgid "This is the issuer label for new enrolled Google Authenticators."
#~ msgstr "这是新注册的Google身份验证器的发行者标签。"

#~ msgid "This is the URL to the token image for smartphone apps like FreeOTP."
#~ msgstr "这是智能手机应用程序（如FreeOTP）的令牌图像的URL。"

#~ msgid ""
#~ "The project ID, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "客户端应使用的项目ID。从Firebase控制台获取它。"

#~ msgid ""
#~ "The project number, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "客户应使用的项目号。从Firebase控制台获取它。"

#~ msgid ""
#~ "The App ID, that the Android client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "Android客户端应使用的应用ID。从Firebase控制台获取它。"

#~ msgid ""
#~ "The API Key, that the Android client should use. Get it from your "
#~ "Firebase console."
#~ msgstr "Android客户端应使用的API密钥。从Firebase控制台获取它。"

#~ msgid ""
#~ "The App ID, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "iOS客户端应使用的应用程序ID。从Firebase控制台获取它。"

#~ msgid ""
#~ "The API Key, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "iOS客户端应使用的API密钥。从Firebase控制台获取它。"
