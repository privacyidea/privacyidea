# Chinese (Traditional) translations for PROJECT.
# Copyright (C) 2021 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# hugoalh <hugoalh@users.noreply.hosted.weblate.org>, 2025.
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2025-04-04 01:39+0200\n"
"PO-Revision-Date: 2025-03-28 09:26+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Chinese (Traditional Han script) <https://hosted.weblate.org/"
"projects/privacyidea/branch-3-11/zh_Hant/>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.11-dev\n"
"Generated-By: Babel 2.12.1\n"

#: api/auth.py:231
msgid "Authentication with passkey disabled."
msgstr ""

#: api/auth.py:236
#, fuzzy
#| msgid "Authentication failure. Missing Username"
msgid "Authentication failure. The passkey is not registered."
msgstr "身份驗證失敗。缺少使用者名"

#: api/auth.py:239
#, fuzzy
#| msgid "Authentication failure. Your token has expired: {0!s}"
msgid "Authentication failure. Token has no user."
msgstr "身份驗證失敗。您的令牌已過期: {0!s}"

#: api/auth.py:250
#, fuzzy
#| msgid "Authentication failure. Missing Username"
msgid "Authentication failure using passkey."
msgstr "身份驗證失敗。缺少使用者名"

#: api/auth.py:255
#, fuzzy
#| msgid "Authentication failure. Unknown realm: {0!s}."
msgid "Authentication failure. Unknown realm:"
msgstr "身份驗證失敗。未知領域: {0!s}。"

#: api/auth.py:259
msgid "Authentication failure. Missing Username"
msgstr "身份驗證失敗。缺少使用者名"

#: api/auth.py:378
msgid "Authentication failure. Wrong credentials"
msgstr "身份驗證失敗。憑據錯誤"

#: api/realm.py:528
msgid "The given node does not exist!"
msgstr ""

#: api/realm.py:534 api/realm.py:544
msgid "Could not verify data in request!"
msgstr ""

#: api/validate.py:466 lib/token.py:2608
msgid "Found matching challenge"
msgstr ""

#: api/lib/postpolicy.py:88
#, python-brace-format
msgid ""
"\n"
"<--- Please describe your Problem in detail --->\n"
"\n"
"<--- Please provide as many additional information as possible --->\n"
"\n"
"privacyIDEA Version: {version}\n"
"Subscriber: {subscriber_name}\n"
"Subscriptions: {subscriptions}\n"
msgstr ""

#: api/lib/prepolicy.py:2476
#, fuzzy, python-brace-format
msgid "Missing description for {} token."
msgstr "令牌的新說明。"

#: api/lib/prepolicy.py:2477
#, fuzzy, python-brace-format
msgid "Description required for {} token."
msgstr "令牌的新說明。"

#: api/lib/utils.py:400
msgid "Authentication failure. Missing Authorization header."
msgstr "身份驗證失敗。缺少授權標頭。"

#: api/lib/utils.py:405 api/lib/utils.py:436
#, fuzzy
#| msgid "Authentication failure. Error during decoding your token: {0!s}"
msgid "Authentication failure. Error decoding the Authorization token:"
msgstr "身份驗證失敗。解碼令牌時出錯: {0!s}"

#: api/lib/utils.py:429 api/lib/utils.py:439
#, fuzzy
#| msgid "Authentication failure. Your token has expired: {0!s}"
msgid "Authentication failure. Your token has expired:"
msgstr "身份驗證失敗。您的令牌已過期: {0!s}"

#: api/lib/utils.py:442
#, fuzzy, python-brace-format
#| msgid ""
#| "Authentication failure. The username {0!s} is not allowed to impersonate "
#| "via JWT."
msgid ""
"Authentication failure. The username {wrong_username} is not allowed to "
"impersonate via JWT."
msgstr "驗證失敗。用戶名 {0!s}不允許通過 JWT 冒充。"

#: api/lib/utils.py:447
#, fuzzy, python-brace-format
#| msgid ""
#| "Authentication failure. You do not have the necessary role ({0!s}) to "
#| "access this resource!"
msgid ""
"Authentication failure. You do not have the necessary role ({required_role}) "
"to access this resource!"
msgstr "驗證失敗。您沒有訪問此資源所需的角色 ({0!s})！"

#: api/lib/utils.py:464
#, fuzzy
#| msgid "'{0!s}' is an invalid policy name."
msgid "Invalid policy name:"
msgstr "“{0!s}”是無效的策略名稱。"

#: api/lib/utils.py:467
msgid "The name of the policy may only contain the characters a-zA-Z0-9_. -"
msgstr "策略的名稱只能包含字元 a-zA-Z0-9_。-"

#: lib/challengeresponsedecorators.py:149
msgid "Please enter the new PIN again"
msgstr "請再次輸入新的 PIN 碼"

#: lib/challengeresponsedecorators.py:163
msgid "Please enter a new PIN"
msgstr "請輸入新的 PIN 碼"

#: lib/challengeresponsedecorators.py:201
msgid "To resync your token, please enter the next OTP value"
msgstr ""

#: lib/containerclass.py:802
msgid ""
"General purpose container that can hold any type and any number of token."
msgstr ""

#: lib/decorators.py:43 lib/token.py:2468
msgid "This action is not possible, since the token is locked"
msgstr "此操作是不可能的，因為令牌已鎖定"

#: lib/decorators.py:87
msgid "You either need to provide user or serial"
msgstr "您需要提供使用者或序列號"

#: lib/decorators.py:114
#, fuzzy
#| msgid "You need to specify a serial or a user."
msgid "You need to specify a serial, user or credential_id."
msgstr "您需要指定序列號或使用者。"

#: lib/decorators.py:116
msgid "Invalid serial number."
msgstr "序列號無效。"

#: lib/decorators.py:118
msgid "Invalid user."
msgstr "無效使用者。"

#: lib/policy.py:205
msgid ""
"Note: If you use a comma in the message, you need to escape it with a "
"backslash."
msgstr ""

#: lib/policy.py:1455
msgid "Invalid client definition!"
msgstr ""

#: lib/policy.py:1650
msgid "Define in which resolver the user should be registered."
msgstr "定義使用者應該在哪個解析器中註冊。"

#: lib/policy.py:1654
msgid "Define in which realm the user should be registered."
msgstr "定義使用者應該在哪個領域註冊。"

#: lib/policy.py:1658
msgid ""
"The SMTP server configuration, that should be used to send the registration "
"email."
msgstr "SMTP 伺服器配置，應用於發送註冊電子郵件。"

#: lib/policy.py:1662
msgid ""
"Only users with this email address are allowed to register. This is a "
"regular expression."
msgstr "只有擁有此電子郵件地址的用戶才允許註冊。這是一個正則表達式。"

#: lib/policy.py:1667
#, python-brace-format
msgid ""
"The body of the registration email. Use '{regkey}' as tag for the "
"registration key."
msgstr "註冊電子郵件的正文。使用“{regkey}”作為註冊碼的標籤。"

#: lib/policy.py:1673
msgid "Admin is allowed to enable tokens."
msgstr "允許管理員啟用令牌。"

#: lib/policy.py:1677
msgid "Admin is allowed to disable tokens."
msgstr "允許管理員禁用令牌。"

#: lib/policy.py:1682
msgid "Admin is allowed to set token properties."
msgstr "允許管理員設置令牌屬性。"

#: lib/policy.py:1686
#, fuzzy
msgid "The admin is allowed to set the token description."
msgstr "允許用戶設置令牌描述。"

#: lib/policy.py:1691
msgid "Admin is allowed to set the OTP PIN of tokens."
msgstr "允許管理員設置令牌的OTP PIN。"

#: lib/policy.py:1696
msgid "Admin is allowed to set a random OTP PIN of tokens."
msgstr "允許管理員設置令牌的隨機OTP PIN。"

#: lib/policy.py:1700
msgid "Admin is allowed to manually set and delete token info."
msgstr "允許管理員手動設置和刪除令牌資訊。"

#: lib/policy.py:1704
msgid "Admin is allowed to set the OTP PIN during enrollment."
msgstr "允許管理員在註冊期間設置 OTP PIN。"

#: lib/policy.py:1709
msgid "Admin is allowed to resync tokens."
msgstr "允許管理員重新同步令牌。"

#: lib/policy.py:1714
msgid "Admin is allowed to reset the Failcounter of a token."
msgstr "允許管理員重置令牌的失敗計數器。"

#: lib/policy.py:1719
msgid "Admin is allowed to revoke a token"
msgstr "允許管理員撤銷令牌"

#: lib/policy.py:1724
msgid "Admin is allowed to assign a token to a user."
msgstr "允許管理員將令牌分配給使用者。"

#: lib/policy.py:1730
msgid ""
"Admin is allowed to remove the token from a user, i.e. unassign a token."
msgstr "允許管理員從用戶中刪除令牌，即取消分配令牌。"

#: lib/policy.py:1736
msgid "Admin is allowed to import token files."
msgstr "允許管理員導入令牌檔。"

#: lib/policy.py:1741
msgid "Admin is allowed to remove tokens from the database."
msgstr "允許管理員從資料庫中刪除令牌。"

#: lib/policy.py:1747
msgid "Admin is allowed to view the list of the users."
msgstr "允許管理員查看用戶清單。"

#: lib/policy.py:1752
msgid "The Admin is allowed to list the machines."
msgstr "允許管理員列出機器。"

#: lib/policy.py:1757
msgid "The Admin is allowed to attach and detach tokens to machines."
msgstr "允許管理員將令牌附加和分離到機器上。"

#: lib/policy.py:1764
msgid ""
"The Admin is allowed to fetch authentication items of tokens assigned to "
"machines."
msgstr "允許管理員獲取分配給機器的令牌的身份驗證項目。"

#: lib/policy.py:1769
msgid "Admin is allowed to manage the realms of a token."
msgstr "允許管理員管理令牌的領域。"

#: lib/policy.py:1774
msgid "Admin is allowed to list tokens."
msgstr "允許管理員列出令牌。"

#: lib/policy.py:1778
msgid "Admin is allowed to retrieve a serial for a given OTP value."
msgstr "允許管理員檢索給定 OTP 值的序列號。"

#: lib/policy.py:1783
msgid "Admin is allowed to retrieve random keys from privacyIDEA."
msgstr "允許管理員從privacyIDEA中檢索隨機密鑰。"

#: lib/policy.py:1788
msgid "Admin is allowed to copy the PIN of one token to another token."
msgstr "允許管理員將一個令牌的 PIN 複製到另一個令牌。"

#: lib/policy.py:1793
msgid ""
"Admin is allowed to copy the assigned user to another token, i.e. assign a "
"user to another token."
msgstr "允許管理員將分配的用戶複製到另一個令牌，即分配一個使用者到另一個令牌。"

#: lib/policy.py:1798
msgid "Admin is allowed to trigger the lost token workflow."
msgstr "允許管理員觸發丟失的令牌工作流程。"

#: lib/policy.py:1804
msgid "Admin is allowed to write and modify the system configuration."
msgstr "允許管理員編寫和修改系統配置。"

#: lib/policy.py:1809
msgid "Admin is allowed to delete keys in the system configuration."
msgstr "允許管理員刪除系統配置中的金鑰。"

#: lib/policy.py:1815
msgid "Admin is allowed to read basic system configuration."
msgstr "允許管理員讀取基本系統配置。"

#: lib/policy.py:1820
msgid ""
"Admin is allowed to export a documentation of the complete configuration "
"including resolvers and realm."
msgstr "允許管理員匯出完整配置的文件，包括解析程式和領域。"

#: lib/policy.py:1828
msgid "Admin is allowed to write and modify the policies."
msgstr "允許管理員編寫和修改策略。"

#: lib/policy.py:1833
msgid "Admin is allowed to delete policies."
msgstr "允許管理員刪除策略。"

#: lib/policy.py:1838
msgid "Admin is allowed to read policies."
msgstr "允許管理員讀取策略。"

#: lib/policy.py:1842
msgid ""
"Admin is allowed to write and modify the resolver and realm configuration."
msgstr "允許管理員編寫和修改解析程式和領域配置。"

#: lib/policy.py:1849
msgid "Admin is allowed to delete resolvers and realms."
msgstr "允許管理員刪除解析程式和領域。"

#: lib/policy.py:1854
msgid "Admin is allowed to read resolvers."
msgstr "允許管理員讀取解析程式。"

#: lib/policy.py:1858
msgid ""
"Admin is allowed to create new CA Connector definitions and modify existing "
"ones."
msgstr "允許管理員創建新的 CA 連接器定義並修改現有定義。"

#: lib/policy.py:1864
msgid "Admin is allowed to delete CA Connector definitions."
msgstr "允許管理員刪除 CA 連接器定義。"

#: lib/policy.py:1869
msgid "Admin is allowed to read CA Connector definitions."
msgstr "允許管理員讀取 CA 連接器定義。"

#: lib/policy.py:1874
msgid "Admin is allowed to write and modify the machine resolvers."
msgstr "允許管理員編寫和修改機器解析程式。"

#: lib/policy.py:1880
msgid "Admin is allowed to delete machine resolvers."
msgstr "允許管理員刪除機器解析程式。"

#: lib/policy.py:1886
msgid "Admin is allowed to read machine resolvers."
msgstr "允許管理員讀取機器解析程式。"

#: lib/policy.py:1893 lib/policy.py:2231
msgid "Set the maximum allowed length of the OTP PIN."
msgstr "設置 OTP PIN 的最大允許長度。"

#: lib/policy.py:1898 lib/policy.py:2235
msgid "Set the minimum required length of the OTP PIN."
msgstr "設置 OTP PIN 所需的最小長度。"

#: lib/policy.py:1902
msgid ""
"Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
"(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgstr ""
"指定 OTP PIN 所需的內容。 (c) 字符，(n) 數字，(s) 特殊。使用修飾符 +/- 或允許"
"的字符列表 [1234567890]"

#: lib/policy.py:1911
msgid "The length of a random PIN set by the administrator."
msgstr "管理員設置的隨機 PIN 的長度。"

#: lib/policy.py:1914
msgid "Admin is allowed to view the Audit log."
msgstr "允許管理員查看審核日誌。"

#: lib/policy.py:1918
msgid "The admin will only see audit entries of the last 10d, 3m or 2y."
msgstr "管理員只能看到最近 10 天、3 個月或 2 年的審核條目。"

#: lib/policy.py:1923
msgid "The admin will not see the specified columns in the audit."
msgstr "管理員不會在審核中看到指定的列。"

#: lib/policy.py:1928
msgid "The admin is allowed to download the complete auditlog."
msgstr "允許管理員下載完整的審核日誌。"

#: lib/policy.py:1933
msgid "Admin is allowed to add users in a userstore/UserIdResolver."
msgstr "允許管理員在 userstore/UserIdResolver 中添加使用者。"

#: lib/policy.py:1938
msgid "Admin is allowed to update the users data in a userstore."
msgstr "允許管理員更新使用者存儲中的用戶數據。"

#: lib/policy.py:1943
msgid "Admin is allowed to delete a user object in a userstore."
msgstr "允許管理員刪除使用者存儲中的用戶物件。"

#: lib/policy.py:1948
msgid "Admin is allowed to set the password of the HSM/Security Module."
msgstr "允許管理員設置 HSM/安全模組的密碼。"

#: lib/policy.py:1952
msgid "Admin is allowed to retrieve the list of active challenges."
msgstr "允許管理員檢索活動質詢的清單。"

#: lib/policy.py:1958
msgid "Admin is allowed to write new SMTP server definitions."
msgstr "允許管理員編寫新的 SMTP 伺服器定義。"

#: lib/policy.py:1963
msgid "Admin is allowed to read SMTP server definitions."
msgstr "允許管理員讀取 SMTP 伺服器定義。"

#: lib/policy.py:1968
msgid "Admin is allowed to write new RADIUS server definitions."
msgstr "允許管理員編寫新的RADIUS伺服器定義。"

#: lib/policy.py:1974
msgid "Admin is allowed to read RADIUS server definitions."
msgstr "允許管理員讀取RADIUS伺服器定義。"

#: lib/policy.py:1979
msgid "Admin is allowed to write remote privacyIDEA server definitions."
msgstr "允許管理員編寫遠端privacyIDEA伺服器定義。"

#: lib/policy.py:1986
msgid "Admin is allowed to read remote privacyIDEA server definitions."
msgstr "允許管理員讀取遠端privacyIDEA伺服器定義。"

#: lib/policy.py:1993
msgid "Admin is allowed to write periodic task definitions."
msgstr "允許管理員編寫定期任務定義。"

#: lib/policy.py:1998
msgid "Admin is allowed to read periodic task definitions."
msgstr "允許管理員定期讀取任務定義。"

#: lib/policy.py:2003
msgid "Admin is allowed to read statistics data."
msgstr "允許管理員讀取統計數據。"

#: lib/policy.py:2006
msgid "Admin is allowed to delete statistics data."
msgstr "允許管理員刪除統計數據。"

#: lib/policy.py:2009
msgid "Admin is allowed to write and modify the event handling configuration."
msgstr "允許管理員編寫和修改事件處理配置。"

#: lib/policy.py:2015
msgid "Admin is allowed to read event handling configuration."
msgstr "允許管理員讀取事件處理配置。"

#: lib/policy.py:2020
msgid "Admin is allowed to write and modify SMS gateway definitions."
msgstr "允許管理員編寫和修改 SMS gateway 定義。"

#: lib/policy.py:2026
msgid "Admin is allowed to read SMS gateway definitions."
msgstr "允許管理員讀取 SMS gateway 定義。"

#: lib/policy.py:2031
msgid ""
"Admin is allowed to get the list of authenticated clients and their types."
msgstr "允許管理員獲取經過身份驗證的用戶端及其類型的清單。"

#: lib/policy.py:2038
msgid "Admin is allowed to add and delete component subscriptions."
msgstr "允許管理員添加和刪除元件訂閱。"

#: lib/policy.py:2044
msgid "The Admin is allowed to trigger a challenge for e.g. SMS OTP token."
msgstr "管理員可以觸發詢問，例如簡訊OTP令牌。"

#: lib/policy.py:2050
msgid ""
"The Admin is allowed to set certain custom user attributes. If the Admin "
"should be allowed to set any attribute, set this to '*:*'. For more details, "
"check the documentation."
msgstr ""
"允許管理員設置某些自定義用戶屬性。如果允許管理員設置任何屬性，請將其設置為"
"\"*:*\"。有關更多詳細資訊，請查看文件。"

#: lib/policy.py:2058
msgid ""
"The Admin is allowed to delete certain custom user attributes. If the Admin "
"should be allowed to delete any attribute, set this to '*'. For more "
"details, check the documentation."
msgstr ""
"允許管理員刪除某些自定義用戶屬性。如果允許管理員刪除任何屬性，請將其設置為"
"\"*\"。有關更多詳細資訊，請查看文件。"

#: lib/policy.py:2066
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the admin."
msgstr ""

#: lib/policy.py:2071
msgid "The Admin is allowed list the available tokengroups."
msgstr ""

#: lib/policy.py:2076
msgid "The Admin is allowed to add a new tokengroup."
msgstr ""

#: lib/policy.py:2081
msgid "The Admin is allowed delete a tokengroup."
msgstr ""

#: lib/policy.py:2086
#, fuzzy
msgid "The Admin is allowed list the available service ID definitions."
msgstr "允許管理員讀取RADIUS伺服器定義。"

#: lib/policy.py:2091
#, fuzzy
msgid "The Admin is allowed to add a new service ID definition."
msgstr "允許管理員讀取RADIUS伺服器定義。"

#: lib/policy.py:2096
#, fuzzy
msgid "The Admin is allowed delete a service ID definition."
msgstr "允許管理員刪除 CA 連接器定義。"

#: lib/policy.py:2101
msgid "The Admin is allowed to manage the tokengroups of a token."
msgstr ""

#: lib/policy.py:2105
#, fuzzy
#| msgid "Admin is allowed to reset the Failcounter of a token."
msgid "Admin is allowed to edit the container info."
msgstr "允許管理員重置令牌的失敗計數器。"

#: lib/policy.py:2109
#, fuzzy
#| msgid "Admin is allowed to reset the Failcounter of a token."
msgid "Admin is allowed to edit the container state."
msgstr "允許管理員重置令牌的失敗計數器。"

#: lib/policy.py:2113
#, fuzzy
msgid "Admin is allowed to edit the container description."
msgstr "允許用戶設置令牌描述。"

#: lib/policy.py:2117
#, fuzzy
#| msgid "Admin is allowed to read policies."
msgid "Admin is allowed to create containers."
msgstr "允許管理員讀取策略。"

#: lib/policy.py:2121
#, fuzzy
#| msgid "Admin is allowed to delete policies."
msgid "Admin is allowed to delete containers."
msgstr "允許管理員刪除策略。"

#: lib/policy.py:2125
#, fuzzy
#| msgid "Admin is allowed to assign a token to a user."
msgid "Admin is allowed to add tokens to containers."
msgstr "允許管理員將令牌分配給使用者。"

#: lib/policy.py:2129
#, fuzzy
#| msgid "Admin is allowed to remove tokens from the database."
msgid "Admin is allowed to remove tokens from containers."
msgstr "允許管理員從資料庫中刪除令牌。"

#: lib/policy.py:2133
#, fuzzy
#| msgid "Admin is allowed to assign a token to a user."
msgid "Admin is allowed to assign users to containers."
msgstr "允許管理員將令牌分配給使用者。"

#: lib/policy.py:2137
#, fuzzy
#| msgid "Admin is allowed to assign a token to a user."
msgid "Admin is allowed to unassign users from containers."
msgstr "允許管理員將令牌分配給使用者。"

#: lib/policy.py:2141
#, fuzzy
#| msgid "Admin is allowed to manage the realms of a token."
msgid "Admin is allowed to set the realm of containers."
msgstr "允許管理員管理令牌的領域。"

#: lib/policy.py:2145
#, fuzzy
#| msgid "Admin is allowed to list tokens."
msgid "Admin is allowed to list containers."
msgstr "允許管理員列出令牌。"

#: lib/policy.py:2149
#, fuzzy
#| msgid "Admin is allowed to read policies."
msgid "Admin is allowed to register containers."
msgstr "允許管理員讀取策略。"

#: lib/policy.py:2153
#, fuzzy
#| msgid "Admin is allowed to read policies."
msgid "Admin is allowed to unregister containers."
msgstr "允許管理員讀取策略。"

#: lib/policy.py:2157
#, fuzzy
#| msgid ""
#| "Admin is allowed to export a documentation of the complete configuration "
#| "including resolvers and realm."
msgid ""
"Admin is allowed to perform a container rollover including a rollover of all "
"contained tokens."
msgstr "允許管理員匯出完整配置的文件，包括解析程式和領域。"

#: lib/policy.py:2162
#, fuzzy
#| msgid "Admin is allowed to read policies."
msgid "Admin is allowed to create and edit container templates."
msgstr "允許管理員讀取策略。"

#: lib/policy.py:2166
#, fuzzy
#| msgid "Admin is allowed to delete policies."
msgid "Admin is allowed to delete templates."
msgstr "允許管理員刪除策略。"

#: lib/policy.py:2170
#, fuzzy
#| msgid "Admin is allowed to delete resolvers and realms."
msgid "Admin is allowed to list templates and view their details."
msgstr "允許管理員刪除解析程式和領域。"

#: lib/policy.py:2177
msgid ""
"The user is allowed to assign an existing token that is not yet assigned "
"using the token serial number."
msgstr "允許使用者分配尚未使用令牌序列號分配的現有令牌。"

#: lib/policy.py:2183
msgid "The user is allowed to disable his own tokens."
msgstr "允許使用者禁用自己的令牌。"

#: lib/policy.py:2187
msgid "The user is allowed to enable his own tokens."
msgstr "允許用戶啟用自己的令牌。"

#: lib/policy.py:2191
msgid "The user is allowed to delete his own tokens."
msgstr "允許用戶刪除自己的令牌。"

#: lib/policy.py:2195
msgid "The user is allowed to unassign his own tokens."
msgstr "允許使用者取消分配自己的令牌。"

#: lib/policy.py:2199
#, fuzzy
#| msgid "The user is allowed to resyncronize his tokens."
msgid "The user is allowed to resynchronize his tokens."
msgstr "允許使用者重新同步自己的令牌。"

#: lib/policy.py:2203
msgid "The user is allowed to revoke a token"
msgstr "允許使用者撤銷令牌"

#: lib/policy.py:2207
msgid "The user is allowed to reset the failcounter of his tokens."
msgstr "允許使用者重置自己令牌的失敗計數器。"

#: lib/policy.py:2211
msgid "The user is allowed to set the OTP PIN of his tokens."
msgstr "允許用戶設置自己令牌的 OTP PIN。"

#: lib/policy.py:2215
msgid "The user is allowed to set a random OTP PIN of his tokens."
msgstr "允許用戶設置自己令牌的隨機OTP PIN。"

#: lib/policy.py:2220
msgid "The length of a random PIN set by the user."
msgstr "用戶設置的隨機 PIN 的長度。"

#: lib/policy.py:2223
msgid "The user is allowed to set the token description."
msgstr "允許用戶設置令牌描述。"

#: lib/policy.py:2227
msgid "The user is allowed to set the OTP PIN during enrollment."
msgstr "允許用戶在註冊期間設置OTP PIN。"

#: lib/policy.py:2238
#, fuzzy
#| msgid ""
#| "Specifiy the required contents of the OTP PIN. (c)haracters, (n)umeric, "
#| "(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgid ""
"Specify the required contents of the OTP PIN. (c)haracters, (n)umeric, "
"(s)pecial. Use modifiers +/- or a list of allowed characters [1234567890]"
msgstr ""
"指定 OTP PIN 所需的內容。 (c) 字符，(n) 數字，(s) 特殊。使用修飾符 +/- 或允許"
"的字符列表 [1234567890]"

#: lib/policy.py:2244
msgid "Allow the user to view his own token history."
msgstr "允許使用者查看自己的令牌歷史記錄。"

#: lib/policy.py:2247
msgid "The user will only see audit entries of the last 10d, 3m or 2y."
msgstr "使用者只能看到最近 10 天、3 個月或 2 年的審核條目。"

#: lib/policy.py:2250
msgid "The user will not see the specified columns in the audit."
msgstr "使用者將不會在審核中看到指定的列。"

#: lib/policy.py:2254
msgid "The user is allowed to view his own user information."
msgstr "允許使用者查看自己的用戶資訊。"

#: lib/policy.py:2257
msgid ""
"The user is allowed to update his own user information, like changing his "
"password."
msgstr "允許使用者更新自己的使用者資訊，例如更改其密碼。"

#: lib/policy.py:2262
msgid ""
"The user is allowed to do a password reset in an editable UserIdResolver."
msgstr "允許使用者在可編輯的使用者 IdResolver 中執行密碼重置。"

#: lib/policy.py:2267
msgid ""
"The user is allowed to set certain custom user attributes. If the user "
"should be allowed to set any attribute, set this to '*:*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"允許使用者設置某些自定義用戶屬性。如果允許使用者設置任何屬性，請將其設置為"
"\"*:*\"。請謹慎使用\"*\"！有關更多詳細資訊，請查看文件。"

#: lib/policy.py:2274
msgid ""
"The user is allowed to delete certain custom user attributes. If the user "
"should be allowed to delete any attribute, set this to '*'. Use '*' with "
"CAUTION! For more details, check the documentation."
msgstr ""
"允許使用者刪除某些自定義用戶屬性。如果應允許使用者刪除任何屬性，請將其設置為"
"\"*\"。請謹慎使用\"*\"！有關更多詳細資訊，請查看文件。"

#: lib/policy.py:2282
msgid ""
"A whitespace-separated list of tokeninfo fields which are not displayed to "
"the user."
msgstr ""

#: lib/policy.py:2288
#, fuzzy
#| msgid "The user is allowed to disable his own tokens."
msgid "Users are allowed to edit the state of their own containers."
msgstr "允許使用者禁用自己的令牌。"

#: lib/policy.py:2293
#, fuzzy
#| msgid "The user is allowed to set the token description."
msgid "Users are allowed to edit the description of their own containers."
msgstr "允許用戶設置令牌描述。"

#: lib/policy.py:2297
#, fuzzy
#| msgid "The user is allowed to enable his own tokens."
msgid "Users are allowed to create containers."
msgstr "允許用戶啟用自己的令牌。"

#: lib/policy.py:2301
#, fuzzy
#| msgid "The user is allowed to delete his own tokens."
msgid "Users are allowed to delete their own containers."
msgstr "允許用戶刪除自己的令牌。"

#: lib/policy.py:2306
msgid "Users are allowed to add their own tokens to their own containers."
msgstr ""

#: lib/policy.py:2310
#, fuzzy
#| msgid "Admin is allowed to remove tokens from the database."
msgid "Users are allowed to remove their own tokens from their own containers."
msgstr "允許管理員從資料庫中刪除令牌。"

#: lib/policy.py:2315
msgid "Users are allowed to assign themselves to containers without an owner."
msgstr ""

#: lib/policy.py:2320
#, fuzzy
#| msgid "The user is allowed to unassign his own tokens."
msgid "Users are allowed to unassign themselves from containers."
msgstr "允許使用者取消分配自己的令牌。"

#: lib/policy.py:2324
#, fuzzy
#| msgid "The user is allowed to delete his own tokens."
msgid "Users are allowed to list their own containers."
msgstr "允許用戶刪除自己的令牌。"

#: lib/policy.py:2329
#, fuzzy
#| msgid "The user is allowed to delete his own tokens."
msgid "Users are allowed to register their own containers."
msgstr "允許用戶刪除自己的令牌。"

#: lib/policy.py:2333
#, fuzzy
#| msgid "The user is allowed to enable his own tokens."
msgid "Users are allowed to unregister containers."
msgstr "允許用戶啟用自己的令牌。"

#: lib/policy.py:2337
msgid ""
"Users are allowed to perform a container rollover of their own containers. "
"This includes a rollover of all contained tokens even if the user is not the "
"owner of a contained token."
msgstr ""

#: lib/policy.py:2343
#, fuzzy
#| msgid "The user is allowed to enable his own tokens."
msgid "Users are allowed to create and edit container templates."
msgstr "允許用戶啟用自己的令牌。"

#: lib/policy.py:2347
#, fuzzy
#| msgid "The user is allowed to delete his own tokens."
msgid "Users are allowed to delete templates."
msgstr "允許用戶刪除自己的令牌。"

#: lib/policy.py:2351
#, fuzzy
#| msgid "The user is allowed to disable his own tokens."
msgid "Users are allowed to list templates and view their details."
msgstr "允許使用者禁用自己的令牌。"

#: lib/policy.py:2358
msgid "Limit the number of allowed tokens in a realm."
msgstr "限制域中允許的令牌數。"

#: lib/policy.py:2362
msgid ""
"During the rollout process, this policy makes the description required for "
"all selected tokentypes."
msgstr ""

#: lib/policy.py:2370
msgid "Limit the number of tokens a user may have assigned."
msgstr "限制使用者可能已分配的令牌數。"

#: lib/policy.py:2375
msgid "Limit the number of active tokens a user may have assigned."
msgstr "限制使用者可能已分配的活動令牌數。"

#: lib/policy.py:2380
msgid ""
"Set a random OTP PIN with this length for a token during the enrollment "
"process."
msgstr "在註冊過程中為令牌設置具有此長度的隨機 OTP PIN。"

#: lib/policy.py:2385
msgid "In case of a random OTP PIN use this python module to process the PIN."
msgstr "如果是隨機的OTP PIN，請使用此python模組來處理PIN。"

#: lib/policy.py:2390
msgid ""
"If the administrator sets the OTP PIN during enrollment or later, the user "
"will have to change the PIN during first use."
msgstr ""
"如果管理員在註冊期間或之後設置了 OTP PIN，則用戶必須在第一次使用時更改 PIN。"

#: lib/policy.py:2397
msgid ""
"The user needs to change his PIN on a regular basis. To change the PIN every "
"180 days, enter '180d'."
msgstr "使用者需要定期更改其 PIN。要每 180 天更改 PIN 碼，請輸入\"180d\"。"

#: lib/policy.py:2404
msgid ""
"The OTP PIN can be hashed or encrypted. Hashing the PIN is the default "
"behaviour."
msgstr "OTP PIN可以進行hash或加密。對 PIN 進行hash處理是預設行為。"

#: lib/policy.py:2409
#, python-brace-format
msgid ""
"The label for a new enrolled Smartphone token. Possible tags are <code>{user}"
"</code>, <code>{realm}</code>, <code>{serial}</code>, <code>{givenname}</"
"code> and <code>{surname}</code>."
msgstr ""

#: lib/policy.py:2415
#, python-brace-format
msgid ""
"The issuer label for new enrolled Smartphone token.Possible tags are "
"<code>{user}</code>, <code>{realm}</code>, <code>{serial}</code>, "
"<code>{givenname}</code> and <code>{surname}</code>."
msgstr ""

#: lib/policy.py:2422
msgid ""
"This is the URL to the token image for the privacyIDEA Authenticator and "
"some other apps like FreeOTP (supported file formats: PNG, JPG and GIF)."
msgstr ""

#: lib/policy.py:2429
msgid ""
"Users can assign a token just by using the unassigned token to authenticate."
msgstr "使用者只需使用未分配的令牌進行身份驗證即可分配令牌。"

#: lib/policy.py:2435
msgid "The length of the password in case of temporary token (lost token)."
msgstr "臨時令牌（丟失令牌）情況下的密碼長度。"

#: lib/policy.py:2439
msgid ""
"The contents of the temporary password, described by the characters C, c, n, "
"s, 8."
msgstr "臨時密碼的內容，由字元 C、c、n、s、8 描述。"

#: lib/policy.py:2444
msgid "The length of the validity for the temporary token (in days)."
msgstr "臨時令牌的有效期長度（以天為單位）。"

#: lib/policy.py:2449
msgid "Set the length of registration codes."
msgstr "設置註冊碼的長度。"

#: lib/policy.py:2453
msgid ""
"Specify the required contents of the registration code. (c)haracters, "
"(n)umeric, (s)pecial. Use modifiers +/- or a list of allowed characters "
"[1234567890]"
msgstr ""
"指定註冊碼所需的內容。 (c) 字符，(n) 數字，(s) 特殊。使用修飾符 +/- 或允許的"
"字符列表 [1234567890]"

#: lib/policy.py:2462
msgid "Set the length of the password of generated password tokens."
msgstr ""

#: lib/policy.py:2466
msgid ""
"Specify the required contents of the password of a password token. "
"(c)haracters, (n)umeric, (s)pecial. Use modifiers +/- or a list of allowed "
"characters [1234567890]"
msgstr ""

#: lib/policy.py:2474
msgid ""
"Specify the email validator that should be used to validate email addresses "
"during enrollment."
msgstr ""

#: lib/policy.py:2480
msgid ""
"Specify the list of token types, that must be verified during enrollment."
msgstr ""

#: lib/policy.py:2493
msgid ""
"Either use the Token PIN , use the Userstore Password or use no fixed "
"password component."
msgstr "使用令牌 PIN ，使用使用者儲存密碼或不使用固定密碼元件。"

#: lib/policy.py:2498
#, fuzzy
#| msgid ""
#| "This is a whitespace separated list of tokentypes, that can be used with "
#| "challenge response."
msgid ""
"Specify the list of token types, that must be used with challenge response."
msgstr "這是一個以空格分隔的令牌類型清單，可與質詢回應一起使用。"

#: lib/policy.py:2506
#, fuzzy
#| msgid ""
#| "Use an alternate challenge text for telling the user to enter the code "
#| "from the eMail."
msgid ""
"Use an alternative challenge text for telling the user to enter an OTP "
"value. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr "使用替代質詢文本告訴使用者輸入電子郵件中的代碼。"

#: lib/policy.py:2513
msgid ""
"If there are several different challenges, this text precedes the list of "
"the challenge texts."
msgstr "如果存在多個不同的質詢，則此文本位於質詢文本清單之前。"

#: lib/policy.py:2518
msgid ""
"If there are several different challenges, this text follows the list of the "
"challenge texts."
msgstr "如果有幾個不同的挑戰，則此文本將遵循挑戰文本清單。"

#: lib/policy.py:2523
msgid ""
"If the PIN of a token is to be changed, this will allow the user to change "
"the PIN during a validate/check request via challenge / response."
msgstr ""
"如果要更改令牌的 PIN，這將允許使用者在驗證/檢查請求期間通過質詢/回應更改 "
"PIN。"

#: lib/policy.py:2528
msgid ""
"The autoresync of a token can be done via a challenge response message.You "
"need to activate 'Automatic resync' in the general settings!"
msgstr ""

#: lib/policy.py:2533
msgid ""
"In case of a successful authentication the following tokentype is enrolled. "
"The maximum number of tokens for a user is checked."
msgstr ""

#: lib/policy.py:2539
msgid "Change the default text that is shown during enrolling a token."
msgstr ""

#: lib/policy.py:2544
msgid ""
"If set, the user in this realm will be authenticated against the userstore "
"or against the given RADIUS config, if the user has no tokens assigned."
msgstr ""
"如果設置，則此域中的使用者將根據使用者存儲或給定的RADIUS配置進行身份驗證（如"
"果使用者未分配令牌）。"

#: lib/policy.py:2551
msgid ""
"This allows to automatically assign a Token within privacyIDEA, if the user "
"was authenticated via passthru against a RADIUS server. The OTP value is "
"used to find the unassigned token in privacyIDEA. Enter the length of the "
"OTP value and where the PIN is set like 8:pin or pin:6."
msgstr ""
"這允許在privacyIDEA中自動分配令牌，如果用戶是通過PASSTHRU對RADIUS伺服器進行身"
"份驗證的。OTP 值用於在 privacyIDEA 中查找未分配的令牌。輸入 OTP 值的長度以及 "
"PIN 設置的位置，如 8：pin 或 pin：6。"

#: lib/policy.py:2558
msgid ""
"If the user has no token, the authentication request for this user will "
"always be true."
msgstr "如果用戶沒有令牌，則此使用者的身份驗證請求將始終為 true。"

#: lib/policy.py:2563
msgid ""
"If the user user does not exist, the authentication request for this non-"
"existing user will always be true."
msgstr "如果用戶使用者不存在，則此不存在使用者的身份驗證請求將始終為 true。"

#: lib/policy.py:2569
msgid ""
"Can be used to modify the parameters pass, user and realm in an "
"authentication request. See the documentation for an example."
msgstr "可用於修改認證請求中的參數傳遞、用戶和領域。有關範例，請參閱文檔。"

#: lib/policy.py:2575
msgid ""
"If a user authenticates successfully reset the failcounter of all of his "
"tokens."
msgstr "如果使用者成功通過身份驗證，請重置其所有令牌的失敗計數器。"

#: lib/policy.py:2580
msgid ""
"Increase the failcounter for all the tokens, for which a challenge has been "
"triggered."
msgstr ""

#: lib/policy.py:2584
msgid ""
"Cache the password used for authentication and allow authentication with the "
"same credentials for a certain amount of time. Specify timeout like 4h or "
"4h/5m."
msgstr ""
"緩存用於身份驗證的密碼，並允許使用相同的憑據進行身份驗證一段時間。指定超時，"
"如 4 小時或 4 小時/5 分鐘。"

#: lib/policy.py:2591
msgid ""
"You can set the client modes in the order that you prefer. For example: "
"\"interactive webauthn poll u2f\". Accepted values are: <code>interactive "
"webauthn poll u2f</code>"
msgstr ""

#: lib/policy.py:2597
msgid ""
"When enabled, authentication attempts will be interpreted as either the PIN "
"or the answer to a challenge. PIN concatenated with OTP can not be used "
"anymore! Does only work when authenticating with a username."
msgstr ""

#: lib/policy.py:2605
#, python-brace-format
msgid ""
"Allow the user to authenticate (default). If set to '{0!s}', the "
"authentication of the user will be denied."
msgstr ""
"允許使用者進行身份驗證（預設）。如果設置為'{0!s}'，則使用者的身份驗證將被拒"
"絕。"

#: lib/policy.py:2612
msgid ""
"Allow the application to choose which token types should be used for "
"authentication. Application may set the parameter 'type' in the request. "
"Works with validate/check, validate/samlcheck and validate/triggerchallenge."
msgstr ""
"允許應用程式選擇應用於身份驗證的令牌類型。應用程式可以在請求中設置參數"
"「type」。使用驗證/檢查，驗證/samlcheck和驗證/觸發挑戰。"

#: lib/policy.py:2619
msgid ""
"You can specify how many successful authentication requests a user is "
"allowed to do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h "
"being second, minute and hour."
msgstr ""
"您可以指定在給定時間內允許使用者執行多少個成功的身份驗證請求。指定 1/5 秒、"
"2/10 分鐘、10/1 小時 - 秒、分、小時為秒、分鐘和小時。"

#: lib/policy.py:2627
msgid ""
"You can specify how many failed authentication requests a user is allowed to "
"do in a given time. Specify like 1/5s, 2/10m, 10/1h - s, m, h being second, "
"minute and hour."
msgstr ""
"您可以指定在給定時間內允許使用者執行多少個失敗的身份驗證請求。指定 1/5 秒、"
"2/10 分鐘、10/1 小時 - 秒、分、小時為秒、分鐘和小時。"

#: lib/policy.py:2635
msgid ""
"You can specify in which time frame the user needs to authenticate again "
"with this token. If the user authenticates later, authentication will fail. "
"Specify like 30h, 7d or 1y."
msgstr ""
"您可以指定使用者需要使用此權杖再次進行身份驗證的時間範圍。如果使用者稍後進行"
"身份驗證，則身份驗證將失敗。指定類似 30小時、7天 或 1年。"

#: lib/policy.py:2643
msgid "The user will only be authenticated with this very tokentype."
msgstr "使用者將僅使用此令牌類型進行身份驗證。"

#: lib/policy.py:2650
msgid ""
"The user will only be authenticated if the serial number of the token "
"matches this regexp."
msgstr "僅當令牌的序列號與此正則表達式匹配時，才會對用戶進行身份驗證。"

#: lib/policy.py:2656
#, fuzzy
#| msgid ""
#| "The user will only be authenticated if the tokeninfo field matches the "
#| "regexp. key/&lt;regexp&gt;/"
msgid ""
"The user will only be authenticated if the tokeninfo field matches the "
"regexp (key/&lt;regexp&gt;/)."
msgstr ""
"僅當 tokeninfo 字段與正則表示式匹配時，才會對用戶進行身份驗證。Key/&lt;"
"regexp&gt;/"

#: lib/policy.py:2663
msgid ""
"The Realm of the user is set to this very realm. This is important if the "
"user is not contained in the default realm and can not pass his realm."
msgstr ""
"使用者的「領域」被設置為此領域。如果使用者不包含在默認領域中並且無法通過其領"
"域，這一點很重要。"

#: lib/policy.py:2670
msgid ""
"In case of successful authentication additional no detail information will "
"be returned."
msgstr "如果身份驗證成功，則不會返回其他詳細資訊。"

#: lib/policy.py:2677
msgid ""
"In case of failed authentication additional no detail information will be "
"returned."
msgstr "如果身份驗證失敗，則不會返回任何詳細資訊。"

#: lib/policy.py:2684
msgid ""
"In case of successful authentication user data will be added in the detail "
"branch of the authentication response."
msgstr "如果身份驗證成功，用戶數據將添加到身份驗證回應的詳細資訊分支中。"

#: lib/policy.py:2691
msgid ""
"In case of successful authentication the user resolver and realm will be "
"added in the detail branch of the authentication response."
msgstr "如果認證成功，使用者解析程式和領域將添加到認證回應的詳細資訊分支中。"

#: lib/policy.py:2698
msgid ""
"The sending of an API Auth Key is required duringauthentication. This avoids "
"rogue authenticate requests against the /validate/check interface."
msgstr ""
"在身份驗證期間需要發送 API 身份驗證金鑰。這樣可以避免針對 /validate/check 介"
"面的惡意身份驗證請求。"

#: lib/policy.py:2707
msgid ""
"If set, administrators will see a dashboard as start screen when logging in "
"to privacyIDEA WebUI."
msgstr ""
"如果設置，管理員在登錄到 privacyIDEA WebUI 時將看到一個儀錶板作為開始螢幕。"

#: lib/policy.py:2713
msgid ""
"If set to \"privacyIDEA\" the users and admins need to authenticate against "
"privacyIDEA when they log in to the Web UI. Defaults to \"userstore\"."
msgstr ""
"如果設置為\"privacyIDEA\"，則使用者和管理員在登錄到 Web UI 時需要針對 "
"privacyIDEA 進行身份驗證。默認為「用戶存儲」。。"

#: lib/policy.py:2721
msgid ""
"An alternative text to display on the WebUI login dialog instead of \"Please "
"sign in\"."
msgstr "要在 WebUI 登錄對話框中顯示的替代文字，而不是「請登錄」。"

#: lib/policy.py:2725
msgid ""
"When searching in the user list, the search will only performed when "
"pressing enter."
msgstr "在使用者清單中搜索時，只有在按 Enter 鍵時才會執行搜索。"

#: lib/policy.py:2730
msgid ""
"The action taken when a user is idle beyond the logout_time limit. Defaults "
"to \"lockscreen\"."
msgstr "當用戶處於空閒狀態超過logout_time限制時執行的操作。默認為「鎖屏」。。"

#: lib/policy.py:2738
msgid ""
"The REMOTE_USER set by the webserver can be used to login to privacyIDEA or "
"it will be ignored. Defaults to \"disable\"."
msgstr ""
"Web伺服器設置的REMOTE_USER可用於登錄到privacyIDEA，否則將被忽略。默認為「禁"
"用」。"

#: lib/policy.py:2744
msgid ""
"Set the time in seconds after which the user will be logged out from the "
"WebUI. Default: 120"
msgstr ""
"設置時間（以秒為單位），在此時間之後，使用者將從 WebUI 註銷。默認值：120"

#: lib/policy.py:2749
msgid ""
"privacyIDEA issues a JWT when the user or admins logs in to the WebUI. The "
"default validity is 1 hour. You can specify different validity times in "
"seconds."
msgstr ""

#: lib/policy.py:2754
msgid "Set how many tokens should be displayed in the token view on one page."
msgstr "設置應在一個頁面上的令牌檢視中顯示多少個令牌。"

#: lib/policy.py:2759
msgid "Set how many users should be displayed in the user view on one page."
msgstr "設置應在一個頁面上的用戶檢視中顯示多少個使用者。"

#: lib/policy.py:2764
msgid ""
"Set how many audit entries should be displayed in the audit view on one page."
msgstr ""

#: lib/policy.py:2769
msgid "Use your own html template for the web UI menu."
msgstr "將您自己的 html 範本用於 Web UI 功能表。"

#: lib/policy.py:2773
msgid "Use your own html template for the web UI baseline/footer."
msgstr "將您自己的 html 範本用於 Web UI 基線/頁腳。"

#: lib/policy.py:2777
msgid "Link your privacy statement to be displayed in the baseline/footer."
msgstr "連結您的隱私聲明以顯示在基線/頁腳中。"

#: lib/policy.py:2781
msgid ""
"Whether the user ID and the resolver should be displayed in the token list."
msgstr "使用者ID和解析程式是否應顯示在令牌清單中。"

#: lib/policy.py:2786
msgid ""
"The URL of a repository, where the policy templates can be found.  (Default "
"https: //raw.githubusercontent.com/ privacyidea/policy-templates /master/"
"templates/)"
msgstr ""
"存儲庫的 URL，可在其中找到策略範本。 （默認 https: //raw.githubusercontent."
"com/ privacyidea/policy-templates /master/templates/）"

#: lib/policy.py:2793
msgid ""
"The URL of an SSO provider for redirect at logout.(The URL must start with "
"http:// or https://)"
msgstr ""

#: lib/policy.py:2798
msgid ""
"As long as a user has no token, he will only see a token wizard in the UI."
msgstr "只要用戶沒有令牌，他就只會在UI中看到令牌精靈。"

#: lib/policy.py:2804
msgid ""
"The tokenwizard will be displayed in the token menu, even if the user "
"already has a token."
msgstr "令牌精靈將顯示在令牌功能表中，即使使用者已有令牌也是如此。"

#: lib/policy.py:2810
msgid ""
"This is a whitespace separated list of tokentypes, for which a rollover "
"button is displayed in the token details."
msgstr "這是一個以空格分隔的令牌類型清單，令牌詳細資訊中會顯示一個翻轉按鈕。"

#: lib/policy.py:2817
msgid ""
"The welcome dialog will be displayed if the user has no tokens assigned."
msgstr "如果使用者未分配令牌，將顯示歡迎對話方塊。"

#: lib/policy.py:2821
msgid "This is the default token type in the token enrollment dialog."
msgstr "這是令牌註冊對話框中的預設令牌類型。"

#: lib/policy.py:2827
#, fuzzy
#| msgid "This is the default token type in the token enrollment dialog."
msgid "This is the default container type in the container create dialog."
msgstr "這是令牌註冊對話框中的預設令牌類型。"

#: lib/policy.py:2832
msgid ""
"A list of realm names, which are displayed in a drop down menu in the WebUI "
"login screen. Realms are separated by white spaces."
msgstr ""
"領域名稱清單，這些名稱顯示在 WebUI 登錄螢幕的下拉功能表中。領域由空格分隔。"

#: lib/policy.py:2838
msgid ""
"If this checked, the administrator will not see the welcome dialog anymore."
msgstr "如果選取此選項，管理員將不再看到歡迎對話框。"

#: lib/policy.py:2843
msgid ""
"Per default disabled actions result in disabled buttons. When checking this "
"action, buttons of disabled actions are hidden."
msgstr ""
"默認情況下，禁用的操作會導致禁用的按鈕。選取此操作時，禁用操作的按鈕將被隱"
"藏。"

#: lib/policy.py:2848
msgid ""
"If this is checked, there will be a confirmation prompt when deleting "
"policies, events, mresolver, resolver or periodic tasks!"
msgstr ""

#: lib/policy.py:2853
msgid ""
"If this is checked, the seed will be displayed as text during enrollment."
msgstr "如果選取此選項，種子將在註冊期間顯示為文字。"

#: lib/policy.py:2858
msgid ""
"If this is checked, the privacyIDEA Node name will be displayed in the menu "
"bar."
msgstr "如果選取此選項，則privacyIDEA節點名稱將顯示在功能表欄中。"

#: lib/policy.py:2863
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the Google "
"Play Store."
msgstr ""
"如果選取此選項，則 HOTP、TOTP 和 Push 令牌的註冊頁面將包含一個 QR 碼，該 QR "
"碼將指向 Google Play 商店中的privacyIDEA身份驗證器。"

#: lib/policy.py:2870
msgid ""
"If this is checked, the enrollment page for HOTP, TOTP and Push tokens will "
"contain a QR code that leads to the privacyIDEA Authenticator in the iOS App "
"Store."
msgstr ""
"如果選取此選項，HOTP、TOTP 和 Push 令牌的註冊頁面將包含一個 QR 碼，該 QR 碼將"
"指向 iOS App Store 中的 privacyIDEA 身份驗證器。"

#: lib/policy.py:2877
msgid ""
"This action adds a QR code in the enrollment page for HOTP, TOTP and Push "
"tokens, that lead to this given URL."
msgstr ""
"此操作將在 HOTP、TOTP 和推送令牌的註冊頁面中添加一個 QR 碼，該代碼將指向此給"
"定 URL。"

#: lib/policy.py:2882
msgid ""
"The RSS feeds fetched for the user defined in the format: "
"<code>'Title':'URL'-'Title':'URL'</code> "
msgstr ""

#: lib/policy.py:2885
msgid ""
"The age of the RSS feed entries in days. Use <code>0</code> to hide the news "
"feed. For admins the default is 180 days and for users 0 days."
msgstr ""

#: lib/policy.py:2889
msgid ""
"Container type to be created with the container wizard. It is required to "
"set at least this option to enable the container wizard. As long as the user "
"has no container assigned he will only see the container wizard in the UI."
msgstr ""

#: lib/policy.py:2896
msgid ""
"Name of the container template to be used to create a container in the "
"container wizard (optional). Note that the template must be of the same type "
"as selected in the container_wizard_type."
msgstr ""

#: lib/policy.py:2902
msgid ""
"In the container wizard, a QR code will be generated to register the new "
"container on the smartphone. (Only applicable for smartphone containers)"
msgstr ""

#: lib/policy.py:2910
msgid ""
"The URL of your privacyIDEA server, e.g. <code>https://pi/</code>. It is "
"used to build URLs the container can contact for registration and "
"synchronization."
msgstr ""

#: lib/policy.py:2916
msgid ""
"The time in minutes the client has to do the second step of the "
"registration. The default is ten minutes."
msgstr ""

#: lib/policy.py:2922
msgid ""
"After the client (a registered container) has challenged an action such as "
"synchronization or unregistration, this defines the time in minutes the "
"client has to complete the action. The default is two minutes."
msgstr ""

#: lib/policy.py:2931
msgid ""
"The container needs to verify the SSL certificate of the privacyIDEA server "
"during registration and synchronization. (default True)"
msgstr ""

#: lib/policy.py:2938
#, fuzzy
#| msgid "The user is allowed to reset the failcounter of his tokens."
msgid ""
"The client is allowed to perform a rollover of the container and the "
"included tokens."
msgstr "允許使用者重置自己令牌的失敗計數器。"

#: lib/policy.py:2943
msgid ""
"During the first synchronization, the server automatically adds the clients "
"tokens existing in privacyIDEA to the container. This allows to register "
"devices with existing tokens as container without having to manually add the "
"tokens on the device to the container."
msgstr ""

#: lib/policy.py:2950
#, fuzzy
#| msgid "The user is allowed to delete his own tokens."
msgid "The user is not allowed to delete tokens locally on the smartphone."
msgstr "允許用戶刪除自己的令牌。"

#: lib/policy.py:2955
msgid ""
"The client is not allowed to unregister the container. The user can not "
"delete the container locally on the smartphone."
msgstr ""

#: lib/policy.py:3000
msgid ""
"The policy only matches if certain conditions on the user info are fulfilled."
msgstr "僅當滿足使用者資訊的某些條件時，策略才匹配。"

#: lib/policy.py:3003
msgid ""
"The policy only matches if certain conditions of the token attributes are "
"fulfilled."
msgstr "僅當滿足令牌屬性的某些條件時，策略才匹配。"

#: lib/policy.py:3006
msgid ""
"The policy only matches if certain conditions on the token info are "
"fulfilled."
msgstr "僅當滿足令牌資訊上的某些條件時，策略才匹配。"

#: lib/policy.py:3009
msgid ""
"The policy only matches if certain conditions on the HTTP Request header are "
"fulfilled."
msgstr "僅當滿足 HTTP 請求標頭上的某些條件時，該策略才匹配。"

#: lib/policy.py:3012
msgid ""
"The policy only matches if certain conditions on the HTTP Environment are "
"fulfilled."
msgstr ""

#: lib/radiusserver.py:223 lib/radiusserver.py:255
msgid "The RADIUS secret is too long"
msgstr "RADIUS 金鑰太長"

#: lib/subscriptions.py:43
msgid "My subscription has expired."
msgstr ""

#: lib/token.py:169
#, python-brace-format
msgid "create_tokenclass_object failed:  {0!r}"
msgstr ""

#: lib/token.py:335
msgid "I can only create SQL filters from tokeninfo of length 1."
msgstr ""

#: lib/token.py:349
#, python-brace-format
msgid "No container with the serial {container_serial} exists."
msgstr ""

#: lib/token.py:742
msgid "The requested token could not be found."
msgstr ""

#: lib/token.py:747
msgid "More than one matching token was found."
msgstr ""

#: lib/token.py:1051
msgid "multiple tokens are matching this OTP value!"
msgstr ""

#: lib/token.py:1270
msgid "init token failed. Unknown token type:"
msgstr ""

#: lib/token.py:1290
#, python-brace-format
msgid ""
"Token {serial} already exists with type {old_type}. Can not initialize token "
"with new type {token_type}"
msgstr ""

#: lib/token.py:1294
msgid "init token failed:"
msgstr ""

#: lib/token.py:1470
#, python-brace-format
msgid "Token already assigned to user {old_user!r}"
msgstr ""

#: lib/token.py:1484
#, python-brace-format
msgid "Token assign failed for {0!r}/{1!s} : {2!r}"
msgstr ""

#: lib/token.py:1512
msgid "Token unassign failed for"
msgstr ""

#: lib/token.py:1592
msgid "Parameter user must not be a string:"
msgstr ""

#: lib/token.py:2148
msgid "You can only define a lost token for an assigned token."
msgstr ""

#: lib/token.py:2174
#, python-brace-format
msgid "temporary replacement for {0!s}"
msgstr ""

#: lib/token.py:2230
msgid "There is no active and assigned token in this realm"
msgstr ""

#: lib/token.py:2242
#, python-brace-format
msgid ""
"There is no active and assigned token in this realm, included types: {0!s}, "
"excluded types: {1!s}"
msgstr ""

#: lib/token.py:2295
msgid "OTP verification failed."
msgstr ""

#: lib/token.py:2329
msgid "The user has no tokens assigned"
msgstr ""

#: lib/token.py:2550
#, python-brace-format
msgid "matching {0:d} tokens"
msgstr ""

#: lib/token.py:2598
msgid "Challenge matches, but token is not fit for challenge"
msgstr ""

#: lib/token.py:2647
msgid "Response did not match the challenge."
msgstr ""

#: lib/token.py:2649
#, python-brace-format
msgid "Response did not match for {0!s} tokens."
msgstr ""

#: lib/token.py:2656
msgid "No active challenge response token found"
msgstr ""

#: lib/token.py:2672
msgid "wrong otp value"
msgstr ""

#: lib/token.py:2679
msgid ". previous otp used again"
msgstr ""

#: lib/token.py:2693
msgid "wrong otp pin"
msgstr ""

#: lib/token.py:2701
msgid "No suitable token found for authentication."
msgstr ""

#: lib/token.py:2726
#, fuzzy, python-brace-format
msgid "Admin is allowed to initialize {0!s} tokens."
msgstr "允許管理員初始化{0!s}令牌。"

#: lib/token.py:2734
#, python-brace-format
msgid "The user is allowed to enroll a {0!s} token."
msgstr "允許用戶註冊{0!s}令牌。"

#: lib/token.py:2765
#, python-brace-format
msgid "Set the maximum allowed PIN length of the {0!s} token."
msgstr "設置{0!s}令牌允許的最大 PIN 長度。"

#: lib/token.py:2772
#, python-brace-format
msgid "Set the minimum required PIN length of the {0!s} token."
msgstr "設置{0!s}令牌所需的最小 PIN 長度。"

#: lib/token.py:2778
#, python-brace-format
msgid ""
"Specifiy the required PIN contents of the {0!s} token. (c)haracters, "
"(n)umeric, (s)pecial, (o)thers. [+/-]!"
msgstr ""
"指定 {0!s} 令牌所需的 PIN 內容。 (c) 字符、(n) 數字、(s) 特殊、(o) 其他。 "
"[+/-]！"

#: lib/token.py:2823 lib/token.py:2839
msgid "The tokengroup does not exist."
msgstr ""

#: lib/token.py:2976
#, python-brace-format
msgid " Please press: {presence_answer}"
msgstr ""

#: lib/tokenclass.py:1700
msgid "please enter otp: "
msgstr "請輸入 otp： "

#: lib/applications/ssh.py:105
#, fuzzy
msgid "The username on the SSH server."
msgstr "強制在伺服器上生成金鑰。"

#: lib/applications/ssh.py:107
msgid ""
"The service ID of the SSH server. Several servers can have the same service "
"ID."
msgstr ""

#: lib/containers/smartphone.py:123
msgid "A smartphone that uses an authenticator app."
msgstr ""

#: lib/containers/smartphone.py:219
#, fuzzy
#| msgid "URL for privacyIDEA Push Token"
msgid "URL for privacyIDEA Container Registration"
msgstr "privacyIDEA 推送令牌的URL"

#: lib/containers/yubikey.py:62
msgid ""
"Yubikey hardware device that can hold HOTP, certificate and webauthn token"
msgstr ""

#: lib/eventhandler/base.py:175
msgid ""
"The challenge session matches the string or regular expression (like "
"'challenge_declined' or 'enrollment')"
msgstr ""

#: lib/eventhandler/base.py:182
msgid "The challenge of a token during the authentication process is expired."
msgstr ""

#: lib/eventhandler/base.py:190
msgid ""
"The rollout_state of the token has a certain value like 'clientwait' or "
"'enrolled'."
msgstr "令牌的rollout_state具有特定值，如\"用戶端等待\"或\"已註冊\"。"

#: lib/eventhandler/base.py:196
msgid "The realm of the user, for which this event should apply."
msgstr "用戶的領域，此事件應應用到該領域。"

#: lib/eventhandler/base.py:203
msgid "The resolver of the user, for which this event should apply."
msgstr "使用者的安全解決程式，應應用此事件。"

#: lib/eventhandler/base.py:210
msgid "The realm of the token, for which this event should apply."
msgstr "令牌的領域，此事件應適用於該領域。"

#: lib/eventhandler/base.py:218
msgid "The resolver of the token, for which this event should apply."
msgstr "令牌的解析程式，此事件應應用。"

#: lib/eventhandler/base.py:226
msgid "The type of the token."
msgstr "令牌的類型。"

#: lib/eventhandler/base.py:233
msgid "The logged in user is of the following type."
msgstr "登錄使用者屬於以下類型。"

#: lib/eventhandler/base.py:240
msgid "The result.value within the response is True or False."
msgstr "回應中的 result.value 為 True 或 False。"

#: lib/eventhandler/base.py:248
msgid "The result.status within the response is True or False."
msgstr "回應中的 result.status 為 True 或 False。"

#: lib/eventhandler/base.py:256
#, fuzzy
#| msgid "The result.value within the response is True or False."
msgid "The result.authentication within the response is the given value."
msgstr "回應中的 result.value 為 True 或 False。"

#: lib/eventhandler/base.py:264
msgid "Check if the max failcounter of the token is reached."
msgstr "檢查是否達到令牌的最大失敗計數器。"

#: lib/eventhandler/base.py:272
msgid "The token has a user assigned."
msgstr "令牌分配了使用者。"

#: lib/eventhandler/base.py:279
msgid ""
"The token has a user assigned, but the user does not exist in the userstore "
"anymore."
msgstr "令牌分配了一個使用者，但該使用者不再存在於使用者存儲中。"

#: lib/eventhandler/base.py:287
msgid "Check if the token is within its validity period."
msgstr "檢查令牌是否在其有效期內。"

#: lib/eventhandler/base.py:294
msgid "Action is triggered, if the serial matches this regular expression."
msgstr "如果串行與此正則表示式匹配，則觸發操作。"

#: lib/eventhandler/base.py:301
#, fuzzy
#| msgid "The token has a user assigned."
msgid "The token is in a container."
msgstr "令牌分配了使用者。"

#: lib/eventhandler/base.py:308
#, fuzzy
#| msgid "Action is triggered, if the user has this number of tokens assigned."
msgid ""
"Action is triggered, if the user has this number of tokens assigned. > and < "
"can be used, like <8."
msgstr "如果為使用者分配了此數量的令牌，則會觸發操作。"

#: lib/eventhandler/base.py:315
#, fuzzy
#| msgid "Action is triggered, if the user has this number of tokens assigned."
msgid ""
"Action is triggered, if the user has this number of containers assigned."
msgstr "如果為使用者分配了此數量的令牌，則會觸發操作。"

#: lib/eventhandler/base.py:322
msgid ""
"Action is triggered, if the counter of the token equals this setting. Can "
"also be '>100' or '<99' for no exact match."
msgstr ""
"如果令牌的計數器等於此設置，則觸發操作。也可以是\">100\"或\"<99\"，因為沒有完"
"全匹配。"

#: lib/eventhandler/base.py:330
msgid ""
"Action is triggered, if the last authentication of the token is older than "
"7h, 10d or 1y."
msgstr "如果令牌的最後一次身份驗證早於 7小時、10天 或 1年，則會觸發操作。"

#: lib/eventhandler/base.py:337
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth' is bigger than 100, less than 99 or exactly 100."
msgstr ""
"如果 tokeninfo 字段\"count_auth\"大於 100、小於 99 或正好 100，則可以使用"
"\">100\"、\"<99\"或\"=100\"來觸發操作。"

#: lib/eventhandler/base.py:345
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"tokeninfo field 'count_auth_success' is bigger than 100, less than 99 or "
"exactly 100."
msgstr ""
"如果 tokeninfo 字段 \"count_auth_success\" 大於 100、小於 99 或正好 100，則可"
"以使用\">100\"、\"<99\"或\"=100\"來觸發操作。"

#: lib/eventhandler/base.py:354
msgid ""
"This can be '>100', '<99', or '=100', to trigger the action, if the "
"difference between the tokeninfo field 'count_auth' and 'count_auth_success "
"is bigger than 100, less than 99 or exactly 100."
msgstr ""
"如果 tokeninfo 字段 \"count_auth\" 和 \"count_auth_success 之間的差異大於 "
"100、小於 99 或正好 100，則可以使用\">100\"、\"<99\"或\"=100\"來觸發操作。"

#: lib/eventhandler/base.py:363
msgid ""
"This can be '>9', '<9', or '=10', to trigger the action, if the failcounter "
"of a token matches this value. Note that the failcounter stops increasing, "
"if the max_failcount is reached."
msgstr ""
"如果令牌的 failcounter 與此值匹配，則可以使用\">9\"、\"<9\"或\"=10\"來觸發操"
"作。請注意，如果達到max_failcount，故障計數器將停止增加。"

#: lib/eventhandler/base.py:372
msgid ""
"This condition can check any arbitrary tokeninfo field. You need to enter "
"something like '<fieldname> == <fieldvalue>', '<fieldname> > <fieldvalue>' "
"or '<fieldname> < <fieldvalue>'."
msgstr ""
"此條件可以檢查任何任意令牌資訊欄位。您需要輸入類似\"<fieldname> == "
"<fieldvalue>\"、\"<fieldname> > <fieldvalue>\"或\"<fieldname> < "
"<fieldvalue>\"之類的內容。"

#: lib/eventhandler/base.py:381
msgid ""
"This condition can check the value of an arbitrary event counter and compare "
"it like 'myCounter == 1000', 'myCounter > 1000' or 'myCounter < 1000'."
msgstr ""
"此條件可以檢查任意事件計數器的值，並將其進行比較，如\"myCounter == "
"1000\"、\"myCounter > 1000\"或\"myCounter < 1000\"。"

#: lib/eventhandler/base.py:389
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->error->message in the response."
msgstr ""
"在這裡，您可以輸入正規表示式。僅當正則表達式與回應中的詳細資訊>錯誤>消息匹配"
"時，該條件才適用。"

#: lib/eventhandler/base.py:397
msgid ""
"Here you can enter a regular expression. The condition only applies if the "
"regular expression matches the detail->message in the response."
msgstr ""
"在這裡，您可以輸入正規表示式。僅當正則表達式與回應中的詳細資訊>消息匹配時，該"
"條件才適用。"

#: lib/eventhandler/base.py:405
msgid "Trigger the action, if the client IP matches."
msgstr "如果用戶端 IP 匹配，則觸發操作。"

#: lib/eventhandler/base.py:411
msgid ""
"The container is in the specified states, but can additionally be in other "
"states."
msgstr ""

#: lib/eventhandler/base.py:418
#, fuzzy
#| msgid "The admin will not see the specified columns in the audit."
msgid "The container is only in the specified states."
msgstr "管理員不會在審核中看到指定的列。"

#: lib/eventhandler/base.py:425
#, fuzzy
#| msgid "The token has a user assigned."
msgid "The container has a user assigned."
msgstr "令牌分配了使用者。"

#: lib/eventhandler/base.py:432
#, fuzzy
#| msgid "The token has a user assigned."
msgid "The container has at least one token assigned."
msgstr "令牌分配了使用者。"

#: lib/eventhandler/base.py:439
#, fuzzy
#| msgid "The logged in user is of the following type."
msgid "The container is of a certain type."
msgstr "登錄使用者屬於以下類型。"

#: lib/eventhandler/base.py:446
msgid ""
"The container is in this realm or in no realm at all. If multiple realms are "
"selected, the condition is fulfilled if the container is in at least one "
"realm of the list. The condition is not checked if the container has no "
"realm, hence the action would be triggered."
msgstr ""

#: lib/eventhandler/base.py:456
msgid ""
"An owner of the container is in this resolver. If multiple resolvers are "
"selected, the condition is fulfilled if at least one owner is in one "
"resolver. The condition is not checked if the container has no owner, hence "
"the action would be triggered."
msgstr ""

#: lib/eventhandler/base.py:465
#, fuzzy
#| msgid ""
#| "This condition can check any arbitrary tokeninfo field. You need to enter "
#| "something like '<fieldname> == <fieldvalue>', '<fieldname> > "
#| "<fieldvalue>' or '<fieldname> < <fieldvalue>'."
msgid ""
"This condition can check any arbitrary container info field. You need to "
"enter something like 'fieldname == fieldvalue', 'fieldname > fieldvalue' or "
"'fieldname < fieldvalue'."
msgstr ""
"此條件可以檢查任何任意令牌資訊欄位。您需要輸入類似\"<fieldname> == "
"<fieldvalue>\"、\"<fieldname> > <fieldvalue>\"或\"<fieldname> < "
"<fieldvalue>\"之類的內容。"

#: lib/eventhandler/base.py:474
msgid ""
"Action is triggered, if the last authentication of the container is older "
"than the specified time. The time value has to be an integer followed by a "
"time unit. Supported units are 'y' (years), 'd' (days), 'h' (hours), "
"'m' (minutes), 's' (seconds). Only one unit is allowed. Examples: '8h', "
"'7d', '1y'"
msgstr ""

#: lib/eventhandler/base.py:485
msgid ""
"Action is triggered, if the last synchronization of the container is older "
"than the specified time. The time value has to be an integer followed by a "
"time unit. Supported units are 'y' (years), 'd' (days), 'h' (hours), "
"'m' (minutes), 's' (seconds). Only one unit is allowed. Examples: '8h', "
"'7d', '1y'"
msgstr ""

#: lib/eventhandler/containerhandler.py:89
#, python-brace-format
msgid "Set the state {state}"
msgstr ""

#: lib/eventhandler/containerhandler.py:96
#, fuzzy
#| msgid "Token type to create"
msgid "Container type to create"
msgstr "要創建的令牌類型"

#: lib/eventhandler/containerhandler.py:102
#: lib/eventhandler/containerhandler.py:124
msgid "Description of the container"
msgstr "容器描述"

#: lib/eventhandler/containerhandler.py:107
#, fuzzy
#| msgid "Assign token to user in request or to tokenowner."
msgid "Assign container to user in request or to token/container owner"
msgstr "將令牌分配給請求中的使用者或令牌擁有者。"

#: lib/eventhandler/containerhandler.py:112
#, fuzzy
#| msgid "Assign token to user in request or to tokenowner."
msgid "Add token from request to container"
msgstr "將令牌分配給請求中的使用者或令牌擁有者。"

#: lib/eventhandler/containerhandler.py:132
msgid "Set this container info key (deletes all existing keys)."
msgstr ""

#: lib/eventhandler/containerhandler.py:136
#: lib/eventhandler/containerhandler.py:146
#, fuzzy
#| msgid "Set the failcounter of the token."
msgid "Set the value for the key above."
msgstr "設置令牌的失敗計數器。"

#: lib/eventhandler/containerhandler.py:142
msgid "Add this key to the container info."
msgstr ""

#: lib/eventhandler/counterhandler.py:67 lib/eventhandler/counterhandler.py:72
#: lib/eventhandler/counterhandler.py:80
msgid "The identifier/key of the counter."
msgstr "計數器的識別碼/金鑰。"

#: lib/eventhandler/counterhandler.py:75
msgid "Don't stop counter if it reaches zero."
msgstr "如果計數器達到零，請不要停止計數器。"

#: lib/eventhandler/customuserattributeshandler.py:61
msgid "The user for whom the custom attribute should be set."
msgstr ""

#: lib/eventhandler/customuserattributeshandler.py:68
msgid "The key of the custom user attribute that should be set."
msgstr ""

#: lib/eventhandler/customuserattributeshandler.py:71
msgid "The value of the custom user attribute."
msgstr ""

#: lib/eventhandler/customuserattributeshandler.py:77
msgid "The user from which the custom attribute should be deleted."
msgstr ""

#: lib/eventhandler/customuserattributeshandler.py:84
msgid "The key of the custom user attribute that should be deleted."
msgstr ""

#: lib/eventhandler/federationhandler.py:74
msgid "The remote/child privacyIDEA Server."
msgstr "遠端/兒童privacyIDEA伺服器。"

#: lib/eventhandler/federationhandler.py:79
msgid "Change the realm name to a realm on the child privacyIDEA system."
msgstr "將領域名稱更改為子privacyIDEA系統上的領域。"

#: lib/eventhandler/federationhandler.py:85
msgid "Change the resolver name to a resolver on the child privacyIDEA system."
msgstr "將解析程式名稱更改為子privacyIDEA 系統上的解析程式。"

#: lib/eventhandler/federationhandler.py:91
msgid ""
"Forward the client IP to the child privacyIDEA server. Otherwise this server "
"will be the client."
msgstr "將用戶端 IP 轉發到子privacyIDEA 伺服器。否則，此伺服器將是用戶端。"

#: lib/eventhandler/federationhandler.py:98
msgid ""
"Forward the authorization header. This allows to also forward request like "
"token- and system-requests."
msgstr "轉發授權標頭。這也允許轉發請求，如令牌和系統請求。"

#: lib/eventhandler/logginghandler.py:85
msgid "The name of the logging facility"
msgstr "日誌記錄工具的名稱"

#: lib/eventhandler/logginghandler.py:91
msgid "The string to write to the log"
msgstr "要寫入日誌的字串"

#: lib/eventhandler/logginghandler.py:97
msgid "The logging level for this logging notification"
msgstr "此記錄通知的紀錄記錄級別"

#: lib/eventhandler/requestmangler.py:87
msgid "The parameter that should be deleted."
msgstr "應刪除的參數。"

#: lib/eventhandler/requestmangler.py:93
msgid "The parameter that should be added or modified."
msgstr "應添加或修改的參數。"

#: lib/eventhandler/requestmangler.py:98
#, python-brace-format
msgid ""
"The new value of the parameter. Can contain tags like {0}, {1} for the "
"matched sub strings."
msgstr "參數的新值。可以包含匹配的子字串的{0}、{1}等標記。"

#: lib/eventhandler/requestmangler.py:103
msgid "The parameter, that should match some values."
msgstr "參數，應與某些值匹配。"

#: lib/eventhandler/requestmangler.py:107
msgid ""
"The value of the match_parameter. It can contain a regular expression and "
"'()' to transfer values to the new parameter."
msgstr "match_parameter的值。它可以包含正則表達式和'()'以將值傳輸到新參數。"

#: lib/eventhandler/requestmangler.py:112
msgid ""
"If the parameter is 'username', 'user' or 'realm', the user will be reset. "
"This can have an effect on any further actions on the user!"
msgstr ""

#: lib/eventhandler/responsemangler.py:79
msgid ""
"The JSON pointer (key) that should be deleted. Please specify in the format "
"'/detail/message'."
msgstr "應刪除的 JSON 指標（鍵）。請以\"/詳情/消息\"格式註明。"

#: lib/eventhandler/responsemangler.py:86
msgid ""
"The JSON pointer (key) that should be set. Please specify in the format '/"
"detail/message'."
msgstr "應設置的 JSON 指標（鍵）。請以\"/詳情/消息\"格式註明。"

#: lib/eventhandler/responsemangler.py:92
msgid "The type of the value."
msgstr "值的類型。"

#: lib/eventhandler/responsemangler.py:98
msgid "The value of the JSON key that should be set."
msgstr "應設置的 JSON 鍵的值。"

#: lib/eventhandler/scripthandler.py:92
#: lib/smsprovider/ScriptSMSProvider.py:121
msgid ""
"Wait for script to complete or run script in background. This will either "
"return the HTTP request early or could also block the request."
msgstr ""
"等待腳本完成或在後台運行腳本。這將提前返回 HTTP 請求，也可能阻止該請求。"

#: lib/eventhandler/scripthandler.py:100
msgid "On script error raise exception in HTTP request."
msgstr "腳本錯誤時，在 HTTP 請求中引發異常。"

#: lib/eventhandler/scripthandler.py:104
msgid ""
"Finish current transaction before running the script. This is useful if "
"changes to the database should be made available to the script or the "
"running request."
msgstr ""
"在運行腳本之前完成當前事務。如果對資料庫的更改應可用於腳本或正在運行的請求，"
"這將非常有用。"

#: lib/eventhandler/scripthandler.py:111
msgid "Add '--serial <serial number>' as script parameter."
msgstr "添加「--序列號<序列号>」作為腳本參數。"

#: lib/eventhandler/scripthandler.py:116
msgid "Add '--user <username>' as script parameter."
msgstr "添加\"--使用者<username>\"作為腳本參數。"

#: lib/eventhandler/scripthandler.py:121
msgid "Add '--realm <realm>' as script parameter."
msgstr "添加\"--領域<realm>\"作為腳本參數。"

#: lib/eventhandler/scripthandler.py:126
msgid ""
"Add the username of the logged in user as script parameter like '--"
"logged_in_user <username>'."
msgstr ""
"將登錄用戶的使用者名添加為腳本參數，如\"--logged_in_user <username>\"。"

#: lib/eventhandler/scripthandler.py:132
msgid ""
"Add the role (either admin or user) of the logged in user as script "
"parameter like '--logged_in_role <role>'."
msgstr ""
"將登錄使用者的角色（管理員或使用者）添加為腳本參數，如\"--logged_in_role "
"<role>\"。"

#: lib/eventhandler/tokenhandler.py:144
msgid "set a new realm of the token"
msgstr "設置令牌的新領域"

#: lib/eventhandler/tokenhandler.py:150
#, fuzzy
msgid ""
"The new realm will be the only realm of the token. I.e. all other realms "
"will be removed from this token. If disabled, the realm will be added to the "
"token."
msgstr ""
"新領域將是令牌的唯一領域。即，所有其他領域將從此令牌中刪除。否則，該領域將添"
"加到令牌中。"

#: lib/eventhandler/tokenhandler.py:167
msgid "set the PIN of the token to a random PIN of this length."
msgstr "將令牌的 PIN 設定為此長度的隨機 PIN。"

#: lib/eventhandler/tokenhandler.py:177
msgid "Token type to create"
msgstr "要創建的令牌類型"

#: lib/eventhandler/tokenhandler.py:183
msgid "Assign token to user in request or to tokenowner."
msgstr "將令牌分配給請求中的使用者或令牌擁有者。"

#: lib/eventhandler/tokenhandler.py:190
msgid "Set the realm of the newly created token."
msgstr "設置新創建的令牌的領域。"

#: lib/eventhandler/tokenhandler.py:199
msgid "Dynamically read the mobile number from the user store."
msgstr "從使用者存儲中動態讀取手機號碼。"

#: lib/eventhandler/tokenhandler.py:207
msgid "Dynamically read the email address from the user store."
msgstr "從使用者存儲中動態讀取電子郵件位址。"

#: lib/eventhandler/tokenhandler.py:215
msgid "Use a specific SMTP server configuration for this token."
msgstr "對此令牌使用特定的 SMTP 伺服器配置。"

#: lib/eventhandler/tokenhandler.py:223
msgid "Use a specific SMS gateway configuration for this token."
msgstr "對此令牌使用特定的SMS gateway 配置。"

#: lib/eventhandler/tokenhandler.py:229
msgid "A dictionary of additional init parameters."
msgstr "其他初始化參數的字典。"

#: lib/eventhandler/tokenhandler.py:236
msgid ""
"Set the MOTP PIN of the MOTP token during enrollment. This is a required "
"value for enrolling MOTP tokens."
msgstr "在註冊期間設置 MOTP 令牌的 MOTP PIN。這是註冊 MOTP 令牌的必需值。"

#: lib/eventhandler/tokenhandler.py:244
msgid ""
"Add the token to the container if there is one identifiable in the request."
msgstr ""

#: lib/eventhandler/tokenhandler.py:252
msgid "The new description of the token."
msgstr "令牌的新說明。"

#: lib/eventhandler/tokenhandler.py:261
msgid ""
"The token will be valid starting at the given date. Can be a fixed date or "
"an offset like +10m, +24h, +7d."
msgstr ""
"令牌將從給定日期開始有效。可以是固定日期，也可以是偏移量，如 +10分鐘、+24小"
"時、+7天。"

#: lib/eventhandler/tokenhandler.py:269
msgid ""
"The token will be valid until the given date. Can be a fixed date or an "
"offset like +10m, +24h, +7d."
msgstr ""
"令牌將在給定日期之前有效。可以是固定日期，也可以是偏移量，如 +10分鐘、+24小"
"時、+7天。"

#: lib/eventhandler/tokenhandler.py:283
msgid "Set the new count window of the token."
msgstr "設置令牌的新計數視窗。"

#: lib/eventhandler/tokenhandler.py:293
msgid "Set the failcounter of the token."
msgstr "設置令牌的失敗計數器。"

#: lib/eventhandler/tokenhandler.py:303
msgid ""
"Increase or decrease the fail counter of the token. Values of +n, -n with n "
"being an integer are accepted."
msgstr "增加或減少令牌的失敗計數器。接受 +n、-n 的值，其中 n 為整數。"

#: lib/eventhandler/tokenhandler.py:313
msgid "Set the maximum failcounter of the token."
msgstr "設置令牌的最大失敗計數器。"

#: lib/eventhandler/tokenhandler.py:322
msgid "Set this tokeninfo key."
msgstr "設置此令牌資訊金鑰。"

#: lib/eventhandler/tokenhandler.py:327
#, fuzzy
msgid "Set the above key to this value."
msgstr "將上面的項設置為 this 值。"

#: lib/eventhandler/tokenhandler.py:337
msgid ""
"Interpret the tokeninfo as 'int' and increase the tokeninfo value by the "
"given offset."
msgstr ""

#: lib/eventhandler/tokenhandler.py:343
msgid ""
"The increment the tokeninfo key should be increased. Can be positive or "
"negative, s.th. like +1 or -7."
msgstr ""

#: lib/eventhandler/tokenhandler.py:353
msgid "Delete this tokeninfo key."
msgstr "刪除此令牌資訊金鑰。"

#: lib/eventhandler/tokenhandler.py:362
msgid "Add a tokengroup to the token."
msgstr ""

#: lib/eventhandler/tokenhandler.py:372
msgid "Remove a tokengroup from the token."
msgstr ""

#: lib/eventhandler/tokenhandler.py:382
msgid "The ID of the machine you want to attach the token to"
msgstr ""

#: lib/eventhandler/tokenhandler.py:389
msgid "Set the service_id for an SSH application."
msgstr ""

#: lib/eventhandler/tokenhandler.py:398
msgid ""
"Set a token application like 'offline' or 'SSH'. Note: Not all tokens work "
"well with all applications!"
msgstr ""

#: lib/eventhandler/tokenhandler.py:408
msgid "The number of offline OTP values available"
msgstr ""

#: lib/eventhandler/tokenhandler.py:416
msgid "The number of rounds for password hashing"
msgstr ""

#: lib/eventhandler/usernotification.py:146
msgid "Send notification email via this email server."
msgstr "通過此電子郵件伺服器發送通知電子郵件。"

#: lib/eventhandler/usernotification.py:150
msgid "Either send email as plain text or HTML."
msgstr "以純文字或 HTML 格式發送電子郵件。"

#: lib/eventhandler/usernotification.py:154
msgid "Send QR-Code image as an attachment (cid URL: token_image)"
msgstr "將二維碼影像作為附件發送（URL：token_image）"

#: lib/eventhandler/usernotification.py:159
msgid "The subject of the mail that is sent."
msgstr "發送的郵件的主題。"

#: lib/eventhandler/usernotification.py:163
msgid "The Reply-To header in the sent email."
msgstr "已發送電子郵件中的「答覆」標頭。"

#: lib/eventhandler/usernotification.py:185
#: lib/eventhandler/usernotification.py:224
msgid "Any email address, to which the notification should be sent."
msgstr "應向其發送通知的任何電子郵件位址。"

#: lib/eventhandler/usernotification.py:192
#, python-brace-format
msgid ""
"The template of the mail body that will be sent. It may contain the "
"following tags as specified in the documentation: <code>{admin}, {realm}, "
"{action}, {serial}, {url}, {user}, {givenname}, {surname}, {username}, "
"{userrealm}, {tokentype}, {tokendescription}, {registrationcode}, "
"{recipient_givenname}, {recipient_surname}, {googleurl_value}, "
"{googleurl_img}, {pushurl_value}, {pushurl_img}, {container_url_value}, "
"{container_url_img}, {time}, {date}, {client_ip}, {ua_browser}, {ua_string}, "
"{pin}.</code>"
msgstr ""

#: lib/eventhandler/usernotification.py:203
#: lib/eventhandler/usernotification.py:248
msgid "Send notification to this user."
msgstr "向此用戶發送通知。"

#: lib/eventhandler/usernotification.py:233
msgid "Send the user notification via a predefined SMS gateway."
msgstr "通過預定義的SMS gateway 發送使用者通知。"

#: lib/eventhandler/usernotification.py:238
#, python-brace-format
msgid ""
"The text template of the SMS. It may contain the following tags as specified "
"in the documentation: <code>{admin}, {realm}, {action}, {serial}, {url}, "
"{user}, {givenname}, {surname}, {username}, {userrealm}, {tokentype}, "
"{tokendescription}, {registrationcode}, {recipient_givenname}, "
"{recipient_surname}, {googleurl_value}, {googleurl_img}, {pushurl_value}, "
"{pushurl_img}, {container_url_value}, {container_url_img}, {time}, {date}, "
"{client_ip}, {ua_browser}, {ua_string}, {pin}.</code>"
msgstr ""

#: lib/eventhandler/usernotification.py:255
#, python-brace-format
msgid ""
"This is the template content of the new file. It may contain the following "
"tags as specified in the documentation: <code>{admin}, {realm}, {action}, "
"{serial}, {url}, {user}, {givenname}, {surname}, {username}, {userrealm}, "
"{tokentype}, {tokendescription}, {registrationcode}, {recipient_givenname}, "
"{recipient_surname}, {googleurl_value}, {googleurl_img}, {pushurl_value}, "
"{pushurl_img}, {container_url_value}, {container_url_img}, {time}, {date}, "
"{client_ip}, {ua_browser}, {ua_string}, {pin}.</code>"
msgstr ""

#: lib/eventhandler/usernotification.py:266
#, python-brace-format
msgid ""
"The filename of the notification. Existing files are overwritten. The name "
"can contain tags as specified in the documentation and can also contain the "
"tag {random}."
msgstr ""
"通知的檔名。現有檔將被覆蓋。該名稱可以包含文檔中指定的標記，也可以包含標記 "
"{random}。"

#: lib/eventhandler/webhookeventhandler.py:82
msgid "The URL the WebHook is posted to"
msgstr ""

#: lib/eventhandler/webhookeventhandler.py:87
msgid "The encoding that is sent to the WebHook, for example json"
msgstr ""

#: lib/eventhandler/webhookeventhandler.py:95
#, python-brace-format
msgid ""
"You can use the following placeholders: {logged_in_user}, {realm}, "
"{surname}, {token_owner}, {user_realm}, {token_serial}. However, tag "
"availability is depending on the endpoint."
msgstr ""

#: lib/eventhandler/webhookeventhandler.py:102
msgid "The data posted in the WebHook"
msgstr ""

#: lib/machines/ldap.py:336
#, python-format
msgid "Your LDAP config seems to be OK, %i machine objects found."
msgstr "您的LDAP配置似乎正常，%i 機器物件已找到。"

#: lib/resolvers/LDAPIdResolver.py:1146
#, fuzzy, python-brace-format
#| msgid ""
#| "Your LDAP config found {0!s} user objects, but only {1!s} with the "
#| "specified uidtype"
msgid ""
"Your LDAP config found {0!s} user objects in {2:.4f}s, but only {1!s} with "
"the specified uidtype."
msgstr "您的 LDAP 配置找到了 {0!s} 個用戶物件，但只有 {1!s} 具有指定的 uidtype"

#: lib/resolvers/LDAPIdResolver.py:1150
#, fuzzy, python-brace-format
#| msgid "Your LDAP config seems to be OK, {0!s} user objects found."
msgid "Your LDAP config seems to be OK, {0!s} user objects found in {1:.4f}s."
msgstr "您的LDAP配置似乎正常，找到 {0!s} 個用戶物件。"

#: lib/smsprovider/FirebaseProvider.py:199
msgid ""
"The filename of the JSON config file, that allows privacyIDEA to talk to the "
"Firebase REST API."
msgstr "JSON 配置檔的檔名，它允許 privacyIDEA 與 Firebase REST API 通信。"

#: lib/smsprovider/FirebaseProvider.py:204
msgid "Proxy setting for HTTPS connections to googleapis.com."
msgstr "用於 googleapis.com HTTPS 連接的代理設置。"

#: lib/smsprovider/HttpSMSProvider.py:249
msgid "The base URL of the HTTP Gateway"
msgstr "HTTP Gateway 的基本 URL"

#: lib/smsprovider/HttpSMSProvider.py:252
msgid "Should the HTTP Gateway be connected via an HTTP GET or POST request."
msgstr "是否應通過 HTTP GET 或 POST 請求連接 HTTP Gateway。"

#: lib/smsprovider/HttpSMSProvider.py:257
msgid ""
"Specify a substring, that indicates, that the SMS was delivered successfully."
msgstr "指定一個子字串，該子字串指示SMS已成功傳遞。"

#: lib/smsprovider/HttpSMSProvider.py:261
msgid ""
"Specify a substring, that indicates, that the SMS failed to be delivered."
msgstr "指定一個子字串，該子字串指示SMS無法傳遞。"

#: lib/smsprovider/HttpSMSProvider.py:265
msgid "Username in case of basic authentication."
msgstr "基本身份驗證情況下的使用者名。"

#: lib/smsprovider/HttpSMSProvider.py:269
msgid "Password in case of basic authentication."
msgstr "基本身份驗證情況下的密碼。"

#: lib/smsprovider/HttpSMSProvider.py:274
msgid "Should the SSL certificate be verified."
msgstr "是否應驗證 SSL 證書。"

#: lib/smsprovider/HttpSMSProvider.py:280
msgid "Should the data in a POST Request be sent as JSON."
msgstr ""

#: lib/smsprovider/HttpSMSProvider.py:287
msgid ""
"An optional proxy string. DEPRECATED. Do not use this anymore. Rather use "
"HTTP_PROXY for http connections and HTTPS_PROXY for https connection. The "
"PROXY option will be removed in future."
msgstr ""
"可選取的代理字串。荒廢的。不要再使用它了。而是將HTTP_PROXY用於HTTP連接，而"
"HTTPS_PROXY用於HTTPs連接。代理選項將在將來刪除。"

#: lib/smsprovider/HttpSMSProvider.py:292
msgid "Proxy setting for HTTP connections."
msgstr "HTTP 連接的代理設置。"

#: lib/smsprovider/HttpSMSProvider.py:293
msgid "Proxy setting for HTTPS connections."
msgstr "HTTPS 連接的代理設置。"

#: lib/smsprovider/HttpSMSProvider.py:294
msgid "The timeout in seconds."
msgstr "超時（以秒為單位）。"

#: lib/smsprovider/SMSProvider.py:74
#, fuzzy
msgid ""
"Regular expression to modify the phone number to make it compatible with the "
"provider. For example to remove pluses and slashes enter something like '/[\\"
"+/]//'."
msgstr ""
"正則表達式，用於修改電話號碼以使其與提供程式相容。輸入類似\"/[\\+/]/\"的內容"
"以刪除加號和斜杠。"

#: lib/smsprovider/ScriptSMSProvider.py:113
msgid ""
"The script in script directory PI_SCRIPT_SMSPROVIDER_DIRECTORY to call. "
"Expects phone as the parameter and the message from stdin."
msgstr ""
"腳本目錄中的腳本PI_SCRIPT_SMSPROVIDER_DIRECTORY調用。期望電話作為參數和來自 "
"stdin 的消息。"

#: lib/smsprovider/SmppSMSProvider.py:125
msgid "SMSC Host IP"
msgstr "SMSC 主機 IP"

#: lib/smsprovider/SmppSMSProvider.py:128
msgid "SMSC Port"
msgstr "SMSC Port"

#: lib/smsprovider/SmppSMSProvider.py:130
msgid "SMSC Service ID"
msgstr "SMSC 服務 ID"

#: lib/smsprovider/SmppSMSProvider.py:132
msgid "Password for authentication on SMSC"
msgstr "用於在 SMSC 上進行身份驗證的密碼"

#: lib/smsprovider/SmppSMSProvider.py:134
msgid "SOURCE_ADDR_TON Special Flag"
msgstr "SOURCE_ADDR_TON 特別標誌"

#: lib/smsprovider/SmppSMSProvider.py:136
msgid "S_ADDR_NPI Special Flag"
msgstr "S_ADDR_NPI特別標誌"

#: lib/smsprovider/SmppSMSProvider.py:138
msgid "Source address (SMS sender)"
msgstr "來源位址（簡訊發件者）"

#: lib/smsprovider/SmppSMSProvider.py:139
msgid "DESTINATION_ADDR_TON Special Flag"
msgstr "DESTINATION_ADDR_TON 特別標誌"

#: lib/smsprovider/SmppSMSProvider.py:140
msgid "D_ADDR_NPI Special Flag"
msgstr "D_ADDR_NPI 特殊旗幟"

#: lib/task/eventcounter.py:41
msgid "The name of the event counter to read."
msgstr "要讀取的事件計數器的名稱。"

#: lib/task/eventcounter.py:46
msgid "The name of the stats key to write to the MonitoringStats table."
msgstr "要寫入監控統計資訊表的統計資訊鍵的名稱。"

#: lib/task/eventcounter.py:52
msgid ""
"Whether to reset the event_counter, if it is read and written to the "
"MonitoringStats table."
msgstr "是否重置event_counter，如果將其讀取並寫入監控統計表。"

#: lib/task/simplestats.py:46
msgid "Total number of tokens"
msgstr "令牌總數"

#: lib/task/simplestats.py:49
msgid "Total number of hardware tokens"
msgstr "硬體令牌總數"

#: lib/task/simplestats.py:52
msgid "Total number of software tokens"
msgstr "軟體令牌總數"

#: lib/task/simplestats.py:55
msgid "Number of hardware tokens not assigned to a user"
msgstr "未分配給使用者的硬體令牌數"

#: lib/task/simplestats.py:58
msgid "Number of tokens assigned to users"
msgstr "分配給使用者的令牌數"

#: lib/task/simplestats.py:61
msgid "Number of users with tokens assigned"
msgstr "分配了令牌的用戶數"

#: lib/tokens/applicationspecificpasswordtoken.py:74
msgid ""
"Application Specific Password: A token with a fixed password. Can be used "
"for certain applications or services."
msgstr ""

#: lib/tokens/applicationspecificpasswordtoken.py:85
#, fuzzy
msgid ""
"The user may only have this maximum number of application specific password "
"tokens assigned."
msgstr "使用者只能分配此最大數量的活動密碼令牌。"

#: lib/tokens/applicationspecificpasswordtoken.py:91
#, fuzzy
msgid ""
"The user may only have this maximum number of active application specific "
"password tokens assigned."
msgstr "使用者只能分配此最大數量的活動密碼令牌。"

#: lib/tokens/certificatetoken.py:282
msgid "Certificate: Enroll an x509 Certificate Token."
msgstr "證書：註冊 x509 證書令牌。"

#: lib/tokens/certificatetoken.py:293
msgid "The user may only have this maximum number of certificates assigned."
msgstr "使用者只能分配此最大數量的證書。"

#: lib/tokens/certificatetoken.py:298
msgid ""
"The user may only have this maximum number of active certificates assigned."
msgstr "使用者只能分配此最大數量的活動證書。"

#: lib/tokens/certificatetoken.py:303
msgid ""
"Enrolling a certificate token can require an attestation certificate. "
"(Default: ignore)"
msgstr "註冊證書令牌可能需要證明證書。（預設值：忽略）"

#: lib/tokens/certificatetoken.py:312
msgid "The CA connector that should be used during certificate enrollment."
msgstr ""

#: lib/tokens/certificatetoken.py:318
msgid "The template that should be used to issue a certificate."
msgstr ""

#: lib/tokens/certificatetoken.py:323
msgid ""
"This takes a space separated list of elements to be added to the subject. "
"Can be 'email' and 'realm'."
msgstr ""

#: lib/tokens/certificatetoken.py:331 lib/tokens/certificatetoken.py:338
msgid "The directory containing attestation certificate chains."
msgstr "包含證明證書鏈的目錄。"

#: lib/tokens/daplugtoken.py:124
msgid "event based OTP token using the HOTP algorithm"
msgstr "使用 HOTP 演算法的基於事件的 OTP 令牌"

#: lib/tokens/daplugtoken.py:130
msgid "The user may only have this maximum number of daplug tokens assigned."
msgstr "使用者只能分配此最大數量的 daplug 令牌。"

#: lib/tokens/daplugtoken.py:135
msgid ""
"The user may only have this maximum number of active daplug tokens assigned."
msgstr "使用者只能分配此最大數量的活動 daplug 令牌。"

#: lib/tokens/daypasswordtoken.py:35
#, fuzzy
msgid "Specify the time step of the DayPassword token. For example: \"24h\""
msgstr "設置令牌的失敗計數器。"

#: lib/tokens/daypasswordtoken.py:83
msgid ""
"DayPassword: A time-based token with a variable timestep and the possibility "
"to use the OTP more than once."
msgstr ""

#: lib/tokens/daypasswordtoken.py:120 lib/tokens/hotptoken.py:173
#: lib/tokens/totptoken.py:158
msgid "Enforce setting an app pin for the privacyIDEA Authenticator App"
msgstr "強制為privacyIDEA 身份驗證器設置一個APP PIN"

#: lib/tokens/daypasswordtoken.py:125
#, fuzzy
msgid ""
"The user may only have this maximum number of daypassword tokens assigned."
msgstr "使用者只能分配此最大數量的密碼令牌。"

#: lib/tokens/daypasswordtoken.py:131
#, fuzzy
msgid ""
"The user may only have this maximum number of active daypassword tokens "
"assigned."
msgstr "使用者只能分配此最大數量的活動密碼令牌。"

#: lib/tokens/emailtoken.py:156
msgid "EMail Token"
msgstr "電子郵件令牌"

#: lib/tokens/emailtoken.py:158
msgid "EMail: Send a One Time Password to the users email address."
msgstr "電子郵件：將一次性密碼發送到使用者的電子郵件位址。"

#: lib/tokens/emailtoken.py:166
#, python-brace-format
msgid ""
"The text that will be sent via EMail for an EMail-token. Several tags like "
"{otp} and {serial} can be used as parameters. You may also specify a "
"filename as email template starting with \"file:\"."
msgstr ""
"將通過電子郵件發送的電子郵件令牌的文字。使用{otp}和{serial}作為參數。您還可以"
"將文件名指定為以“file:”開頭的電子郵件模板。"

#: lib/tokens/emailtoken.py:175
#, python-brace-format
msgid ""
"The subject of the EMail for an EMail token. Use tags like {otp} and "
"{serial} as parameters."
msgstr "電子郵件令牌的電子郵件的主題。使用{otp}和{serial}作為參數。"

#: lib/tokens/emailtoken.py:180
msgid ""
"If set, a new EMail OTP will be sent after successful authentication with "
"one EMail OTP."
msgstr ""
"如果設置，則在使用一個電子郵件 OTP 成功進行身份驗證後，將發送新的電子郵件 "
"OTP。"

#: lib/tokens/emailtoken.py:185
#, fuzzy
#| msgid ""
#| "Use an alternate challenge text for telling the user to enter the code "
#| "from the eMail."
msgid ""
"Use an alternative challenge text for telling the user to enter the code "
"from the e-mail. You can also use tags for automated replacement. Check out "
"the documentation for more details."
msgstr "使用替代質詢文本告訴使用者輸入電子郵件中的代碼。"

#: lib/tokens/emailtoken.py:195
msgid "The user may only have this maximum number of email tokens assigned."
msgstr "使用者只能分配此最大數量的電子郵件令牌。"

#: lib/tokens/emailtoken.py:200
msgid ""
"The user may only have this maximum number of active email tokens assigned."
msgstr "使用者只能分配此最大數量的活動電子郵件令牌。"

#: lib/tokens/emailtoken.py:282
#, fuzzy
#| msgid "Enter the OTP from the Email:"
msgid "Enter the OTP from the Email"
msgstr "從電子郵件中輸入OTP："

#: lib/tokens/emailtoken.py:324
msgid "The PIN was correct, but the EMail could not be sent!"
msgstr ""

#: lib/tokens/emailtoken.py:561
msgid "Please enter your new email address!"
msgstr ""

#: lib/tokens/emailtoken.py:601
msgid "The email address is not valid!"
msgstr ""

#: lib/tokens/foureyestoken.py:130
msgid "4Eyes Token: Use tokens of two or more users to authenticate"
msgstr "4Eyes 令牌：使用兩個或更多使用者的令牌進行身份驗證"

#: lib/tokens/foureyestoken.py:141
msgid "The user may only have this maximum number of 4eyes tokens assigned."
msgstr "使用者只能分配此最大數量的 4eyes 令牌。"

#: lib/tokens/foureyestoken.py:146
msgid ""
"The user may only have this maximum number of active 4eyes tokens assigned."
msgstr "使用者只能分配此最大數量的活動 daplug 令牌。"

#: lib/tokens/hotptoken.py:84
msgid "Please enter a valid OTP value of the new token."
msgstr ""

#: lib/tokens/hotptoken.py:97
msgid "Specify the hashing function to be used. Can be SHA1, SHA256 or SHA512."
msgstr "指定要使用的 hash。可以是 SHA1, SHA-256 或 SHA-512。"

#: lib/tokens/hotptoken.py:99
msgid "Specify the OTP length to be used. Can be 6 or 8 digits."
msgstr "指定要使用的 otplen。可以是 6 位或 8 位數位。"

#: lib/tokens/hotptoken.py:100
msgid "Force the key to be generated on the server."
msgstr "強制在伺服器上生成金鑰。"

#: lib/tokens/hotptoken.py:101
msgid "Specify whether users are allowed or forced to use two-step enrollment."
msgstr "指定是允許使用者還是強制使用者使用兩步註冊。"

#: lib/tokens/hotptoken.py:103
msgid ""
"Specify whether admins are allowed or forced to use two-step enrollment."
msgstr "指定是允許還是強制管理員使用兩步註冊。"

#: lib/tokens/hotptoken.py:140
msgid "HOTP: Event based One Time Passwords."
msgstr "HOTP：基於事件的一次性密碼。"

#: lib/tokens/hotptoken.py:148
msgid "The user may only have this maximum number of HOTP tokens assigned."
msgstr "使用者只能分配此最大數量的 HOTP 令牌。"

#: lib/tokens/hotptoken.py:153
msgid ""
"The user may only have this maximum number of active HOTP tokens assigned."
msgstr "使用者只能分配此最大數量的活動 HOTP 令牌。"

#: lib/tokens/hotptoken.py:158 lib/tokens/totptoken.py:147
msgid "The size of the OTP seed part contributed by the client (in bytes)"
msgstr "用戶端貢獻的 OTP 種子部分的大小（以位元組為單位）"

#: lib/tokens/hotptoken.py:163 lib/tokens/totptoken.py:150
msgid "The size of the OTP seed part contributed by the server (in bytes)"
msgstr "伺服器貢獻的 OTP 種子部分的大小（以位元組為單位）"

#: lib/tokens/hotptoken.py:168 lib/tokens/totptoken.py:153
msgid ""
"The difficulty factor used for the OTP seed generation (should be at least "
"10000)"
msgstr "用於OTP種子產生的難度因數（應至少為10000）"

#: lib/tokens/hotptoken.py:279
msgid "URL for google Authenticator"
msgstr "谷歌身份驗證器的網址"

#: lib/tokens/hotptoken.py:291
msgid "URL for OATH token"
msgstr "OATH 令牌的網址"

#: lib/tokens/hotptoken.py:840
#, fuzzy
#| msgid "Please scan the QR code!"
msgid "Please scan the QR code and enter the OTP value!"
msgstr "請掃描二維碼"

#: lib/tokens/indexedsecrettoken.py:50
#, python-brace-format
msgid "Please enter the positions {0!s} from your secret."
msgstr "請輸入您的金鑰中的 {0!s} 位置。"

#: lib/tokens/indexedsecrettoken.py:99
msgid "Indexed Secret Token"
msgstr "索引秘密令牌"

#: lib/tokens/indexedsecrettoken.py:101
msgid ""
"IndexedSecret: Request certain positions of a shared secret from the user."
msgstr "已編入索引的機密：向使用者請求共享機密的某些位置。"

#: lib/tokens/indexedsecrettoken.py:109
#, fuzzy
#| msgid ""
#| "Use an alternate challenge text for telling the user which positions of "
#| "the secret he should enter."
msgid ""
"Use an alternative challenge text for telling the user which positions of "
"the secret he should enter. You can also use tags for automated replacement. "
"Check out the documentation for more details."
msgstr "使用備用質詢文本告訴使用者他應輸入機密的哪個位置。"

#: lib/tokens/indexedsecrettoken.py:117
msgid "Number of necessary positions to be answered by the user."
msgstr "使用者需要回答的必要位置的數量。"

#: lib/tokens/indexedsecrettoken.py:124
msgid "Preset the enrollment with the value of the given attribute."
msgstr "使用給定屬性的值預設註冊。"

#: lib/tokens/indexedsecrettoken.py:131 lib/tokens/indexedsecrettoken.py:138
msgid "The attribute whose value should be force set during enrollment."
msgstr "在註冊期間應強制設置其值的屬性。"

#: lib/tokens/indexedsecrettoken.py:145
msgid ""
"The user may only have this maximum number of indexed secret tokens assigned."
msgstr "使用者只能分配此最大數量的索引機密令牌。"

#: lib/tokens/indexedsecrettoken.py:150
msgid ""
"The user may only have this maximum number of active indexed secret tokens "
"assigned."
msgstr "使用者只能分配此最大數量的活動索引機密令牌。"

#: lib/tokens/motptoken.py:84
#, fuzzy
#| msgid "TOTP: Time based One Time Passwords."
msgid "mOTP: Classical mobile One Time Passwords."
msgstr "TOTP：基於時間的一次性密碼。"

#: lib/tokens/motptoken.py:102
msgid "The user may only have this maximum number of mOTP tokens assigned."
msgstr "使用者只能分配此最大數量的 mOTP 令牌。"

#: lib/tokens/motptoken.py:107
msgid ""
"The user may only have this maximum number of active mOTP tokens assigned."
msgstr "使用者只能分配此最大數量的活動 mOTP 令牌。"

#: lib/tokens/motptoken.py:149
#, fuzzy
#| msgid "URL for MOTP token"
msgid "URL for mOTP token"
msgstr "MOTP 令牌的網址"

#: lib/tokens/ocratoken.py:89
msgid "OCRA: Enroll an OCRA token."
msgstr "OCRA：註冊 OCRA 令牌。"

#: lib/tokens/ocratoken.py:99
msgid "The user may only have this maximum number of OCRA tokens assigned."
msgstr "使用者只能分配此最大數量的 OCRA 令牌。"

#: lib/tokens/ocratoken.py:104
msgid ""
"The user may only have this maximum number of active OCRA tokens assigned."
msgstr "使用者只能分配此最大數量的活動 OCRA 令牌。"

#: lib/tokens/papertoken.py:93
msgid "PPR: One Time Passwords printed on a sheet of paper."
msgstr ""

#: lib/tokens/papertoken.py:104 lib/tokens/tantoken.py:106
msgid "The number of OTP values, which are printed on the paper."
msgstr "列印在紙張上的 OTP 值的數量。"

#: lib/tokens/papertoken.py:109
msgid "The user may only have this maximum number of paper tokens assigned."
msgstr "使用者只能分配此最大數量的紙質令牌。"

#: lib/tokens/papertoken.py:114
msgid ""
"The user may only have this maximum number of active paper tokens assigned."
msgstr "使用者只能分配此最大數量的活動紙質令牌。"

#: lib/tokens/passkeytoken.py:95
msgid "Passkey: A secret stored on a device, unlocked with biometrics."
msgstr ""

#: lib/tokens/passkeytoken.py:104
#, fuzzy
#| msgid ""
#| "Use an alternate challenge text for telling the user to enter the code "
#| "from the eMail."
msgid ""
"Alternative challenge message to use when authenticating with a passkey.You "
"can also use tags for replacement, check the documentation for more details."
msgstr "使用替代質詢文本告訴使用者輸入電子郵件中的代碼。"

#: lib/tokens/passkeytoken.py:110
msgid ""
"When enabled, passkey token can be triggered with the PIN or via the /"
"validate/triggerchallenge endpoint. For privacyIDEA plugins, this is not "
"recommended. It is advised to use a condition, for example on a user-agent, "
"with this policy."
msgstr ""

#: lib/tokens/passkeytoken.py:119
msgid ""
"Request attestation from the authenticator during the registration. The "
"attestation certificate will be saved in the token info. The default value "
"is 'none'."
msgstr ""

#: lib/tokens/passkeytoken.py:400
msgid "Please authenticate with your passkey!"
msgstr ""

#: lib/tokens/passkeytoken.py:404
#, fuzzy
#| msgid "Please confirm the authentication on your mobile device!"
msgid "Please confirm the registration with your passkey!"
msgstr "請在您的行動裝置上確認身份驗證！"

#: lib/tokens/passwordtoken.py:113
msgid ""
"A token with a fixed password. Can be combined  with the OTP PIN. Is used "
"for the lost token scenario."
msgstr "具有固定密碼的令牌。可與 OTP PIN 結合使用。用於丟失令牌方案。"

#: lib/tokens/passwordtoken.py:125
msgid "The user may only have this maximum number of password tokens assigned."
msgstr "使用者只能分配此最大數量的密碼令牌。"

#: lib/tokens/passwordtoken.py:130
msgid ""
"The user may only have this maximum number of active password tokens "
"assigned."
msgstr "使用者只能分配此最大數量的活動密碼令牌。"

#: lib/tokens/pushtoken.py:72
msgid "Please confirm the authentication on your mobile device!"
msgstr "請在您的行動裝置上確認身份驗證！"

#: lib/tokens/pushtoken.py:73
msgid ""
"Use the polling feature of your privacyIDEA Authenticator App to check for a "
"new Login request."
msgstr ""

#: lib/tokens/pushtoken.py:75
msgid "Do you want to confirm the login?"
msgstr "是否要確認登錄？"

#: lib/tokens/pushtoken.py:372
msgid "PUSH Token"
msgstr "推送令牌"

#: lib/tokens/pushtoken.py:374
msgid "PUSH: Send a push notification to a smartphone."
msgstr "推送：向智慧手機發送推送通知。"

#: lib/tokens/pushtoken.py:383
msgid "The configuration of your Firebase application."
msgstr "您的 Firebase 應用的配置。"

#: lib/tokens/pushtoken.py:391
msgid ""
"The URL the Push App should contact in the second enrollment step. Usually "
"it is the endpoint /ttype/push of the privacyIDEA server."
msgstr ""
"推送應用在第二個註冊步驟中應聯繫的URL。通常它是privacyIDEA伺服器的端點/ttype/"
"push。"

#: lib/tokens/pushtoken.py:397
msgid ""
"The second enrollment step must be completed within this time (in minutes)."
msgstr "第二個註冊步驟必須在此時間內完成（以分鐘為單位）。"

#: lib/tokens/pushtoken.py:401
msgid "The smartphone needs to verify SSL during the enrollment. (default 1)"
msgstr "智能手機需要在註冊期間驗證 SSL。（預設值 1）"

#: lib/tokens/pushtoken.py:407
msgid "The user may only have this maximum number of Push tokens assigned."
msgstr "使用者只能分配此最大數量的推送令牌。"

#: lib/tokens/pushtoken.py:412
msgid ""
"The user may only have this maximum number of active Push tokens assigned."
msgstr "使用者只能分配此最大數量的活動推送令牌。"

#: lib/tokens/pushtoken.py:418
msgid "Require to unlock the Smartphone before Push requests can be accepted"
msgstr ""

#: lib/tokens/pushtoken.py:425
#, python-brace-format
msgid ""
"The question the user sees on his mobile phone. Several tags like {serial} "
"and {client_ip} can be used as parameters."
msgstr ""

#: lib/tokens/pushtoken.py:431
msgid "The title of the notification, the user sees on his mobile phone."
msgstr "使用者在其行動電話上看到的通知的標題。"

#: lib/tokens/pushtoken.py:436
msgid "The smartphone needs to verify SSL during authentication. (default 1)"
msgstr "智能手機需要在身份驗證期間驗證 SSL。（預設值 1）"

#: lib/tokens/pushtoken.py:442
msgid "Require the user to confirm the login with a presence check."
msgstr ""

#: lib/tokens/pushtoken.py:447
#, python-brace-format
msgid ""
"The options that can be presented to the user to confirm the login. "
"<code>ALPHABETIC</code>: A-Z, <code>NUMERIC</code>: 01-99, <code>CUSTOM</"
"code>: user defined. Does only apply if <em>{0!s}</em> is set."
msgstr ""

#: lib/tokens/pushtoken.py:457
#, python-brace-format
msgid ""
"Custom options that can be presented to the user to confirm the login. The "
"string must contain at least 2 options and should be unique. The options are "
"separated by <code>:</code>. e.g.: <code>01:02:03:1A:1B:1C</code>. Does only "
"apply if <em>{0!s}</em> is set to <code>CUSTOM</code>."
msgstr ""

#: lib/tokens/pushtoken.py:467
#, python-brace-format
msgid ""
"The number of options the user is presented with to confirm the login. Does "
"only apply if <em>{0!s}</em> is set."
msgstr ""

#: lib/tokens/pushtoken.py:475
msgid ""
"Wait for number of seconds for the user to confirm the challenge in the "
"first request."
msgstr "等待秒數，以便使用者在第一個請求中確認質詢。"

#: lib/tokens/pushtoken.py:481
msgid "Configure whether to allow push tokens to poll for challenges"
msgstr "配置是否允許推送令牌輪詢質詢"

#: lib/tokens/pushtoken.py:616
msgid "URL for privacyIDEA Push Token"
msgstr "privacyIDEA 推送令牌的URL"

#: lib/tokens/pushtoken.py:1195
msgid "Please scan the QR code!"
msgstr "請掃描二維碼"

#: lib/tokens/questionnairetoken.py:96
msgid "Questionnaire: Enroll Questions for the user."
msgstr "調查表：為用戶註冊問題。"

#: lib/tokens/questionnairetoken.py:107
msgid "The user has to answer this number of questions during authentication."
msgstr "用戶必須在身份驗證期間回答這批問題。"

#: lib/tokens/questionnairetoken.py:115
msgid ""
"The user may only have this maximum number of questionaire tokens assigned."
msgstr "使用者只能分配此最大數量的提問者令牌。"

#: lib/tokens/questionnairetoken.py:120
msgid ""
"The user may only have this maximum number of active questionaire tokens "
"assigned."
msgstr "使用者只能分配此最大數量的活動提問者令牌。"

#: lib/tokens/questionnairetoken.py:164
#, python-format
msgid "You need to provide at least %s answers."
msgstr "您需要至少提供 %s 答案。"

#: lib/tokens/radiustoken.py:106
msgid "RADIUS: Forward authentication request to a RADIUS server."
msgstr "RADIUS：將身份驗證請求轉發到RADIUS伺服器。"

#: lib/tokens/radiustoken.py:115
msgid "The user may only have this maximum number of RADIUS tokens assigned."
msgstr "使用者只能分配此最大數量的RADIUS令牌。"

#: lib/tokens/radiustoken.py:121
msgid ""
"The user may only have this maximum number of active RADIUS tokens assigned."
msgstr "使用者只能分配此最大數量的活動RADIUS令牌。"

#: lib/tokens/registrationtoken.py:127
msgid ""
"Registration: A token that creates a registration code that can be used as a "
"second factor once."
msgstr "註冊：創建註冊碼的令牌，該註冊碼可用作第二因素一次。"

#: lib/tokens/registrationtoken.py:139
msgid ""
"The user may only have this maximum number of registration tokens assigned."
msgstr "使用者只能分配此最大數量的註冊令牌。"

#: lib/tokens/registrationtoken.py:145
msgid ""
"The user may only have this maximum number of active registration tokens "
"assigned."
msgstr "使用者只能分配此最大數量的活動註冊令牌。"

#: lib/tokens/remotetoken.py:112
msgid "Remote Token: Forward authentication request to another server."
msgstr "遠端令牌：將身份驗證請求轉發到另一台伺服器。"

#: lib/tokens/remotetoken.py:121 lib/tokens/totptoken.py:163
msgid "The user may only have this maximum number of remote tokens assigned."
msgstr "使用者只能分配此最大數量的遠端令牌。"

#: lib/tokens/remotetoken.py:127 lib/tokens/totptoken.py:169
msgid ""
"The user may only have this maximum number of active remote tokens assigned."
msgstr "使用者只能分配此最大數量的活動遠端令牌。"

#: lib/tokens/smstoken.py:195
msgid "SMS Token"
msgstr "短信令牌"

#: lib/tokens/smstoken.py:197
msgid "SMS: Send a One Time Password to the users mobile phone."
msgstr "短信：向用戶手機發送一次性密碼。"

#: lib/tokens/smstoken.py:206
#, python-brace-format
msgid ""
"The text that will be send via SMS for an SMS token. Use tags like {otp} and "
"{serial} as parameters."
msgstr "將通過簡訊發送的文本，用於簡訊令牌。使用{otp}和{serial}作為參數。"

#: lib/tokens/smstoken.py:213
msgid ""
"If set, a new SMS OTP will be sent after successful authentication with one "
"SMS OTP."
msgstr ""
"如果設置，在使用一個簡訊一次性密碼成功進行身份驗證后，將發送新的簡訊一次性密"
"碼。"

#: lib/tokens/smstoken.py:218
#, fuzzy
#| msgid ""
#| "Use an alternate challenge text for telling the user to enter the code "
#| "from the eMail."
msgid ""
"Use an alternative challenge text for telling the user to enter the code "
"from the SMS. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr "使用替代質詢文本告訴使用者輸入電子郵件中的代碼。"

#: lib/tokens/smstoken.py:229
msgid "Choose the gateways the administrator is allowed to set."
msgstr "選擇允許管理員設置的閘道。"

#: lib/tokens/smstoken.py:237
msgid "Choose the gateways the user is allowed to set."
msgstr "選擇允許使用者設置的Gateway。"

#: lib/tokens/smstoken.py:244
msgid "The user may only have this maximum number of SMS tokens assigned."
msgstr "使用者只能分配此最大數量的SMS令牌。"

#: lib/tokens/smstoken.py:250
msgid ""
"The user may only have this maximum number of active SMS tokens assigned."
msgstr "使用者只能分配此最大數量的活動SMS令牌。"

#: lib/tokens/smstoken.py:326
msgid "Enter the OTP from the SMS:"
msgstr "從簡訊中輸入OTP："

#: lib/tokens/smstoken.py:360
msgid "The PIN was correct, but the SMS could not be sent!"
msgstr ""

#: lib/tokens/smstoken.py:611
msgid "Please enter your new phone number!"
msgstr ""

#: lib/tokens/spasstoken.py:86
msgid "SPass: Simple Pass token. Static passwords."
msgstr "SPass：簡單傳遞令牌。靜態密碼。"

#: lib/tokens/spasstoken.py:98
msgid "The user may only have this maximum number of SPASS tokens assigned."
msgstr "使用者只能分配此最大數量的 SPASS 令牌。"

#: lib/tokens/spasstoken.py:104
msgid ""
"The user may only have this maximum number of active SPASS tokens assigned."
msgstr "使用者只能分配此最大數量的活動 SPASS 令牌。"

#: lib/tokens/sshkeytoken.py:82
msgid "SSH Public Key: The public SSH key."
msgstr "SSH 公鑰：公有 SSH 金鑰。"

#: lib/tokens/sshkeytoken.py:91
msgid "The user may only have this maximum number of SSH keys assigned."
msgstr "使用者只能分配此最大數量的 SSH 金鑰。"

#: lib/tokens/sshkeytoken.py:97
msgid "The user may only have this maximum number of active SSH keys assigned."
msgstr "使用者只能分配此最大數量的活動 SSH 金鑰。"

#: lib/tokens/tantoken.py:96
msgid "TAN: TANs printed on a sheet of paper."
msgstr ""

#: lib/tokens/tantoken.py:111
msgid "The user may only have this maximum number of TAN tokens assigned."
msgstr "使用者只能分配此最大數量的 TAN 令牌。"

#: lib/tokens/tantoken.py:117
msgid ""
"The user may only have this maximum number of active TAN tokens assigned."
msgstr "使用者只能分配此最大數量的活動 TAN 令牌。"

#: lib/tokens/tiqrtoken.py:156
msgid "TiQR: Enroll a TiQR token."
msgstr "TiQR：註冊 TiQR 令牌。"

#: lib/tokens/tiqrtoken.py:166
msgid "The user may only have this maximum number of TiQR tokens assigned."
msgstr "使用者只能分配此最大數量的 TiQR 令牌。"

#: lib/tokens/tiqrtoken.py:172
msgid ""
"The user may only have this maximum number of active TiQR tokens assigned."
msgstr "使用者只能分配此最大數量的活動 TiQR 令牌。"

#: lib/tokens/tiqrtoken.py:236
msgid "URL for TiQR enrollment"
msgstr "TiQR 註冊的網址"

#: lib/tokens/tiqrtoken.py:394
msgid "Please scan the QR Code"
msgstr "請掃描二維碼"

#: lib/tokens/totptoken.py:59
msgid "Specify the time step of the time-based OTP token."
msgstr ""

#: lib/tokens/totptoken.py:106
msgid "TOTP: Time based One Time Passwords."
msgstr "TOTP：基於時間的一次性密碼。"

#: lib/tokens/u2ftoken.py:248
#, fuzzy
#| msgid "TiQR: Enroll a TiQR token."
msgid "U2F: Enroll a U2F token."
msgstr "TiQR：註冊 TiQR 令牌。"

#: lib/tokens/u2ftoken.py:258
msgid "This is a list of FQDN hostnames trusting the registered U2F tokens."
msgstr "這是信任已註冊的U2F令牌的FQDN主機名的清單。"

#: lib/tokens/u2ftoken.py:262
#, fuzzy
#| msgid ""
#| "Use an alternate challenge text for telling the user to confirm with his "
#| "U2F device."
msgid ""
"Use an alternative challenge text for telling the user to confirm with his "
"U2F device. You can also use tags for automated replacement. Check out the "
"documentation for more details."
msgstr "使用備用質詢文本告訴使用者使用其 U2F 設備進行確認。"

#: lib/tokens/u2ftoken.py:272
msgid "Only specified U2F tokens are authorized."
msgstr "僅授權指定的 U2F 令牌。"

#: lib/tokens/u2ftoken.py:280
msgid "Only specified U2F tokens are allowed to be registered."
msgstr "只允許註冊指定的 U2F 令牌。"

#: lib/tokens/u2ftoken.py:285
msgid "Do not verify the U2F attestation certificate."
msgstr "不要驗證 U2F 證明證書。"

#: lib/tokens/u2ftoken.py:290
msgid "The user may only have this maximum number of U2F tokens assigned."
msgstr "使用者只能分配此最大數量的U2F令牌。"

#: lib/tokens/u2ftoken.py:296
msgid ""
"The user may only have this maximum number of active U2F tokens assigned."
msgstr "使用者只能分配此最大數量的活動U2F令牌。"

#: lib/tokens/u2ftoken.py:380
msgid "You need to define the appId in the token config!"
msgstr "您需要在令牌配置中定義 appId！"

#: lib/tokens/u2ftoken.py:444
#, python-brace-format
msgid "Please confirm with your U2F token ({0!s})"
msgstr "請使用您的 U2F 令牌 ({0!s}) 進行確認"

#: lib/tokens/vascotoken.py:99
msgid "VASCO Token: Authentication using VASCO tokens"
msgstr "VASCO 令牌：使用 VASCO 令牌進行身份驗證"

#: lib/tokens/vascotoken.py:108
msgid "The user may only have this maximum number of Vasco tokens assigned."
msgstr "使用者只能分配此最大數量的 Vasco 令牌。"

#: lib/tokens/vascotoken.py:114
msgid ""
"The user may only have this maximum number of active Vasco tokens assigned."
msgstr "使用者只能分配此最大數量的活動 Vasco 令牌。"

#: lib/tokens/webauthntoken.py:462
msgid "Generic WebAuthn Token"
msgstr "通用 WebAuthn 令牌"

#: lib/tokens/webauthntoken.py:472
#, python-brace-format
msgid "Please confirm with your WebAuthn token ({0!s})"
msgstr "請使用您的 WebAuthn 令牌 ({0!s}) 進行確認"

#: lib/tokens/webauthntoken.py:473
msgid "Please confirm with your WebAuthn token"
msgstr "請使用您的 WebAuthn 令牌進行確認"

#: lib/tokens/webauthntoken.py:554
msgid "WebAuthn: Enroll a Web Authentication token."
msgstr ""

#: lib/tokens/webauthntoken.py:564
msgid ""
"A list of transports to prefer to communicate with WebAuthn tokens. Default: "
"usb ble nfc internal (All standard transports)"
msgstr ""
"首選與 WebAuthn 令牌通信的傳輸清單。預設值：usb ble nfc 內部（所有標準傳輸）"

#: lib/tokens/webauthntoken.py:569
msgid ""
"The time in seconds the user has to confirm authorization on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"用戶必須在其 WebAuthn 令牌上確認授權的時間（以秒為單位）。注意：您將希望同時"
"增加 ChallengeValidityTime。默認值：60"

#: lib/tokens/webauthntoken.py:575
msgid ""
"Whether the user's identity should be verified when authenticating with a "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"使用 WebAuthn 令牌進行身份驗證時是否應驗證使用者的身份。預設值：首選（驗證權"
"杖是否支援使用者）"

#: lib/tokens/webauthntoken.py:585
#, fuzzy
#| msgid ""
#| "Use an alternative challenge text for telling the user to confirm with "
#| "his WebAuthn token."
msgid ""
"Use an alternative challenge text for telling the user to confirm the login "
"with his WebAuthn token. You can also use tags for automated replacement. "
"Check out the documentation for more details."
msgstr "使用替代質詢文本告訴使用者使用其WebAuthn令牌進行確認。"

#: lib/tokens/webauthntoken.py:594
msgid ""
"A list of WebAuthn authenticators acceptable for authorization, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"可接受授權的 WebAuthn 身份驗證器清單，以空格分隔的 AAGUID 清單的形式給出。默"
"認情況下，所有身份驗證器都是可以接受的。"

#: lib/tokens/webauthntoken.py:600
msgid "Only the specified WebAuthn-tokens are authorized."
msgstr "僅授權指定的 WebAuthn 令牌。"

#: lib/tokens/webauthntoken.py:607
msgid "One webauthn token can not be registered to a user more than once."
msgstr ""

#: lib/tokens/webauthntoken.py:612
#, fuzzy
msgid "A human-readable name for the organization rolling out WebAuthn tokens."
msgstr "推出 WebAuthn 令牌的組織的用戶可讀名稱。"

#: lib/tokens/webauthntoken.py:617
msgid ""
"A domain name that is a subset of the respective FQDNs for all the "
"webservices the users should be able to sign in to using WebAuthn tokens."
msgstr ""
"功能變數名稱是使用者應該能夠使用 WebAuthn 令牌登錄到的所有 Web 服務的相應 "
"FQDN 的子集。"

#: lib/tokens/webauthntoken.py:623
msgid ""
"The time in seconds the user has to confirm enrollment on his WebAuthn "
"token. Note: You will want to increase the ChallengeValidityTime along with "
"this. Default: 60"
msgstr ""
"用戶必須在其 WebAuthn 令牌上確認註冊的時間（以秒為單位）。注意：您將希望同時"
"增加 ChallengeValidityTime。默認值：60"

#: lib/tokens/webauthntoken.py:630
msgid ""
"Whether to limit roll out of WebAuthn tokens to either only platform "
"authenticators, or only cross-platform authenticators. Default: either"
msgstr ""
"是將 WebAuthn 令牌的推出限制為僅平臺身份驗證器，還是僅跨平臺身份驗證器。默認"
"值：任一"

#: lib/tokens/webauthntoken.py:641
msgid ""
"A list of WebAuthn authenticators acceptable for enrollment, given as a "
"space-separated list of AAGUIDs. Per default all authenticators are "
"acceptable."
msgstr ""
"可接受註冊的 WebAuthn 身份驗證器清單，以空格分隔的 AAGUID 清單的形式給出。默"
"認情況下，所有身份驗證器都是可以接受的。"

#: lib/tokens/webauthntoken.py:647
msgid ""
"Whether the user's identity should be verified when rolling out a new "
"WebAuthn token. Default: preferred (verify the user if supported by the "
"token)"
msgstr ""
"在推出新的 WebAuthn 令牌時是否應驗證使用者的身份。預設值：首選（驗證權杖是否"
"支援使用者）"

#: lib/tokens/webauthntoken.py:658
#, python-brace-format
msgid ""
"Which algorithm are available to use for creating public key credentials for "
"WebAuthn tokens. (Default: [{0!s}], Order: [{1!s}])"
msgstr ""

#: lib/tokens/webauthntoken.py:668
msgid ""
"Whether to request attestation data when enrolling a new WebAuthn token. "
"Note: for u2f_req to work with WebAuthn, this cannot be set to none. "
"Default: direct (ask for non-anonymized attestation data)"
msgstr ""
"註冊新的 WebAuthn 令牌時是否請求證明數據。注意：要u2f_req使用 WebAuthn，則不"
"能將其設置為 none。預設值：直接（要求提供非匿名證明數據）"

#: lib/tokens/webauthntoken.py:680
msgid ""
"Whether and how strictly to check authenticator attestation data. Note: If "
"the attestation form is none, the attestation level needs to also be none. "
"Default: untrusted (attestation is required, but can be unknown or self-"
"signed)"
msgstr ""
"是否以及如何嚴格檢查身份驗證器證明數據。注意：如果證明形式為 none，則證明級別"
"也必須為 none。預設值：不受信任（證明是必需的，但可以是未知的或自簽名的）"

#: lib/tokens/webauthntoken.py:692
msgid "Only the specified WebAuthn-tokens are allowed to be registered."
msgstr "只允許註冊指定的 WebAuthn 令牌。"

#: lib/tokens/webauthntoken.py:697
msgid "The user may only have this number of WebAuthn tokens assigned."
msgstr "使用者只能分配此數量的 WebAuthn 令牌。"

#: lib/tokens/webauthntoken.py:702
msgid "The user may only have this number of active WebAuthn tokens assigned."
msgstr "使用者只能分配此數量的活動 WebAuthn 令牌。"

#: lib/tokens/webauthntoken.py:707
#, fuzzy
#| msgid ""
#| "Use an alternative challenge text for telling the user to confirm with "
#| "his WebAuthn token."
msgid ""
"Use an alternative challenge text for telling the user to confirm the "
"enrollment with his WebAuthn device. You can also use tags for automated "
"replacement. Check out the documentation for more details."
msgstr "使用替代質詢文本告訴使用者使用其WebAuthn令牌進行確認。"

#: lib/tokens/yubicotoken.py:101
msgid "Yubikey Cloud mode: Forward authentication request to YubiCloud."
msgstr "Yubikey Cloud 模式：將身份驗證請求轉發到 YubiCloud。"

#: lib/tokens/yubicotoken.py:110
msgid "The user may only have this maximum number of Yubico tokens assigned."
msgstr "使用者只能分配此最大數量的 Yubico 令牌。"

#: lib/tokens/yubicotoken.py:116
msgid ""
"The user may only have this maximum number of active Yubico tokens assigned."
msgstr "使用者只能分配此最大數量的活動 Yubico 令牌。"

#: lib/tokens/yubikeytoken.py:164
msgid "Yubikey AES mode: One Time Passwords with Yubikey."
msgstr "Yubikey AES模式：使用Yubikey的一次性密碼。"

#: lib/tokens/yubikeytoken.py:173
msgid "The user may only have this maximum number of Yubikey tokens assigned."
msgstr "使用者只能分配此最大數量的 Yubikey 令牌。"

#: lib/tokens/yubikeytoken.py:179
msgid ""
"The user may only have this maximum number of active Yubikey tokens assigned."
msgstr "使用者只能分配此最大數量的活動 Yubikey 令牌。"

#: lib/tokens/yubikeytoken.py:184
msgid ""
"The Yubikey access code can be read by an enrollment client to initialize "
"Yubikeys."
msgstr "用於初始化 Yubikey 的 Yubikey 存取代碼。"

#: lib/utils/compare.py:189
msgid "true if the value of the left attribute contains the right value"
msgstr "如果 left 屬性的值包含右值，則為 true"

#: lib/utils/compare.py:190
msgid "false if the value of the left attribute contains the right value"
msgstr "如果 left 屬性的值包含右值，則為 true"

#: lib/utils/compare.py:192
msgid "true if the value of the left attribute equals the right value"
msgstr "如果 left 屬性的值等於右值，則為 true"

#: lib/utils/compare.py:193
msgid "false if the value of the left attribute equals the right value"
msgstr "如果左屬性的值等於右值，則為 false"

#: lib/utils/compare.py:195
msgid ""
"true if the value of the left attribute completely matches the given regular "
"expression pattern on the right"
msgstr "如果左側屬性的值與右側給定的正則表達式模式完全匹配，則為 true"

#: lib/utils/compare.py:196
msgid ""
"false if the value of the left attribute completely matches the given "
"regular expression pattern on the right"
msgstr "如果左側屬性的值與右側給定的正則表達式模式完全匹配，則為 false"

#: lib/utils/compare.py:198
msgid ""
"true if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr "如果左側屬性的值包含在右側的逗號分隔值中，則為 true"

#: lib/utils/compare.py:199
msgid ""
"false if the value of the left attribute is contained in the comma-separated "
"values on the right"
msgstr "如果左側屬性的值包含在右側的逗號分隔值中，則為 false"

#: lib/utils/compare.py:201
msgid ""
"true if the integer value of the left attribute is smaller than the right "
"integer value"
msgstr "如果左側屬性的整數值小於右側整數值，則為 true"

#: lib/utils/compare.py:202
msgid ""
"true if the integer value of the left attribute is bigger than the right "
"integer value"
msgstr "如果左側屬性的整數值大於右側整數值，則為 true"

#, fuzzy
#~ msgid "Admin is allowed to register containers for synchronization."
#~ msgstr "允許用戶設置令牌描述。"

#, fuzzy
#~ msgid "Admin is allowed to unregister containers from synchronization."
#~ msgstr "允許用戶設置令牌描述。"

#, fuzzy
#~| msgid "The user is allowed to delete his own tokens."
#~ msgid ""
#~ "Users are allowed to register their own containers for synchronization."
#~ msgstr "允許用戶刪除自己的令牌。"

#, fuzzy
#~| msgid "The user is allowed to enable his own tokens."
#~ msgid "Users are allowed to unregister containers from synchronization."
#~ msgstr "允許用戶啟用自己的令牌。"

#~ msgid "The body of the mail that is sent."
#~ msgstr "發送的郵件的正文。"

#~ msgid "The text of the SMS."
#~ msgstr "短信的文本。"

#~ msgid ""
#~ "This is the template content of the new file. Can contain the tags as "
#~ "specified in the documentation."
#~ msgstr "這是新檔的範本內容。可以包含文件中指定的標記。"

#~ msgid ""
#~ "Use an alternate challenge text for telling the user to enter an OTP "
#~ "value."
#~ msgstr "使用替代質詢文本告訴使用者輸入 OTP 值。"

#~ msgid ""
#~ "Use an alternate challenge text for telling the user to enter the code "
#~ "from the SMS."
#~ msgstr "使用備用質詢文本告訴使用者輸入簡訊中的代碼。"

#~ msgid ""
#~ "Use an alternate challenge text for telling the user to confirm with his "
#~ "WebAuthn device."
#~ msgstr "使用替代質詢文本告訴使用者使用其 WebAuthn 設備進行確認。"

#~ msgid "The question the user sees on his mobile phone."
#~ msgstr "用戶在行動電話上看到的問題。"

#~ msgid ""
#~ "Set label for a new enrolled Google Authenticator. Possible tags are &lt;"
#~ "u&gt; (user), &lt;r&gt; (realm), &lt;s&gt; (serial)."
#~ msgstr ""
#~ "為新註冊的Google身份驗證器設置標籤。可能的標籤是&lt;u&gt;（使用者），&lt;"
#~ "r&gt;（領域），&lt;s&gt;（序號）。"

#~ msgid "This is the issuer label for new enrolled Google Authenticators."
#~ msgstr "這是新註冊的Google身份驗證器的頒發者標籤。"

#~ msgid "This is the URL to the token image for smartphone apps like FreeOTP."
#~ msgstr "這是智慧手機應用程式（如FreeOTP）的令牌圖像的URL。"

#~ msgid ""
#~ "The project ID, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "用戶端應使用的專案ID。從您的 Firebase 控制台獲取它。"

#~ msgid ""
#~ "The project number, that the client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "客戶應使用的項目編號。從您的 Firebase 控制台獲取它。"

#~ msgid ""
#~ "The App ID, that the Android client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "應用ID，Android用戶端應使用。從您的 Firebase 控制台獲取它。"

#~ msgid ""
#~ "The API Key, that the Android client should use. Get it from your "
#~ "Firebase console."
#~ msgstr "Android 用戶端應使用的 API 金鑰。從您的 Firebase 控制台獲取它。"

#~ msgid ""
#~ "The App ID, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "iOS 用戶端應使用的應用ID。從您的 Firebase 控制台獲取它。"

#~ msgid ""
#~ "The API Key, that the iOS client should use. Get it from your Firebase "
#~ "console."
#~ msgstr "iOS 用戶端應使用的 API 金鑰。從您的 Firebase 控制台獲取它。"
